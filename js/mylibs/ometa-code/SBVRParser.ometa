/*
Copyright 2011 University of Surrey

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

//A parser for Semantics of Business Vocabulary and Rules (SBVR), an OMG standard.
//Converts from Structured English (SBVR-SE) to Logical Formulation (SBVR-LF)
//Specification: http://www.omg.org/spec/SBVR/1.0/

ometa SBVRParser {
	isTerm		:x	= ?this._isTerm(x),
	isVerb		:x	= ?this._isVerb(x),
	isFctp		:x	= ?this._isFctp(x),

	findVar		:x	= {this.ruleVars[x[1]]},
	bind		:x	= findVar(x):y											-> [`bind, x, y],

	letters			= letter+:l												-> l.join(''),
	num				= spaces digit+:n										-> ['num', parseInt(n.join(''))]
					| "one"													-> ['num', 1],
	toEOL			= spaces (~(spaces lineStart) anything)*:w				-> w.join(''),

	token		:x	= spaces seq(x):s &(space+)								-> s,

	addTerm			= &(termPart+):t {this.possMap.term[t.join(' ')] = true}
					  term,
	term		:x  = termPart:t {x = x==undefined ? t : [x, t].join(' ')}
						( term(x)
						| isTerm(x)											-> ['term',this._termForm(x)]
						),
	termPart		= spaces ~lineStart letters,
	
	
	addVerb			= &((verbPart)+):v {this.possMap.verb[v.join(' ')] = true}
					  verb,
	verb		:x  = verbPart:v {x = x==undefined ? v : [x, v].join(' ')}
						( verb(x)
						| isVerb(x)											-> ['verb',this._verbForm(x)]
						),
	verbPart		= spaces ~lineStart ~term letters,
	
	joinQuant		= matchForAll('keyword',["and","at","most"]),
	quant			= keyword("each")										-> [`univQ]
					| matchForAny('keyword',["a","an","some"])										-> [`existQ]
					| matchForAll('keyword',["at","most"])		num:n		-> [`atMostQ, [`maxCard, n]]
					| matchForAll('keyword',["at","least"])		num:n
										( joinQuant num:m					-> [`numRngQ, [`minCard, n], [`maxCard, m]]
										| empty 							-> [`atLeastQ, [`minCard, n]])
					| matchForAll('keyword',["more","than"])	num:n {++n[1]}
																			-> [`atLeastQ, [`minCard, n]]
					| keyword("exactly")						num:n		-> [`exactQ, [`card, n]],

	keyword		:x	= token(x),
	adVar		:x	= {this.ruleVars[x[1]] = this.ruleVarsCount++} {['var', ['num', this.ruleVars[x[1]]], x]}:v
					( keyword("that")
						( keyword("the") terbRi([[]], x)
						| qTerbRi([[]], x) ):q {v.push(q)}
					)?														-> v,

	atfo		:c	= isFctp(c[0]) {c[0] = ['fcTp'].concat(c[0])}			-> ['aFrm'].concat(c),

	terbRi    :c :i = term:t verb:v bind(t):b {c[0].push(t,v);c.push(b)} (qTerbRi(c,i)),

	qTerbRi   :c :i = (quant:q term:t adVar(t):a verb:v bind(t):b
							{q.push(a);c[0].push(t,v);c.push(b)}
							(qTerbRi(c,i)):r								-> q.concat([r])
						| verb:v bind(i):b {c[0].push(i,v);c.push(b)} (atfo(c)|qTerbR(c)|qTerm(c))
						| bind(i):b {c[0].push(i);c.push(b)} atfo(c)
					),

	qTerm		:c	= quant:q term:t adVar(t):a bind(t):b {q.push(a);c[0].push(t);c.push(b)}
							atfo(c):r											-> q.concat([r]),

	qTerbR		:c	= quant:q term:t adVar(t):a verb:v bind(t):b {q.push(a);c[0].push(t,v);c.push(b)}
							(atfo(c)|qTerbR(c)|qTerm(c)):r						-> q.concat([r]),

	modRule			= "It" "is" 
						( "obligatory"		-> ['obl']
						| "necessary"		-> ['nec']
						| "prohibited"		-> ['obl', ['neg']]
						| "impossible"		-> ['nec', ['neg']]
						| "not" "possible"	-> ['nec', ['neg']]
						| "possible"		-> ['pos']
						| "permissible"		-> ['prm']
						):r
					  "that"											-> r,

	startRule		= "R:",
	newRule			= startRule spaces &((~(spaces lineStart) char)*):ruleText {this.ruleVarsCount=1}
						modRule:r qTerbR([[]]):q {r.length == 2 ? r[1][1] = q : r[1] = q}
																		-> ['rule', r, ['text', ruleText.join('')]],
	terb			= term:t addVerb:v									-> [t, v],
	startFactType	= "F:",
	newFactType		= startFactType {[]}:t (terb:b {t.concat(b)}:t)+ (term:e {t.push(e)})? {this.fctps[t] = true}
																		-> [`fcTp].concat(t),
	startTerm		= "T:",
	newTerm			= startTerm addTerm:t {t.push([])}					-> t,
	attribute		= ?{this.lines[this.lines.length-1][0] == 'term'}
						allowedAttrs:attrName ':' toEOL:attrVal			-> {var lastLine = this.lines.pop(); lastLine[2].push([attrName.replace(new RegExp(' ','g'),''), attrVal]); lastLine},
						
	allowedAttrs	= matchForAny('seq',this.possMap.allowedAttrs),

	lineStart		= startTerm
					| startFactType
					| startRule
					| allowedAttrs ':',
	line			= spaces (newTerm | newFactType | newRule | attribute):l spaces
						{this.lines.push(l)}							-> l,
	expr			= line*												-> this.lines
}

SBVRParser.keyTokens = ["startTerm", "startFactType", "startRule", "term", "modRule", "verb", "keyword", "allowedAttrs", "num"];

/**
	Following are "instance" variables/functions rather than shared.
*/
SBVRParser.initialize = function() {
	this.reset();
}

SBVRParser._isTerm = function(k) {
	return this.possMap.term.hasOwnProperty(k) || this.possMap.term.hasOwnProperty(k.singularize())
}

SBVRParser._termForm = function(k) {
	return this.possMap.term.hasOwnProperty(k.singularize()) ? k.singularize() : k
}

SBVRParser._isVerb = function(k) {
	if(this.possMap.verb.hasOwnProperty(k))                                               { return true }
	else if( k.slice(0,3)=='are' && this.possMap.verb.hasOwnProperty('is' + k.slice(3)) ) { return true }
	else if(k=='have' && this.possMap.verb.hasOwnProperty('has'))                         { return true }
	else return false
}

SBVRParser._verbForm = function(k) {
	if(k.slice(0,3)=='are' && this.possMap.verb.hasOwnProperty('is' + k.slice(3))){ return 'is' + k.slice(3) }
	else if(k=='have' && this.possMap.verb.hasOwnProperty('has'))                 { return 'has'}
	else return k
}

SBVRParser._isFctp = function(k) { return this.fctps.hasOwnProperty(k) }

SBVRParser.reset = function() {
	this.possMap = {
		startTerm: ['T:'],
		startFactType: ['F:'],
		startRule: ['R:'],
		term: {},
		verb: {},
		allowedAttrs: [
			'Concept Type',
			/* Custom Attributes */
			'Database ID Field',
			'Database Name Field',
			'Database Table Name',
			/* End Custom */
			'Definition',
			'Dictionary Basis',
			'Example',
			'General Concept',
			'Namespace URI',
			'Necessity',
			'Note',
			'Possibility',
			'Reference Scheme',
			'See',
			'Source',
			'Subject Field',
			'Synonymous Form',
			'Synonym'
		],
		modRule: [
			'It is obligatory that',
			'It is necessary that',
			'It is prohibited that',
			'It is impossible that',
			'It is not possible that',
			'It is possible that',
			'It is permissible that'
		],
		quant: [
			'each',
			'a',
			'an',
			'some',
			'at most',
			'at least',
//			'and at most',
			'more than',
			"exactly"
		],
		joinQuant: ['and at most'],
		num: [
			'1', '2', '3', '4', '5', '6', '7', '8', '9',
			'one'
		]
	}
	this.fctps = {}
	this.ruleVars = {}
	this.ruleVarsCount = 0
	this.lines = ['model']
}

SBVRParser.equals = function(compareTo) {
	if(this.possMap.verb.length != compareTo.possMap.verb.length) return false
	for(var i = this.possMap.verb.length - 1; i >= 0; i--) {
		if(this.possMap.verb[i] != compareTo.possMap.verb.length) return false
	}
	for(var x in this.possMap.term) {
		if(!compareTo.possMap.term.hasOwnProperty(x)) return false
	}
	for(var x in compareTo.possMap.term) {
		if(!this.possMap.term.hasOwnProperty(x)) return false
	}
	return true
}


/** **/
SBVRParser.matchForAny = function(rule,arr) {
	var origInput = this.input
	for (var idx = 0; idx < arr.length; idx++)
		try { this.input = origInput; return this._applyWithArgs.call(this, rule, arr[idx]) }
		catch (f) {
			if (f != fail) {
				console.log(f.stack)
				throw f
			}
		}
	throw fail
}
SBVRParser.matchForAll = function(rule,arr) {
	var ret
	for (var idx = 0; idx < arr.length; idx++)
		ret = this._applyWithArgs.call(this, rule, arr[idx])
	return ret
}