if(typeof SBVR_SERVER_ENABLED === 'undefined') SBVR_SERVER_ENABLED = true;

define(['sbvr-parser/SBVRLibs', 'underscore', 'ometa-core', 'inflection'], function(SBVRLibs) {
	//A parser for Semantics of Business Vocabulary and Rules (SBVR), an OMG standard.
	//Converts from Structured English (SBVR-SE) to Logical Formulation (SBVR-LF)
	//Specification: http://www.omg.org/spec/SBVR/1.0/

	ometa SBVRParser <: SBVRLibs {
		EOL =
			(	'\n'
			|	'\r'
				'\n'?
			),
		EOLSpaces =
			{false}:eol
			(	EOL
				{true}:eol
			|	space
			)*
			?eol,
		Bind :identifier :bindings =
			// Check a var exists to bind to.
			?(this.ruleVars.hasOwnProperty(identifier[1]))
			{['RoleBinding', identifier, this.ruleVars[identifier[1]]]}:binding
			(	?bindings
				{bindings.push(binding)}
			)?
			-> binding,

		spaces =
			(	~EOL
				space
			)*,

		letters =
			<letter+>,
		Number =
			(	spaces <digit+>:n
				-> ['Number', parseInt(n, 10)]
			|	"one"
				-> ['Number', 1]
			),
		Value :stopOn =
			(	spaces
				~token(stopOn)
				<letterOrDigit+>
			)+:value
			-> value.join(''),
		toSBVREOL =
			spaces
			<	(	spaces
					(	InformalIdentifier
					|	'\'' InformalIdentifier '\''
					|	(	~space
							anything
						)+
					)
				)*
			>,
		toEOL =
			<	(	~EOL
					anything
				)*
			>,

		token :x =
			spaces seq(x):s
			&(	space
			|	end
			)
			-> s,

		AddIdentifier :identifierType :baseSynonym =
			&(IdentifierPart+):identifier
			{identifier.join(' ')}:identifier
			// Make sure the identifier isn't taken.
			?(!this.identifierChildren.hasOwnProperty(identifier))
			_AddIdentifier(identifierType, identifier, baseSynonym)
			apply(identifierType),
		
		InformalIdentifier =
			Identifier(undefined, true),
		Identifier :factTypeSoFar :noAutoComplete =
			~(<Term(factTypeSoFar)?>:term)?
			~(<Name(factTypeSoFar)?>:name)?
			?(!noAutoComplete || term || name)
			(	?(term.length > name.length)
				Term(factTypeSoFar)
			|	Name(factTypeSoFar)
			),
		Name :factTypeSoFar =
			FindIdentifier('Name', factTypeSoFar),
		Term :factTypeSoFar =
			FindIdentifier('Term', factTypeSoFar),
		FindIdentifier :identifierType :factTypeSoFar =
			spaces
			'\''?:quote
			FindIdentifierNest(identifierType, factTypeSoFar):identifier
			(	?(!quote)
			|	seq(quote)
			)
			-> identifier,
		FindIdentifierNest :identifierType :factTypeSoFar :identifierSoFar =
			IdentifierPart:part
			(	?identifierSoFar
				-> (identifierSoFar + ' ' + part)
			|	-> part
			):identifierSoFar
			// Make sure the potential identifier so far is short enough to be valid.
			?(identifierSoFar.length <= this.longestIdentifier[identifierType])
			(	FindIdentifierNest(identifierType, factTypeSoFar, identifierSoFar)
			|	IsFactTypeIdentifier(identifierType, factTypeSoFar, identifierSoFar):factTypeIdentifier
				?(factTypeIdentifier !== false)
				-> [identifierType, factTypeIdentifier]
			),
		IdentifierPart =
			spaces
			<	(	letters
				|	'-'
				)+
			>,
		
		
		addVerb =
			clearSuggestions Verb(true),
		Verb :factTypeSoFar =
			FindVerb(factTypeSoFar),
		FindVerb :factTypeSoFar :verbSoFar =
			VerbPart:part
			(	?verbSoFar
				-> (verbSoFar + ' ' + part)
			|	-> part
			):verbSoFar
			(	FindVerb(factTypeSoFar, verbSoFar)
			|	(	?(factTypeSoFar===true)
				|	?this.isVerb(factTypeSoFar, verbSoFar)
				)
				-> ['Verb', this._verbForm(verbSoFar)]
			),
		VerbPart =
			spaces
			~Identifier
			IdentifierPart,
		
		JoiningQuantifier =
			matchForAll('keyword',["and","at","most"]),
		
		// Be very careful with anywhere you use quantifier as any in-place modifications of the array will be remembered in memoisation.
		Quantifier =
			(	keyword("each")
				-> ['UniversalQuantification']
			|	matchForAny('keyword',["a","an","some"])
				-> ['ExistentialQuantification']
			|	matchForAll('keyword',["at","most"]) Number:n
				-> ['AtMostNQuantification', ['MaximumCardinality', n]]
			|	matchForAll('keyword',["at","least"]) Number:n
				(	JoiningQuantifier
					Number:m
					-> ['NumericalRangeQuantification', ['MinimumCardinality', n], ['MaximumCardinality', m]]
				|	-> ['AtLeastNQuantification', ['MinimumCardinality', n]]
				)
			|	matchForAll('keyword',["more","than"]) Number:n {++n[1]}
				-> ['AtLeastNQuantification', ['MinimumCardinality', n]]
			|	keyword("exactly") Number:n
				-> ['ExactQuantification', ['Cardinality', n]]
			|	keyword("no")
				-> ['ExactQuantification', ['Cardinality', 0]]
			),

		keyword :word :noToken =
			(	?(noToken===true) seq(word)
			|	?(noToken!==true) token(word)
			),
		
		addThat =
			keyword("that"),
		addThe =
			keyword("the"),
		addComma =
			keyword(","),
		addOr =
			keyword("or"),
		createVar :identifier :unitary =
			{this.ruleVars[identifier[1]] = this.ruleVarsCount++}
			-> ['Variable', ['Number', this.ruleVars[identifier[1]]], identifier],
			// TODO: Add this unitary attribute along the entire compiler chain
			// -> ['Variable', ['Number', this.ruleVars[identifier[1]]], identifier, ['Unitary', unitary === true]],

		IsAtomicFormulation :factType :bindings =
			IsFactType(factType):realFactType
			?realFactType
			-> ['AtomicFormulation'].concat([['FactType'].concat(factType)], bindings),

		ClosedProjection :identifier :bind =
			addThat
			(	{[identifier]}:factType
				Verb(factType):verb {factType.push(verb)}
				(	RuleBody(factType, [bind])
				|	IsAtomicFormulation(factType, [bind])
				)
			|	RuleBody([], [], identifier, bind)
			),

		RuleBody :factType :bindings :parentIdentifier :parentBind =
			(	Quantifier:quant
				Term(factType):t createVar(t):tVar Bind(t, bindings):b {factType.push(t)}
				(	ClosedProjection(t, b):thatLF {tVar.push(thatLF)}
					addComma?
				)?
			|	addThe
				// TODO: Should be a "ReferencedTerm" or Name, rather than Identifier (which is Term or Name)
				Identifier(factType):identifier
				(	Bind(identifier, bindings)
				|	createVar(identifier, true):tVar
					// TODO: Do something with the var we create.
					Bind(identifier, bindings)
				)
				{factType.push(identifier)}
			)
			(	Verb(factType):v {factType.push(v)}
				{	if(parentIdentifier != null) {
						factType.push(parentIdentifier);
						bindings.push(parentBind);
					}
				}
				(	RuleBody(factType, bindings)
				|	IsAtomicFormulation(factType, bindings)
				)
			|	IsAtomicFormulation(factType, bindings)
			):lf
			-> (quant == null ? lf : quant.concat([tVar, lf])),

		Modifier =
			"It" "is" 
			(	"obligatory"
				-> ['ObligationFormulation']
			|	"necessary"	
				-> ['NecessityFormulation']
			|	"prohibited"
				-> ['ObligationFormulation', ['LogicalNegation']]
			|	"impossible"
				-> ['NecessityFormulation', ['LogicalNegation']]
			|	"not" "possible"
				-> ['NecessityFormulation', ['LogicalNegation']]
			|	"possible"
				-> ['PossibilityFormulation']
			|	"permitted"
				-> ['PermissibilityFormulation']
			):r
			"that"
			-> r,

		startRule =
			"R:"|"Rule:",
		newRule =
			startRule spaces &(toEOL):ruleText {this.ruleVarsCount=0}
			Modifier:r RuleBody([], []):q {r.length == 2 ? (r[1][1] = q) : (r[1] = q)}
			-> ['Rule', r, ['StructuredEnglish', ruleText]],
		startFactType =
			"F:"|"Fact type:",
		newFactType =
			startFactType {[]}:factType
			(Identifier:identifier addVerb:v {factType.push(identifier, v)})+
			(Identifier:identifier {factType.push(identifier)})?
			AddFactType(factType, factType) {factType.push(['Attributes'])}
			-> ['FactType'].concat(factType),
		StartTerm =
			(	"T:"
			|	"Term:"
			)
			-> 'Term',
		StartName =
			(	"N:"
			|	"Name:"
			)
			-> 'Name',
		NewIdentifier =
			(	StartTerm
			|	StartName
			):identifierType
			clearSuggestions
			AddIdentifier(identifierType):identifier
			{identifier.push(['Attributes'])}
			-> identifier,
		Attribute =
			{this.lines[this.lines.length-1]}:currentLine
			AllowedAttrs(currentLine[0]):attrName
			{attrName.replace(/ /g, '')}:attrName
			spaces
			ApplyFirstExisting(['Attr' + attrName, 'DefaultAttr'], [currentLine]):attrVal
			-> {var lastLine = this.lines.pop(); lastLine[lastLine.length-1].push([attrName, attrVal]); lastLine},
							
		AllowedAttrs :termOrFactType =
			matchForAny('seq',this.branches.AllowedAttrs.call(this, termOrFactType)):attrName
			-> attrName.replace(':',''),
		DefaultAttr :currentLine =
			toSBVREOL,
		AttrConceptType :currentLine =
			{currentLine[1]}:identifierName
			?(!this.conceptTypes.hasOwnProperty(identifierName)) // Only allow one instance of Concept Type: attribute.
											 // TODO: Improve this to deal with synonyms and autocomplete/highlighting.
			// A concept type has to be a term (cannot be a name)
			Term:term
			(	?(currentLine[0] == 'FactType')
			|	{term[1]}:termName
				?(identifierName != termName) // Do not allow a term to have itself as its concept type.
				{this.conceptTypes[identifierName] = termName}
				{this.identifierChildren[termName].push(identifierName)}
			)
			-> term,
		AttrDefinition :currentLine =
			(	addThe?
				// The following section is copied from RuleBody, should really be sorted properly.
				{this.ruleVarsCount=0}
				Term:t createVar(t):tVar Bind(t):b
				ClosedProjection(t, b):thatLF {tVar.push(thatLF)}
				(	?(currentLine[0] == 'FactType')
				|	{this.conceptTypes[currentLine[1]] = t[1]}
					{this.identifierChildren[t[1]].push(currentLine[1])}
				)?
				-> tVar
			|	Value('or'):name
				(	addOr clearSuggestions
					Value('or')
				)+:names
				{names.unshift(name)}
				-> ['Enum', names]
			),
		AttrGuidanceType :currentLine =
			matchForAny('seq', this.branches.AttrGuidanceType),
		AttrNecessity :currentLine =
			(	RuleBody([], [])
			|	toSBVREOL
			),
		AttrSynonym :currentLine =
			AddIdentifier(currentLine[0], currentLine[1]),
		AttrSynonymousForm :currentLine =
			{[]}:factType
			(	Identifier:identifier
				addVerb:v
				{factType.push(identifier, v)}
			)+
			(	Identifier:identifier
				{factType.push(identifier)}
			)?
			AddFactType(factType, currentLine.slice(1,-1))
			-> factType,
		AttrTermForm :currentLine =
			AddIdentifier('Term'):term
			{
				for(var i = 0; i < currentLine.length; i++) {
					if(currentLine[i][0] == 'Term') {
						var factType = [term, ['Verb', 'has'], currentLine[i]];
						this.AddFactType(factType, factType);
					}
				}
			}
		-> term,

		startComment =
			seq('--'),
		newComment =
			startComment toEOL,
		
		Terminator =
			spaces keyword('.',true),
		line =
			spaces
			(
				(	NewIdentifier
				|	newFactType
				|	newRule
				|	Attribute
				):l
				Terminator? clearSuggestions
				{this.lines.push(l)}
				-> l
			|	newComment
			),
		Process =
			line
			(	EOLSpaces
				line
			)*
			space*
			end
			-> this.lines
	}

	SBVRParser.clearSuggestions = function() {};
	/**
		Following are "instance" variables/functions rather than shared.
	*/
	SBVRParser.initialize = function() {
		this.tokensEnabled = false;
		this.reset();
	};
	
	SBVRParser._enableTokens = function() {
		this.tokensEnabled = true;
		SBVRLibs._enableTokens.call(this, ["StartTerm", "StartName", "startFactType", "startRule", "newComment", "Term", "Name", "Modifier", "Verb", "keyword", "AllowedAttrs", "AttrGuidanceType", "Number", "Value"]);
	};
	
	SBVRParser._AddIdentifier = function(identifierType, identifier, baseSynonym) {
		if(baseSynonym == null) {
			baseSynonym = identifier;
			this.identifierChildren[baseSynonym] = [];
		}
		else {
			this.identifierChildren[baseSynonym].push(identifier);
		}
		this.identifiers[identifierType][identifier] = baseSynonym;
		// Check for longest identifier between current and pluralised form, as the plural form may well be (and often is) longer.
		this.longestIdentifier[identifierType] = Math.max(identifier.length, identifier.pluralize().length, this.longestIdentifier[identifierType]);
	};
	
	// Returns the base synonym for this identifier.
	SBVRParser.BaseSynonym = function(identifierType, identifier) {
		var identifiers = this.identifiers[identifierType];
		if(identifiers.hasOwnProperty(identifier)) {
			return identifiers[identifier];
		}
		identifier = identifier.singularize();
		if(identifiers.hasOwnProperty(identifier)) {
			return identifiers[identifier];
		}
		return false;
	};

	// Checks that the identifier is valid in this point of the fact type and returns the identifier as it is found in the fact type.
	SBVRParser.IsFactTypeIdentifier = function(identifierType, factTypeSoFar, identifier) {
		identifier = this.BaseSynonym(identifierType, identifier);
		if(identifier === false) {
			return false;
		}
		var identifiers = this.branches[identifierType].call(this, factTypeSoFar);
		if(identifiers.indexOf(identifier) !== -1) {
			return identifier;
		}
		return false;
	};

	SBVRParser.isVerb = function(factTypeSoFar, verb) {
		verb = ['Verb',this._verbForm(verb)];
		var currentLevel = this._traverseFactType(factTypeSoFar);
		if(currentLevel===false) {
			// We have no fact type matching this chain.
			return false;
		}
		if(currentLevel.hasOwnProperty(verb)) {
			// We found the verb.
			return true;
		}
		if(currentLevel.hasOwnProperty('__valid') && currentLevel.__valid===true) {
			// We have a valid fact type up to here, try a new one.
			// TODO: Should this actually be looking if the verb before last term is valid?
			return this.isVerb([], verb);
		}
		return false;
	};

	SBVRParser._verbForm = function(verb) {
		// People are eating.. Person is eating
		// Not: Police arest people.. Police isst people
		// I used a mispelling here because I could not find a case with a correct word, however in case I just missed one I'd rather check for the space.
		// People aren't animals.. Person isn't animal. Should probably be allowed, however what are our thoughts on contractions?
		if(verb.slice(0,4) == 'are ') {
			return 'is ' + verb.slice(4);
		}
		// Students are people.. Student is person
		if(verb == 'are') {
			return 'is';
		}
		// People have eyes.. Person has eyes
		if(verb=='have') {
			return 'has';
		}
		return verb;
	};

	SBVRParser.IsFactType = function(factType) {
		var currentLevel = this._traverseFactType(factType);
		if(currentLevel === false) {
			return false;
		}
		return currentLevel.__valid;
	};

	var removeRegex = {
			'Verb': new RegExp('^' + ['Verb',''].toString()),
			'Term': new RegExp('^' + ['Term',''].toString()),
			'Name': new RegExp('^' + ['Name',''].toString())
		},
		allowedAttrLists = [
			'Concept Type:',
			'Definition:',
			'Definition (Informal):',
			'Description:',
			'Dictionary Basis:',
			'Example:',
			'General Concept:',
			'Namespace URI:',
			'Necessity:',
			'Note:',
			'Possibility:',
			'Reference Scheme:',
			'See:',
			'Source:',
			'Subject Field:'
		];
	if(SBVR_SERVER_ENABLED) {
		allowedAttrLists = [
			/* Custom Attributes */
			'Database ID Field:',
			'Database Value Field:',
			'Database Table Name:'
			/* End Custom */
		].concat(allowedAttrLists);
	}
	allowedAttrLists = {
		Term: [
			'Synonym:'
		].concat(allowedAttrLists),
		Name: [
			'Synonym:'
		].concat(allowedAttrLists),
		FactType: [
			'Synonymous Form:',
			'Term Form:'
		].concat(allowedAttrLists),
		Rule: [
			'Rule Name:',
			'Guidance Type:',
			'Source:',
			'Synonymous Statement:',
			'Note:',
			'Example:',
			'Enforcement Level:'
		]
	};
	function getValidFactTypeParts(partType, factTypeSoFar) {
		if(factTypeSoFar == null || factTypeSoFar.length == 0) {
			if(this.identifiers.hasOwnProperty(partType)) {
				return _.keys(this.identifiers[partType]);
			}
			else {
				return [];
			}
		}
		var factTypePart,
			currentLevel = this._traverseFactType(factTypeSoFar),
			factTypeParts = [],
			regex = removeRegex[partType];
		for(factTypePart in currentLevel) {
			if(currentLevel.hasOwnProperty(factTypePart)) {
				if(regex.test(factTypePart)) {
					factTypePart = factTypePart.replace(regex, '');
					factTypeParts.push(factTypePart);
					if(this.identifierChildren.hasOwnProperty(factTypePart)) {
						factTypeParts = factTypeParts.concat(this.identifierChildren[factTypePart]);
					}
				}
			}
		}
		return factTypeParts;
	}
	SBVRParser.reset = function() {
		SBVRLibs.initialize.call(this);
		this.branches = {
			clearSuggestions: [], //This stops us suggesting any autocomplete before this point.
			StartTerm: ['Term:     '],
			StartName: ['Name:     '],
			startFactType: ['Fact type:'],
			startRule: ['Rule:     '],
			Term: function(factTypeSoFar) {
				return getValidFactTypeParts.call(this, 'Term', factTypeSoFar);
			},
			Name: function(factTypeSoFar) {
				return getValidFactTypeParts.call(this, 'Name', factTypeSoFar);
			},
			Verb: function(factTypeSoFar) {
				return getValidFactTypeParts.call(this, 'Verb', factTypeSoFar);
			},
			AllowedAttrs: function(termOrFactType) {
				if(allowedAttrLists.hasOwnProperty(termOrFactType)) {
					return allowedAttrLists[termOrFactType];
				}
				else if(termOrFactType == null) {
					return allowedAttrLists.Term.concat(allowedAttrLists.Name, allowedAttrLists.FactType);
				}
				return [];
			},
			AttrGuidanceType: [
				'operative business rule',
				'structural business rule',
				'advice of permission',
				'advice of possibility',
				'advice of optionality',
				'advice of contingency'
			],
			Modifier: [
				'It is obligatory that',
				'It is necessary that',
				'It is prohibited that',
				'It is impossible that',
				'It is not possible that',
				'It is possible that',
				'It is permitted that'
			],
			Quantifier: [
				'each',
				'a',
				'an',
				'some',
				'at most',
				'at least',
	//			'and at most',
				'more than',
				'exactly',
				'no'
			],
			JoiningQuantifier: ['and at most'],
			Number: [
				'1', '2', '3', '4', '5', '6', '7', '8', '9',
				'one'
			],
			addThat: ['that', 'that the'],
			addThe: ['the'],
			addComma: [','],
			addOr: ['or'],
			Terminator: ['.']
		};
		this.identifiers = {
			'Term': {},
			'Name': {}
		};
		this.longestIdentifier = {
			'Term': 0,
			'Name': 0
		};
		this.identifierChildren = {};
		this.ruleVars = {};
		this.ruleVarsCount = 0;
		this.lines = ['Model'];
	};


	/** **/
	SBVRParser.matchForAny = function(rule, arr) {
		var self = this,
        origInput = this.input,
        ref = {},
        result = ref;
		
		for (var idx = 0; idx < arr.length; idx++) {
			try {
				self.input = origInput;
				result = self._applyWithArgs.call(self, rule, arr[idx]);
			}
			catch (e) {
				if (!(e instanceof SyntaxError)) {
					throw e;
				}
			}

			if (result !== ref) {
				return result;
			}
		}
		throw this._fail();
	};
	SBVRParser.matchForAll = function(rule, arr) {
		for (var idx = 0; idx < arr.length; idx++) {
			this._applyWithArgs.call(this, rule, arr[idx]);
		}
	};
	//TODO: This is a bit of a hack for case insensitivity, a better solution needs to be implemented in future.
	SBVRParser.exactly = function(wanted) {
		if (wanted.toLowerCase() === this._apply("lowerCaseAnything")) {
			return wanted;
		}
		throw this._fail();
	};
	// This is a bit hacky, but the lack of arguments means the .toLowerCase() is memoised,
	// saving a lot of .toLowerCase() calls in "exactly" (which isn't memoised :( )
	SBVRParser.lowerCaseAnything = function() {
		return this._apply("anything").toLowerCase();
	};
	
	// For performance we can use this.
	SBVRParser._disablePrependingInput();
	
	return SBVRParser;

});
