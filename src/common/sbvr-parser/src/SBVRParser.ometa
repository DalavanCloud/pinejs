if(typeof SBVR_SERVER_ENABLED === 'undefined') SBVR_SERVER_ENABLED = true;

define(['sbvr-parser/SBVRLibs', 'underscore', 'ometa-core', 'inflection'], function(SBVRLibs) {
	//A parser for Semantics of Business Vocabulary and Rules (SBVR), an OMG standard.
	//Converts from Structured English (SBVR-SE) to Logical Formulation (SBVR-LF)
	//Specification: http://www.omg.org/spec/SBVR/1.0/

	ometa SBVRParser <: SBVRLibs {
		EOL =
			(	'\r'?
				'\n'
			|	'\r'
			),
		EOLSpaces =
			{false}:eol
			(	EOL
				{true}:eol
			|	space
			)*
			?eol,
		Bind :x	=
			-> ['RoleBinding', x, this.ruleVars[x[1]]],

		letters =
			letter+:l
			-> l.join(''),
		Number =
			(	spaces <digit+>:n
				-> ['Number', parseInt(n, 10)]
			|	"one"
				-> ['Number', 1]
			),
		Value :stopOn =
			(	spaces ~token(stopOn) ~lineStart letterOrDigit+:alphaNum
				-> alphaNum.join('')
			)+:value
			-> value.join(''),
		toSBVREOL =
			spaces
			(
				~(spaces lineStart) spaces?:s
				(~space anything)+:a
				-> s.concat(a).join('')
			)*:w
			-> w.join(''),
		toEOL =
			(	~EOL
				anything
			)*:a
			-> a.join(''),

		token :x =
			spaces seq(x):s
			&(	space
			|	end
			)
			-> s,

		addTerm =
			&(termPart+):t {this.terms[t.join(' ')] = t.join(' ')}
			Term,
		Term :factTypeSoFar =
			findTerm(factTypeSoFar),
		findTerm :factTypeSoFar :termSoFar =
			termPart:t {termSoFar = termSoFar==null ? t : [termSoFar, t].join(' ')}
			(	findTerm(factTypeSoFar, termSoFar)
			|	?this.isTerm(factTypeSoFar, termSoFar)
				-> ['Term',this._termForm(factTypeSoFar, termSoFar)]
			),
		termPart =
			spaces ~lineStart letters,
		
		
		addVerb =
			clearSuggestions Verb(true),
		Verb :factTypeSoFar =
			findVerb(factTypeSoFar),
		findVerb :factTypeSoFar :verbSoFar =
			verbPart:v {verbSoFar = verbSoFar==undefined ? v : [verbSoFar, v].join(' ')}
			(	findVerb(factTypeSoFar, verbSoFar)
			|	(	?(factTypeSoFar===true)
				|	?this.isVerb(factTypeSoFar, verbSoFar)
				)
				-> ['Verb',this._verbForm(verbSoFar)]
			),
		verbPart =
			spaces ~lineStart ~Term letters,
		
		JoiningQuantifier =
			matchForAll('keyword',["and","at","most"]),
		
		// Be very careful with anywhere you use quantifier as any in-place modifications of the array will be remembered in memoisation.
		Quantifier =
			(	keyword("each")
				-> ['UniversalQuantification']
			|	matchForAny('keyword',["a","an","some"])
				-> ['ExistentialQuantification']
			|	matchForAll('keyword',["at","most"]) Number:n
				-> ['AtMostNQuantification', ['MaximumCardinality', n]]
			|	matchForAll('keyword',["at","least"]) Number:n
				(	JoiningQuantifier
					Number:m
					-> ['NumericalRangeQuantification', ['MinimumCardinality', n], ['MaximumCardinality', m]]
				|	-> ['AtLeastNQuantification', ['MinimumCardinality', n]]
				)
			|	matchForAll('keyword',["more","than"]) Number:n {++n[1]}
				-> ['AtLeastNQuantification', ['MinimumCardinality', n]]
			|	keyword("exactly") Number:n
				-> ['ExactQuantification', ['Cardinality', n]]
			),

		keyword :word :noToken =
			(	?(noToken===true) seq(word)
			|	?(noToken!==true) token(word)
			),
		
		addThat =
			keyword("that"),
		addThe =
			keyword("the"),
		addComma =
			keyword(","),
		addOr =
			keyword("or"),
		createVar :term =
			{this.ruleVars[term[1]] = this.ruleVarsCount++}
			-> ['Variable', ['Number', this.ruleVars[term[1]]], term],

		atfo :factType :bindings =
			isFactType(factType):realFactType
			?realFactType
			-> ['AtomicFormulation'].concat([['FactType'].concat(factType)], bindings),

		ruleBody :factType :bindings :exitOnTermFactType =
			(	Quantifier:body
				Term(factType):t createVar(t):tVar Bind(t):b {factType.push(t);bindings.push(b)}
				(	addThat
					(	{[t]}:thatFactType
						Verb(thatFactType):v {thatFactType.push(v)}
						(	ruleBody(thatFactType, [b], true)
						|	atfo(thatFactType, [b])
						)
					|	ruleBody([t], [b])
					):thatLF {tVar.push(thatLF)}
					','?
				)?
			|	addThe
				{factType[factType.length - 1]}:parentTerm
				{bindings[bindings.length - 1]}:parentTermBind
				Term:t Bind(t):b {[t]}:factType {[b]}:bindings
			)
			(
				Verb(factType):v {factType.push(v)}
				{	if(parentTerm != null) {
						factType.push(parentTerm);
						bindings.push(parentTermBind);
					}
				}
				(	ruleBody(factType, bindings, true)
				|	atfo(factType, bindings)
				)
			|	?(exitOnTermFactType === true)
				atfo(factType, bindings)
			):lf
			-> (parentTerm != null ? lf : body.concat([tVar, lf])),

		Modifier =
			"It" "is" 
			(	"obligatory"
				-> ['ObligationFormulation']
			|	"necessary"	
				-> ['NecessityFormulation']
			|	"prohibited"
				-> ['ObligationFormulation', ['LogicalNegation']]
			|	"impossible"
				-> ['NecessityFormulation', ['LogicalNegation']]
			|	"not" "possible"
				-> ['NecessityFormulation', ['LogicalNegation']]
			|	"possible"
				-> ['PossibilityFormulation']
			|	"permissible"
				-> ['PermissibilityFormulation']
			):r
			"that"
			-> r,

		startRule =
			"R:"|"Rule:",
		newRule =
			startRule spaces &(toSBVREOL):ruleText {this.ruleVarsCount=0}
			Modifier:r ruleBody([], []):q {r.length == 2 ? (r[1][1] = q) : (r[1] = q)}
			-> ['Rule', r, ['StructuredEnglish', ruleText]],
		terb =
			Term:t addVerb:v
			-> [t, v],
		startFactType =
			"F:"|"Fact type:",
		newFactType =
			startFactType {[]}:factType
			(Term:t addVerb:v {factType.push(t, v)})+
			(Term:t {factType.push(t)})?
			AddFactType(factType, factType) {factType.push([])}
			-> ['FactType'].concat(factType),
		startTerm =
			"T:"|"Term:",
		newTerm =
			startTerm clearSuggestions addTerm:t {t.push([])}
			-> t,
		attribute =
			{this.lines[this.lines.length-1]}:currentLine
			allowedAttrs(currentLine[0]):attrName
			{attrName.replace(new RegExp(' ','g'),'')}:attrName
			ApplyFirstExisting(['attr'+attrName,'defaultAttr'], [currentLine]):attrVal
			-> {var lastLine = this.lines.pop(); lastLine[lastLine.length-1].push([attrName, attrVal]); lastLine},
							
		allowedAttrs :termOrFactType =
			matchForAny('seq',this.branches.allowedAttrs.call(this, termOrFactType)):attrName -> attrName.replace(':',''),
		defaultAttr :currentLine =
			toSBVREOL,
		attrDefinition :currentLine =
			(	addThe?
				// The following section is copied from ruleBody, should really be sorted properly.
				{this.ruleVarsCount=0} {[]}:factType {[]}:bindings
				Term:t createVar(t):tVar Bind(t):b {factType.push(t);bindings.push(b)}
				addThat
				(	{[t]}:thatFactType
					Verb(thatFactType):v {thatFactType.push(v)}
					(	ruleBody(thatFactType, [b], true)
					|	atfo(thatFactType, [b])
					)
				|	ruleBody([t], [b])
				):thatLF {tVar.push(thatLF)}
				-> tVar
			|	Value('or'):name
				(	addOr clearSuggestions
					Value('or')
				)*:names
				{names.unshift(name)}
				-> ['Enum', names]
			),
		attrConceptType :currentLine =
			{currentLine[1]}:termName
			?(!this.conceptTypes.hasOwnProperty(termName)) // Only allow one instance of Concept Type: attribute.
											 // TODO: Improve this to deal with synonyms and autocomplete/highlighting.
			Term:t ?(termName != t[1]) // Do not allow a term to have itself as its concept type.
			{this.conceptTypes[termName] = t[1]}
			-> t,
		attrSynonym :currentLine =
			addTerm:t {this.terms[t[1]] = currentLine[1]}
			-> t,
		attrSynonymousForm :currentLine =
			{[]}:factType
			(Term:t addVerb:v {factType.push(t, v)})+
			(Term:t {factType.push(t)})?
			AddFactType(factType, currentLine.slice(1,-1)) {factType.push([])}
			-> factType,
		attrTermForm :currentLine =
			addTerm:t
			{
				for(var i = 0; i < currentLine.length; i++) {
					if(currentLine[i][0] == 'Term') {
						var factType = [t, ['Verb', 'has'], currentLine[i]];
						this.AddFactType(factType, factType);
					}
				}
			}
		-> t,

		startComment =
			seq('--'),
		newComment =
			startComment toEOL,
		
		terminator =
			spaces keyword('.',true),
		lineStart :lineType =
			(	startTerm
			|	startFactType
			|	startRule
			|	allowedAttrs
			|	startComment
			),
		line =
			spaces
			(
				(	newTerm
				|	newFactType
				|	newRule
				|	attribute
				):l
				terminator? clearSuggestions
				{this.lines.push(l)}
				-> l
			|	newComment
			),
		Process =
			line
			(	EOLSpaces
				line
			)*
			spaces
			end
			-> this.lines
	}

	SBVRParser.clearSuggestions = function() {};
	/**
		Following are "instance" variables/functions rather than shared.
	*/
	SBVRParser.initialize = function() {
		this.tokensEnabled = false;
		this.reset();
	};
	
	SBVRParser._enableTokens = function() {
		this.tokensEnabled = true;
		SBVRLibs._enableTokens.call(this, ["startTerm", "startFactType", "startRule", "newComment", "Term", "Modifier", "Verb", "keyword", "allowedAttrs", "Number", "Value"]);
	};
	
	SBVRParser._baseTerm = function(factTypeSoFar, term) {
		if(this.terms.hasOwnProperty(term)) {
			return this.terms[term];
		}
		if(this.terms.hasOwnProperty(term.singularize())) {
			return this.terms[term.singularize()];
		}
		return false;
	};

	SBVRParser.isTerm = function(factTypeSoFar, term) {
		var terms = this.branches['Term'].call(this, factTypeSoFar);
		term = this._baseTerm(factTypeSoFar, term);
		return term !== false && (terms.indexOf(term) !== -1 || terms.indexOf(term.singularize()) !== -1);
	};

	SBVRParser._termForm = function(factTypeSoFar, term) {
		term = this._baseTerm(factTypeSoFar, term);
		var termForms = this.branches['Term'].call(this, factTypeSoFar);
		return termForms.indexOf(term.singularize()) !== -1 ? term.singularize() : term
	};

	SBVRParser.isVerb = function(factTypeSoFar, verb) {
		verb = ['Verb',this._verbForm(verb)];
		var currentLevel = this._traverseFactType(factTypeSoFar);
		if(currentLevel===false) {
			// We have no fact type matching this chain.
			return false;
		}
		if(currentLevel.hasOwnProperty(verb)) {
			// We found the verb.
			return true;
		}
		if(currentLevel.hasOwnProperty('__valid') && currentLevel.__valid===true) {
			// We have a valid fact type up to here, try a new one.
			// TODO: Should this actually be looking if the verb before last term is valid?
			return this.isVerb([], verb);
		}
		return false;
	};

	SBVRParser._verbForm = function(verb) {
		// People are eating.. Person is eating
		// Not: Police arest people.. Police isst people
		// I used a mispelling here because I could not find a case with a correct word, however in case I just missed one I'd rather check for the space.
		// People aren't animals.. Person isn't animal. Should probably be allowed, however what are our thoughts on contractions?
		if(verb.slice(0,4) == 'are ') {
			return 'is ' + verb.slice(4);
		}
		// Students are people.. Student is person
		if(verb == 'are') {
			return 'is';
		}
		// People have eyes.. Person has eyes
		if(verb=='have') {
			return 'has';
		}
		return verb;
	};

	SBVRParser.isFactType = function(factType) {
		var currentLevel = this._traverseFactType(factType);
		if(currentLevel === false) {
			return false;
		}
		return currentLevel.__valid;
	};

	var removeVerbRegex = new RegExp('^' + ['Verb',''].toString()),
		removeTermRegex = new RegExp('^' + ['Term',''].toString()),
		allowedAttrLists = [
			'Dictionary Basis:',
			'Example:',
			'General Concept:',
			'Namespace URI:',
			'Necessity:',
			'Note:',
			'Possibility:',
			'Reference Scheme:',
			'See:',
			'Source:',
			'Subject Field:'
		];
	if(SBVR_SERVER_ENABLED) {
		allowedAttrLists = [
			/* Custom Attributes */
			'Database ID Field:',
			'Database Value Field:',
			'Database Table Name:'
			/* End Custom */
		].concat(allowedAttrLists);
	}
	allowedAttrLists = {
		Term: [
			'Concept Type:',
			'Definition:',
			'Synonym:'
		].concat(allowedAttrLists),
		FactType: [
			'Synonymous Form:',
			'Term Form:'
		].concat(allowedAttrLists),
		Rule: []
	};
	SBVRParser.reset = function() {
		SBVRLibs.initialize.call(this);
		this.branches = {
			clearSuggestions: [], //This stops us suggesting any autocomplete before this point.
			startTerm: ['Term:     '],
			startFactType: ['Fact type:'],
			startRule: ['Rule:     '],
			Term: function(factTypeSoFar) {
				if(factTypeSoFar == null || factTypeSoFar.length == 0) {
					return _.keys(this.terms);
				}
				var term, currentLevel = this._traverseFactType(factTypeSoFar), terms = [];
				for(term in currentLevel) {
					if(currentLevel.hasOwnProperty(term)) {
						if(removeTermRegex.test(term)) {
							terms.push(term.replace(removeTermRegex,''));
						}
					}
				}
				return terms;
			},
			Verb: function(factTypeSoFar) {
				var verb, currentLevel = this._traverseFactType(factTypeSoFar), verbs = [];
				for(verb in currentLevel) {
					if(currentLevel.hasOwnProperty(verb)) {
						if(removeVerbRegex.test(verb)) {
							verbs.push(verb.replace(removeVerbRegex,''));
						}
					}
				}
				return verbs;
			},
			allowedAttrs: function(termOrFactType) {
				if(allowedAttrLists.hasOwnProperty(termOrFactType)) {
					return allowedAttrLists[termOrFactType];
				}
				else if(termOrFactType == null) {
					return allowedAttrLists.Term.concat(allowedAttrLists.FactType);
				}
				return [];
			},
			Modifier: [
				'It is obligatory that',
				'It is necessary that',
				'It is prohibited that',
				'It is impossible that',
				'It is not possible that',
				'It is possible that',
				'It is permissible that'
			],
			Quantifier: [
				'each',
				'a',
				'an',
				'some',
				'at most',
				'at least',
	//			'and at most',
				'more than',
				"exactly"
			],
			JoiningQuantifier: ['and at most'],
			Number: [
				'1', '2', '3', '4', '5', '6', '7', '8', '9',
				'one'
			],
			addThat: ['that', 'that the'],
			addThe: ['the'],
			addComma: [','],
			addOr: ['or'],
			terminator: ['.']
		};
		this.terms = {};
		this.ruleVars = {};
		this.ruleVarsCount = 0;
		this.lines = ['Model'];
	};

	SBVRParser.equals = function(compareTo) {
		// TODO: Can this be simplified to just compare lines (and made provably comparable)?
		if(!_.isEqual(this.terms, compareTo.terms)) {
			return false;
		}
		if(!_.isEqual(this.conceptTypes, compareTo.conceptTypes)) {
			return false;
		}
		if(!_.isEqual(this.factTypes, compareTo.factTypes)) {
			return false;
		}
		return true;
	};

	SBVRParser.clone = function() {
		var clone = SBVRParser.createInstance();
		if(this.tokensEnabled) {
			clone._enableTokens();
		}
		return $.extend(true, clone, {
			terms: this.terms,
			conceptTypes: this.conceptTypes,
			factTypes: this.factTypes,
			ruleVars: this.ruleVars,
			ruleVarsCount: this.ruleVarsCount,
			lines: this.lines
		});
	};


	/** **/
	SBVRParser.matchForAny = function(rule, arr) {
		var self = this,
        origInput = this.input,
        ref = {},
        result = ref;
		
		for (var idx = 0; idx < arr.length; idx++) {
			try {
				self.input = origInput;
				result = self._applyWithArgs.call(self, rule, arr[idx]);
			}
			catch (e) {
				if (!(e instanceof SyntaxError)) {
					throw e;
				}
			}

			if (result !== ref) {
				return result;
			}
		}
		throw this._fail();
	};
	SBVRParser.matchForAll = function(rule, arr) {
		for (var idx = 0; idx < arr.length; idx++) {
			this._applyWithArgs.call(this, rule, arr[idx]);
		}
	};
	//TODO: This is a bit of a hack for case insensitivity, a better solution needs to be implemented in future.
	SBVRParser.exactly = function(wanted) {
		if (wanted.toLowerCase() === this._apply("anything").toLowerCase()) {
			return wanted;
		}
		throw this._fail();
	};
	
	return SBVRParser;

});