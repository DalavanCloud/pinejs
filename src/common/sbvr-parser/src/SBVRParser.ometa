define(['underscore', 'ometa/ometa-base', 'inflection'], function(_) {
	var SBVRParser;

	//A parser for Semantics of Business Vocabulary and Rules (SBVR), an OMG standard.
	//Converts from Structured English (SBVR-SE) to Logical Formulation (SBVR-LF)
	//Specification: http://www.omg.org/spec/SBVR/1.0/

	ometa SBVRParser {
		isTerm		:term
						= ?this._isTerm(term),
		isVerb		:prevTerm :verb
						= ?this._isVerb(prevTerm, verb),
		isFctp		:factType
						= ?this._isFctp(factType),

		findVar		:x	= {this.ruleVars[x[1]]},
		bind		:x	= findVar(x):y											-> ['bind', x, y],

		letters			= letter+:l												-> l.join(''),
		num				= spaces digit+:n										-> ['num', parseInt(n.join(''))]
						| "one"													-> ['num', 1],
		toSBVREOL		= spaces (~(spaces lineStart) spaces?:s (~space anything)+:a -> s.concat(a).join(''))*:w
																				-> w.join(''),
		toEOL			= (~('\r'|'\n') anything)+:a							-> a.join(''),

		token		:x	= spaces seq(x):s &(space+)								-> s,

		addTerm			= &(termPart+):t {this.possMap.term[t.join(' ')] = true}
						  term,
		term			= findTerm,
		findTerm	:termSoFar
						= termPart:t {termSoFar = termSoFar==undefined ? t : [termSoFar, t].join(' ')}
							( findTerm(termSoFar)
							| isTerm(termSoFar)									-> ['term',this._termForm(termSoFar)]
							),
		termPart		= spaces ~lineStart letters,
		
		
		addVerb		:prevTerm
						= clearSuggestions &((verbPart)+):v {this._addVerbToTerm(prevTerm,v.join(' '))}
						  verb(prevTerm),
		verb		:prevTerm
						= findVerb(prevTerm),
		findVerb	:prevTerm :verbSoFar
						= verbPart:v {verbSoFar = verbSoFar==undefined ? v : [verbSoFar, v].join(' ')}
							( findVerb(prevTerm, verbSoFar)
							| isVerb(prevTerm, verbSoFar)									-> ['verb',this._verbForm(prevTerm, verbSoFar)]
							),
		verbPart		= spaces ~lineStart ~term letters,
		
		joinQuant		= matchForAll('keyword',["and","at","most"]),
		
		quantTermAddVar	= quant:q term:t addVar(t):v							-> {quantVar: q.concat([v]), term: t},
		//Be very careful with anywhere you use quant as any in-place modifications of the array will be remembered in memoisation.
		quant			= keyword("each")										-> ['univQ']
						| matchForAny('keyword',["a","an","some"])				-> ['existQ']
						| matchForAll('keyword',["at","most"])		num:n		-> ['atMostQ', ['maxCard', n]]
						| matchForAll('keyword',["at","least"])		num:n
											( joinQuant num:m					-> ['numRngQ', ['minCard', n], ['maxCard', m]]
											| empty 							-> ['atLeastQ', ['minCard', n]])
						| matchForAll('keyword',["more","than"])	num:n {++n[1]}
																				-> ['atLeastQ', ['minCard', n]]
						| keyword("exactly")						num:n		-> ['exactQ', ['card', n]],

		keyword		:word :noToken
						= ?(noToken==true) seq(word)
						| ?(noToken!=true) token(word),
		
		addThat			= keyword("that"),
		addThe			= keyword("the"),
		addVar		:prevTerm
						= {this.ruleVars[prevTerm[1]] = this.ruleVarsCount++} {['var', ['num', this.ruleVars[prevTerm[1]]], prevTerm]}:v
						( addThat
							( addThe terbRi([[]], prevTerm)
							| qTerbRi([[]], prevTerm) ):q {v.push(q)}
						)?														-> v,

		atfo		:c	= isFctp(c[0]) {c[0] = ['fcTp'].concat(c[0])}			-> ['aFrm'].concat(c),

		terbRi	:c :prevTerm
						= term:t verb(t):v bind(t):b {c[0].push(t,v);c.push(b)} (qTerbRi(c,prevTerm)),

		qTerbRi	:c :prevTerm
						= (quantTermAddVar:qt {qt.term}:t verb():v bind(t):b
								{c[0].push(t,v);c.push(b)}
								(qTerbRi(c,prevTerm)):r							-> qt.quantVar.concat([r])
							| verb(prevTerm):v bind(prevTerm):b {c[0].push(prevTerm,v);c.push(b)} (atfo(c)|qTerbR(c)|qTerm(c))
							| bind(prevTerm):b {c[0].push(prevTerm);c.push(b)} atfo(c)
						),

		qTerm		:c	= quantTermAddVar:qt {qt.term}:t bind(t):b {c[0].push(t);c.push(b)}
								atfo(c):r										-> qt.quantVar.concat([r]),

		qTerbR		:c	= quantTermAddVar:qt {t = qt.term} verb(t):v bind(t):b {c[0].push(t,v);c.push(b)}
								(atfo(c)|qTerbR(c)|qTerm(c)):r					-> qt.quantVar.concat([r]),

		modRule			= "It" "is" 
							( "obligatory"		-> ['obl']
							| "necessary"		-> ['nec']
							| "prohibited"		-> ['obl', ['neg']]
							| "impossible"		-> ['nec', ['neg']]
							| "not" "possible"	-> ['nec', ['neg']]
							| "possible"		-> ['pos']
							| "permissible"		-> ['prm']
							):r
						  "that"											-> r,

		startRule		= "R:"|"Rule:",
		newRule			= startRule spaces &(toSBVREOL):ruleText {this.ruleVarsCount=0}
							modRule:r qTerbR([[]]):q {r.length == 2 ? r[1][1] = q : r[1] = q}
																			-> ['rule', r, ['text', ruleText]],
		terb			= term:t addVerb(t):v								-> [t, v],
		startFactType	= "F:"|"Fact type:",
		newFactType		= startFactType {[]}:t (terb:b {t.concat(b)}:t)+ (term:e {t.push(e)})? {this.fctps[t] = true; t.push([])}
																			-> ['fcTp'].concat(t),
		startTerm		= "T:"|"Term:",
		newTerm			= startTerm clearSuggestions addTerm:t {t.push([])}					-> t,
		attribute		= ?{this.lines[this.lines.length-1][0] == 'term' ||
							this.lines[this.lines.length-1][0] == 'fcTp'}
							allowedAttrs:attrName
							{attrName.replace(new RegExp(' ','g'),'')}:attrName
							applyFirstExisting(['attr'+attrName,'toSBVREOL']):attrVal
																			-> {var lastLine = this.lines.pop(); lastLine[lastLine.length-1].push([attrName, attrVal]); lastLine},
							
		allowedAttrs	= matchForAny('seq',this.possMap.allowedAttrs):attrName -> attrName.replace(':',''),
		attrDefinition	= qTerbR([[]]),
		attrConceptType	= term,

		startComment	= seq('--'),
		newComment		= startComment toEOL,
		
		terminator		= spaces keyword('.',true),
		lineStart		= startTerm
						| startFactType
						| startRule
						| allowedAttrs
						| startComment,
		line			= (spaces (newTerm | newFactType | newRule | attribute):l terminator? clearSuggestions spaces
							{this.lines.push(l)}							-> l)
						| newComment,
		expr			= line* end											-> this.lines
	}

	SBVRParser.keyTokens = ["startTerm", "startFactType", "startRule", "newComment", "term", "modRule", "verb", "keyword", "allowedAttrs", "num"];
	SBVRParser.clearSuggestions = function() {}
	/**
		Following are "instance" variables/functions rather than shared.
	*/
	SBVRParser.initialize = function() {
		this.reset();
	}

	SBVRParser._isTerm = function(k) {
		return this.possMap.term.hasOwnProperty(k) || this.possMap.term.hasOwnProperty(k.singularize())
	}

	SBVRParser._termForm = function(k) {
		return this.possMap.term.hasOwnProperty(k.singularize()) ? k.singularize() : k
	}

	SBVRParser._isVerb = function(prevTerm, verb) {
		if(typeof prevTerm == 'undefined') {
			for(term in this.possMap.verb) {
				if(this._isVerb(term, verb)) {
					return true
				}
			}
		}
		else {
			if(!this.possMap.verb.hasOwnProperty(prevTerm)) {
				return false
			}
			if(this.possMap.verb[prevTerm].hasOwnProperty(verb)) {
				return true
			}
			if( verb.slice(0,3)=='are' && this.possMap.verb[prevTerm].hasOwnProperty('is' + verb.slice(3)) ) {
				return true
			}
			if(verb=='have' && this.possMap.verb[prevTerm].hasOwnProperty('has')) {
				return true
			}
		}
		return false
	}

	SBVRParser._verbForm = function(prevTerm, verb) {
		if(this.possMap.verb.hasOwnProperty(prevTerm)) {
			if(verb.slice(0,3)=='are' && this.possMap.verb[prevTerm].hasOwnProperty('is' + verb.slice(3))) {
				return 'is' + verb.slice(3)
			}
			if(verb=='have' && this.possMap.verb[prevTerm].hasOwnProperty('has')) {
				return 'has'
			}
			return verb
		}
		return verb //TODO: This should fail really.
	}

	SBVRParser._addVerbToTerm = function(term, verb) {
		if(!this.possMap.verb.hasOwnProperty(term)) {
			this.possMap.verb[term] = {}
		}
		this.possMap.verb[term][verb] = true
	}

	SBVRParser._isFctp = function(k) { return this.fctps.hasOwnProperty(k) }

	SBVRParser.reset = function() {
		this.possMap = {
			clearSuggestions: [], //This stops us suggesting any autocomplete before this point.
			startTerm: ['Term:     '],
			startFactType: ['Fact type:'],
			startRule: ['Rule:     '],
			term: {},
			verb: {},
			allowedAttrs: [
				'Concept Type:',
				/*#IFDEF server */
					/* Custom Attributes */
					'Database ID Field:',
					'Database Name Field:',
					'Database Table Name:',
					/* End Custom */
				/*#ENDIFDEF*/
				'Definition:',
				'Dictionary Basis:',
				'Example:',
				'General Concept:',
				'Namespace URI:',
				'Necessity:',
				'Note:',
				'Possibility:',
				'Reference Scheme:',
				'See:',
				'Source:',
				'Subject Field:',
				'Synonymous Form:',
				'Synonym:'
			],
			modRule: [
				'It is obligatory that',
				'It is necessary that',
				'It is prohibited that',
				'It is impossible that',
				'It is not possible that',
				'It is possible that',
				'It is permissible that'
			],
			quant: [
				'each',
				'a',
				'an',
				'some',
				'at most',
				'at least',
	//			'and at most',
				'more than',
				"exactly"
			],
			joinQuant: ['and at most'],
			num: [
				'1', '2', '3', '4', '5', '6', '7', '8', '9',
				'one'
			],
			addThat: ['that', 'that the'],
			addThe: ['the'],
			terminator: ['.']
		}
		this.fctps = {}
		this.ruleVars = {}
		this.ruleVarsCount = 0
		this.lines = ['model']
	}

	SBVRParser.equals = function(compareTo) {
		if(!_.isEqual(this.possMap.term, compareTo.possMap.term)) return false
		if(!_.isEqual(this.possMap.verb, compareTo.possMap.verb)) return false
		if(!_.isEqual(this.fctps, compareTo.fctps)) return false
		return true
	}


	/** **/
	SBVRParser.matchForAny = function(rule,arr) {
		var origInput = this.input
		for (var idx = 0; idx < arr.length; idx++)
			try { this.input = origInput; return this._applyWithArgs.call(this, rule, arr[idx]) }
			catch (f) {
				if (f != fail) {
					console.log(f.stack)
					throw f
				}
			}
		throw fail
	}
	SBVRParser.matchForAll = function(rule,arr) {
		var ret
		for (var idx = 0; idx < arr.length; idx++)
			ret = this._applyWithArgs.call(this, rule, arr[idx])
		return ret
	}
	SBVRParser.applyFirstExisting = function(arr) {
		for (var i = 0; i < arr.length; i++)
			if(this[arr[i]] != undefined)
				return this._apply(arr[i])
	}
	/* This is a bit of a hack for case insensitivity, a better solution needs to be implemented in future. */
	SBVRParser.exactly = function(wanted) {
		if (wanted.toLowerCase() === this._apply("anything").toLowerCase())
			return wanted
		throw fail
	}
	
	return SBVRParser;

});