define(['sbvr-parser/SBVRLibs', 'underscore', 'ometa/ometa-base', 'inflection'], function(SBVRLibs, _) {
	var SBVRParser;

	//A parser for Semantics of Business Vocabulary and Rules (SBVR), an OMG standard.
	//Converts from Structured English (SBVR-SE) to Logical Formulation (SBVR-LF)
	//Specification: http://www.omg.org/spec/SBVR/1.0/

	ometa SBVRParser <: SBVRLibs {
		bind :x	=
			-> ['bind', x, this.ruleVars[x[1]]],

		letters =
			letter+:l
			-> l.join(''),
		num =
			(	spaces digit+:n
				-> ['num', parseInt(n.join(''))]
			|	"one"
				-> ['num', 1]
			),
		Value :stopOn =
			(	spaces ~token(stopOn) ~lineStart letterOrDigit+:alphaNum
				-> alphaNum.join('')
			)+:value
			-> value.join(''),
		toSBVREOL =
			spaces
			(
				~(spaces lineStart) spaces?:s
				(~space anything)+:a
				-> s.concat(a).join('')
			)*:w
			-> w.join(''),
		toEOL =
			(	~('\r'|'\n')
				anything
			)*:a
			-> a.join(''),

		token :x =
			spaces seq(x):s
			&(	space
			|	end
			)
			-> s,

		addTerm =
			&(termPart+):t {this.terms[t.join(' ')] = t.join(' ')}
			Term,
		Term :factTypeSoFar =
			findTerm(factTypeSoFar),
		findTerm :factTypeSoFar :termSoFar =
			termPart:t {termSoFar = termSoFar==null ? t : [termSoFar, t].join(' ')}
			(	findTerm(factTypeSoFar, termSoFar)
			|	?this.isTerm(factTypeSoFar, termSoFar)
				-> ['Term',this._termForm(factTypeSoFar, termSoFar)]
			),
		termPart =
			spaces ~lineStart letters,
		
		
		addVerb =
			clearSuggestions Verb(true),
		Verb :factTypeSoFar =
			findVerb(factTypeSoFar),
		findVerb :factTypeSoFar :verbSoFar =
			verbPart:v {verbSoFar = verbSoFar==undefined ? v : [verbSoFar, v].join(' ')}
			(	findVerb(factTypeSoFar, verbSoFar)
			|	(	?(factTypeSoFar===true)
				|	?this.isVerb(factTypeSoFar, verbSoFar)
				)
				-> ['Verb',this._verbForm(verbSoFar)]
			),
		verbPart =
			spaces ~lineStart ~Term letters,
		
		joinQuant =
			matchForAll('keyword',["and","at","most"]),
		
		// Be very careful with anywhere you use quant as any in-place modifications of the array will be remembered in memoisation.
		quant =
			(	keyword("each")
				-> ['univQ']
			|	matchForAny('keyword',["a","an","some"])
				-> ['existQ']
			|	matchForAll('keyword',["at","most"]) num:n
				-> ['atMostQ', ['maxCard', n]]
			|	matchForAll('keyword',["at","least"]) num:n
				(	joinQuant num:m
					-> ['numRngQ', ['minCard', n], ['maxCard', m]]
				|	-> ['atLeastQ', ['minCard', n]]
				)
			|	matchForAll('keyword',["more","than"]) num:n {++n[1]}
				-> ['atLeastQ', ['minCard', n]]
			|	keyword("exactly") num:n
				-> ['exactQ', ['card', n]]
			),

		keyword :word :noToken =
			(	?(noToken===true) seq(word)
			|	?(noToken!==true) token(word)
			),
		
		addThat =
			keyword("that"),
		addThe =
			keyword("the"),
		addComma =
			keyword(","),
		addOr =
			keyword("or"),
		createVar :term =
			{this.ruleVars[term[1]] = this.ruleVarsCount++}
			-> ['var', ['num', this.ruleVars[term[1]]], term],
		checkThat :term :termBind =
			addThat
			(	addThe Term:t bind(t):b {[[t],b]}:c Verb(c[0]):v {c[0].push(v, term); c.push(termBind)}
				(	ruleBody(c)
				|	atfo(c)
				)
			|	(	{[[term], termBind]}:c Verb(c[0]):v {c[0].push(v)}
					(	ruleBody(c, true)
					|	atfo(c)
					)
				| ruleBody([[]])
				)
			):r
			addComma?
			-> r,

		atfo :c	=
			isFactType(c[0]):realFactType
			?realFactType
			{c[0] = ['FactType'].concat(c[0])}
			-> ['AtomicFormulation'].concat(c),

		// c[0] should contain the current fact type that is being built
		// c[1..] should contain the bindings for the fact type being built
		ruleBody :c :exitOnTermFactType =
			quant:body Term(c[0]):t createVar(t):tVar bind(t):b {c[0].push(t);c.push(b)}
			(checkThat(t, b):thatC {tVar.push(thatC)})?
			(
				Verb(c[0]):v {c[0].push(v)}
				(	ruleBody(c, true)
				|	atfo(c)
				)
			|	?(exitOnTermFactType === true)
				atfo(c)
			):r
			{body.push(tVar, r)}
			-> body,

		modRule =
			"It" "is" 
			(	"obligatory"
				-> ['obl']
			|	"necessary"	
				-> ['nec']
			|	"prohibited"
				-> ['obl', ['neg']]
			|	"impossible"
				-> ['nec', ['neg']]
			|	"not" "possible"
				-> ['nec', ['neg']]
			|	"possible"
				-> ['pos']
			|	"permissible"
				-> ['prm']
			):r
			"that"
			-> r,

		startRule =
			"R:"|"Rule:",
		newRule =
			startRule spaces &(toSBVREOL):ruleText {this.ruleVarsCount=0}
			modRule:r ruleBody([[]]):q {r.length == 2 ? r[1][1] = q : r[1] = q}
			-> ['Rule', r, ['text', ruleText]],
		terb =
			Term:t addVerb:v
			-> [t, v],
		startFactType =
			"F:"|"Fact type:",
		newFactType =
			startFactType {[]}:factType
			(Term:t addVerb:v {factType.push(t, v)})+
			(Term:t {factType.push(t)})?
			AddFactType(factType, factType) {factType.push([])}
			-> ['FactType'].concat(factType),
		startTerm =
			"T:"|"Term:",
		newTerm =
			startTerm clearSuggestions addTerm:t {t.push([])}
			-> t,
		attribute =
			{this.lines[this.lines.length-1]}:currentLine
			allowedAttrs(currentLine[0]):attrName
			{attrName.replace(new RegExp(' ','g'),'')}:attrName
			ApplyFirstExisting(['attr'+attrName,'defaultAttr'], [currentLine]):attrVal
			-> {var lastLine = this.lines.pop(); lastLine[lastLine.length-1].push([attrName, attrVal]); lastLine},
							
		allowedAttrs :termOrFactType =
			matchForAny('seq',this.possMap.allowedAttrs.call(this, termOrFactType)):attrName -> attrName.replace(':',''),
		defaultAttr :currentLine =
			toSBVREOL,
		attrDefinition :currentLine =
			(	{this.ruleVarsCount=0} {[[]]}:c Term:t createVar(t):tVar bind(t):b {c[0].push(t);c.push(b)}
				checkThat(t, b):thatC {tVar.push(thatC)}
				-> tVar
			|	Value('or'):name
				(	addOr clearSuggestions
					Value('or')
				)*:names
				{names.unshift(name)}
				-> ['Enum', names]
			),
		attrConceptType :currentLine =
			{currentLine[1]}:termName
			?(!this.conceptTypes.hasOwnProperty(termName)) // Only allow one instance of Concept Type: attribute.
											 // TODO: Improve this to deal with synonyms and autocomplete/highlighting.
			Term:t ?(termName != t[1]) // Do not allow a term to have itself as its concept type.
			{this.conceptTypes[termName] = t[1]}
			-> t,
		attrSynonym :currentLine =
			addTerm:t {this.terms[t[1]] = currentLine[1]}
			-> t,
		attrSynonymousForm :currentLine =
			{[]}:factType
			(Term:t addVerb:v {factType.push(t, v)})+
			(Term:t {factType.push(t)})?
			AddFactType(factType, currentLine.slice(1,-1)) {factType.push([])}
			-> factType,
		attrTermForm :currentLine =
			addTerm:t
			{
				for(var i = 0; i < currentLine.length; i++) {
					if(currentLine[i][0] == 'Term') {
						var factType = [t, ['Verb', 'has'], currentLine[i]];
						this.AddFactType(factType, factType);
					}
				}
			}
		-> t,

		startComment =
			seq('--'),
		newComment =
			startComment toEOL,
		
		terminator =
			spaces keyword('.',true),
		lineStart :lineType =
			(	startTerm
			|	startFactType
			|	startRule
			|	allowedAttrs
			|	startComment
			),
		line =
			spaces
			(
				(	newTerm
				|	newFactType
				|	newRule
				|	attribute
				):l
				terminator? clearSuggestions
				spaces &(lineStart | end)
				{this.lines.push(l)}
				-> l
			|	newComment
			),
		expr =
			line* end
			-> this.lines
	}

	SBVRParser.keyTokens = ["startTerm", "startFactType", "startRule", "newComment", "Term", "modRule", "Verb", "keyword", "allowedAttrs", "num", "Value"];
	SBVRParser.clearSuggestions = function() {};
	/**
		Following are "instance" variables/functions rather than shared.
	*/
	SBVRParser.initialize = function() {
		this.reset();
	};
	
	SBVRParser._baseTerm = function(factTypeSoFar, term) {
		if(this.terms.hasOwnProperty(term)) {
			return this.terms[term];
		}
		if(this.terms.hasOwnProperty(term.singularize())) {
			return this.terms[term.singularize()];
		}
		return false;
	};

	SBVRParser.isTerm = function(factTypeSoFar, term) {
		var terms = this.possMap['Term'].call(this, factTypeSoFar);
		term = this._baseTerm(factTypeSoFar, term);
		return term !== false && ($.inArray(term,terms) !== -1 || $.inArray(term.singularize(),terms) !== -1);
	};

	SBVRParser._termForm = function(factTypeSoFar, term) {
		term = this._baseTerm(factTypeSoFar, term);
		return $.inArray(term.singularize(), this.possMap['Term'].call(this, factTypeSoFar)) !== -1 ? term.singularize() : term
	};

	SBVRParser.isVerb = function(factTypeSoFar, verb) {
		verb = ['Verb',this._verbForm(verb)];
		var currentLevel = this._traverseFactType(factTypeSoFar);
		if(currentLevel===false) {
			// We have no fact type matching this chain.
			return false;
		}
		if(currentLevel.hasOwnProperty(verb)) {
			// We found the verb.
			return true;
		}
		if(currentLevel.hasOwnProperty('__valid') && currentLevel.__valid===true) {
			// We have a valid fact type up to here, try a new one.
			// TODO: Should this actually be looking if the verb before last term is valid?
			return this.isVerb([], verb);
		}
		return false;
	};

	SBVRParser._verbForm = function(verb) {
		// People are eating.. Person is eating
		// Not: Police arest people.. Police isst people
		// I used a mispelling here because I could not find a case with a correct word, however in case I just missed one I'd rather check for the space.
		// People aren't animals.. Person isn't animal. Should probably be allowed, however what are our thoughts on contractions?
		if(verb.slice(0,4) == 'are ') {
			return 'is ' + verb.slice(4);
		}
		// Students are people.. Student is person
		if(verb == 'are') {
			return 'is';
		}
		// People have eyes.. Person has eyes
		if(verb=='have') {
			return 'has';
		}
		return verb;
	};

	SBVRParser.isFactType = function(factType) {
		var currentLevel = this._traverseFactType(factType);
		if(currentLevel === false) {
			return false;
		}
		return currentLevel.__valid;
	};

	var removeVerbRegex = new RegExp('^' + ['Verb',''].toString()),
		removeTermRegex = new RegExp('^' + ['Term',''].toString()),
		allowedAttrLists = [
			/*#IFDEF server */
				/* Custom Attributes */
				'Database ID Field:',
				'Database Name Field:',
				'Database Table Name:',
				/* End Custom */
			/*#ENDIFDEF*/
			'Dictionary Basis:',
			'Example:',
			'General Concept:',
			'Namespace URI:',
			'Necessity:',
			'Note:',
			'Possibility:',
			'Reference Scheme:',
			'See:',
			'Source:',
			'Subject Field:'
		];
		allowedAttrLists = {
			Term: [
				'Concept Type:',
				'Definition:',
				'Synonym:'
			].concat(allowedAttrLists),
			FactType: [
				'Synonymous Form:',
				'Term Form:'
			].concat(allowedAttrLists),
			Rule: []
		};
	SBVRParser.reset = function() {
		SBVRLibs.initialize.call(this);
		this.terms = {};
		this.possMap = {
			clearSuggestions: [], //This stops us suggesting any autocomplete before this point.
			startTerm: ['Term:     '],
			startFactType: ['Fact type:'],
			startRule: ['Rule:     '],
			Term: function(factTypeSoFar) {
				if(factTypeSoFar == null || factTypeSoFar.length == 0) {
					return _.keys(this.terms);
				}
				var term, currentLevel = this._traverseFactType(factTypeSoFar), terms = [];
				for(term in currentLevel) {
					if(currentLevel.hasOwnProperty(term)) {
						if(removeTermRegex.test(term)) {
							terms.push(term.replace(removeTermRegex,''))
						}
					}
				}
				return terms;
			},
			Verb: function(factTypeSoFar) {
				var verb, currentLevel = this._traverseFactType(factTypeSoFar), verbs = [];
				for(verb in currentLevel) {
					if(currentLevel.hasOwnProperty(verb)) {
						if(removeVerbRegex.test(verb)) {
							verbs.push(verb.replace(removeVerbRegex,''))
						}
					}
				}
				return verbs;
			},
			allowedAttrs: function(termOrFactType) {
				if(allowedAttrLists.hasOwnProperty(termOrFactType)) {
					return allowedAttrLists[termOrFactType];
				}
				else if(termOrFactType == null) {
					return allowedAttrLists.Term.concat(allowedAttrLists.FactType);
				}
				return [];
			},
			modRule: [
				'It is obligatory that',
				'It is necessary that',
				'It is prohibited that',
				'It is impossible that',
				'It is not possible that',
				'It is possible that',
				'It is permissible that'
			],
			quant: [
				'each',
				'a',
				'an',
				'some',
				'at most',
				'at least',
	//			'and at most',
				'more than',
				"exactly"
			],
			joinQuant: ['and at most'],
			num: [
				'1', '2', '3', '4', '5', '6', '7', '8', '9',
				'one'
			],
			addThat: ['that', 'that the'],
			addThe: ['the'],
			addComma: [','],
			addOr: ['or'],
			terminator: ['.']
		};
		this.ruleVars = {};
		this.ruleVarsCount = 0;
		this.lines = ['Model'];
	};

	SBVRParser.equals = function(compareTo) {
		// TODO: Can this be simplified to just compare lines (and made provably comparable)?
		if(!_.isEqual(this.terms, compareTo.terms)) {
			return false;
		}
		if(!_.isEqual(this.conceptTypes, compareTo.conceptTypes)) {
			return false;
		}
		if(!_.isEqual(this.factTypes, compareTo.factTypes)) {
			return false;
		}
		return true;
	};


	/** **/
	SBVRParser.matchForAny = function(rule,arr) {
		var origInput = this.input;
		for (var idx = 0; idx < arr.length; idx++) {
			try {
				this.input = origInput;
				return this._applyWithArgs.call(this, rule, arr[idx]);
			}
			catch (f) {
				if (f != fail) {
					console.log(f.stack);
					throw f;
				}
			}
		}
		throw fail;
	};
	SBVRParser.matchForAll = function(rule,arr) {
		var ret;
		for (var idx = 0; idx < arr.length; idx++) {
			ret = this._applyWithArgs.call(this, rule, arr[idx]);
		}
		return ret;
	};
	//TODO: This is a bit of a hack for case insensitivity, a better solution needs to be implemented in future.
	SBVRParser.exactly = function(wanted) {
		if (wanted.toLowerCase() === this._apply("anything").toLowerCase()) {
			return wanted;
		}
		throw fail;
	};
	
	return SBVRParser;

});