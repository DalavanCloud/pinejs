define(['underscore', 'ometa/ometa-base', 'inflection'], function(_) {
	var SBVRParser;

	//A parser for Semantics of Business Vocabulary and Rules (SBVR), an OMG standard.
	//Converts from Structured English (SBVR-SE) to Logical Formulation (SBVR-LF)
	//Specification: http://www.omg.org/spec/SBVR/1.0/

	ometa SBVRParser {
		isTerm		:factTypeSoFar :term
						= ?this._isTerm(factTypeSoFar, term),
		isVerb		:factTypeSoFar :verb
						= ?this._isVerb(factTypeSoFar, verb),
		isFctp		:factType
						= ?this._isFctp(factType),

		findVar		:x	= {this.ruleVars[x[1]]},
		bind		:x	= findVar(x):y											-> ['bind', x, y],

		letters			= letter+:l												-> l.join(''),
		num				= spaces digit+:n										-> ['num', parseInt(n.join(''))]
						| "one"													-> ['num', 1],
		toSBVREOL		= spaces (~(spaces lineStart) spaces?:s (~space anything)+:a -> s.concat(a).join(''))*:w
																				-> w.join(''),
		toEOL			= (~('\r'|'\n') anything)+:a							-> a.join(''),

		token		:x	= spaces seq(x):s &(space+)								-> s,

		addTerm			= &(termPart+):t {this.terms[t.join(' ')] = true}
						  term,
		term		:factTypeSoFar
						= findTerm(factTypeSoFar),
		findTerm	:factTypeSoFar :termSoFar
						= termPart:t {termSoFar = termSoFar==null ? t : [termSoFar, t].join(' ')}
							( findTerm(factTypeSoFar, termSoFar)
							| isTerm(factTypeSoFar, termSoFar)					-> ['term',this._termForm(factTypeSoFar, termSoFar)]
							),
		termPart		= spaces ~lineStart letters,
		
		
		addVerb			= clearSuggestions verb(true),
		verb		:factTypeSoFar
						= findVerb(factTypeSoFar),
		findVerb	:factTypeSoFar :verbSoFar
						= verbPart:v {verbSoFar = verbSoFar==undefined ? v : [verbSoFar, v].join(' ')}
							( findVerb(factTypeSoFar, verbSoFar)
							|	( ?(factTypeSoFar===true)
								| isVerb(factTypeSoFar, verbSoFar)
								)												-> ['verb',this._verbForm(verbSoFar)]
							),
		verbPart		= spaces ~lineStart ~term letters,
		
		joinQuant		= matchForAll('keyword',["and","at","most"]),
		
		// Be very careful with anywhere you use quant as any in-place modifications of the array will be remembered in memoisation.
		quant			= keyword("each")										-> ['univQ']
						| matchForAny('keyword',["a","an","some"])				-> ['existQ']
						| matchForAll('keyword',["at","most"])		num:n		-> ['atMostQ', ['maxCard', n]]
						| matchForAll('keyword',["at","least"])		num:n
											( joinQuant num:m					-> ['numRngQ', ['minCard', n], ['maxCard', m]]
											| empty 							-> ['atLeastQ', ['minCard', n]])
						| matchForAll('keyword',["more","than"])	num:n {++n[1]}
																				-> ['atLeastQ', ['minCard', n]]
						| keyword("exactly")						num:n		-> ['exactQ', ['card', n]],

		keyword		:word :noToken
						= ?(noToken==true) seq(word)
						| ?(noToken!=true) token(word),
		
		addThat			= keyword("that"),
		addThe			= keyword("the"),
		createVar	:term
						= {this.ruleVars[term[1]] = this.ruleVarsCount++}		-> ['var', ['num', this.ruleVars[term[1]]], term],
		checkThat	:term :termBind
						= addThat
							( addThe term:t bind(t):b {[[t],b]}:c verb(c[0]):v {c[0].push(v, term); c.push(termBind)}
								( ruleBody(c)
								| atfo(c) )
							|	( {[[term], termBind]}:c verb(c[0]):v {c[0].push(v)}
									( ruleBody(c, true)
									| atfo(c) )
								| ruleBody([[]]))
							),

		atfo		:c	= isFctp(c[0]) {c[0] = ['fcTp'].concat(c[0])}			-> ['aFrm'].concat(c),

		// c[0] should contain the current fact type that is being built
		// c[1..] should contain the bindings for the fact type being built
		ruleBody :c :exitOnTermFactType
			= quant:body term(c[0]):t createVar(t):tVar bind(t):b {c[0].push(t);c.push(b)}
				(checkThat(t, b):thatC {tVar.push(thatC)})?
				(
					verb(c[0]):v {c[0].push(v)}
					( ruleBody(c, true)
					| atfo(c)
					)
				| ?(exitOnTermFactType === true) atfo(c)
				):r
				{body.push(tVar, r)}
																			-> body,

		modRule			= "It" "is" 
							( "obligatory"		-> ['obl']
							| "necessary"		-> ['nec']
							| "prohibited"		-> ['obl', ['neg']]
							| "impossible"		-> ['nec', ['neg']]
							| "not" "possible"	-> ['nec', ['neg']]
							| "possible"		-> ['pos']
							| "permissible"		-> ['prm']
							):r
						  "that"											-> r,

		startRule		= "R:"|"Rule:",
		newRule			= startRule spaces &(toSBVREOL):ruleText {this.ruleVarsCount=0}
							modRule:r ruleBody([[]]):q {r.length == 2 ? r[1][1] = q : r[1] = q}
																			-> ['rule', r, ['text', ruleText]],
		terb			= term:t addVerb:v								-> [t, v],
		startFactType	= "F:"|"Fact type:",
		newFactType		= startFactType {[]}:fctp
							(term:t addVerb:v {fctp.push(t, v)})+
							(term:t {fctp.push(t)})?
							{this._addFactType(fctp); fctp.push([])}
																			-> ['fcTp'].concat(fctp),
		startTerm		= "T:"|"Term:",
		newTerm			= startTerm clearSuggestions addTerm:t {t.push([])}					-> t,
		attribute		= ?{this.lines[this.lines.length-1][0] == 'term' ||
							this.lines[this.lines.length-1][0] == 'fcTp'}
							allowedAttrs:attrName
							{attrName.replace(new RegExp(' ','g'),'')}:attrName
							applyFirstExisting(['attr'+attrName,'toSBVREOL']):attrVal
																			-> {var lastLine = this.lines.pop(); lastLine[lastLine.length-1].push([attrName, attrVal]); lastLine},
							
		allowedAttrs	= matchForAny('seq',this.possMap.allowedAttrs):attrName -> attrName.replace(':',''),
		attrDefinition	= ruleBody([[]]),
		attrConceptType	= term,

		startComment	= seq('--'),
		newComment		= startComment toEOL,
		
		terminator		= spaces keyword('.',true),
		lineStart		= startTerm
						| startFactType
						| startRule
						| allowedAttrs
						| startComment,
		line			= (spaces (newTerm | newFactType | newRule | attribute):l terminator? clearSuggestions spaces &(lineStart | end)
							{this.lines.push(l)}							-> l)
						| newComment,
		expr			= line* end											-> this.lines
	}

	SBVRParser.keyTokens = ["startTerm", "startFactType", "startRule", "newComment", "term", "modRule", "verb", "keyword", "allowedAttrs", "num"];
	SBVRParser.clearSuggestions = function() {}
	/**
		Following are "instance" variables/functions rather than shared.
	*/
	SBVRParser.initialize = function() {
		this.reset();
	}

	SBVRParser._isTerm = function(factTypeSoFar, term) {
		var terms = this.possMap.term(factTypeSoFar);
		return $.inArray(term,terms) !== -1 || $.inArray(term.singularize(),terms) !== -1
	}

	SBVRParser._termForm = function(factTypeSoFar, term) {
		return $.inArray(term.singularize(), this.possMap.term(factTypeSoFar)) !== -1 ? term.singularize() : term
	}

	SBVRParser._traverseFactType = function(fctp, create) {
		var currentLevel = this.factTypes;
		for(var i=0; i<fctp.length;i++) {
			currentFactTypePart = fctp[i];
			if(!currentLevel.hasOwnProperty(currentFactTypePart)) {
				if(create===true) {
					currentLevel[currentFactTypePart] = {}
				}
				else {
					return false;
				}
			}
			currentLevel = currentLevel[currentFactTypePart];
		}
		return currentLevel;
	}

	SBVRParser._isVerb = function(factTypeSoFar, verb) {
		verb = ['verb',this._verbForm(verb)];
		var currentLevel = this._traverseFactType(factTypeSoFar);
		if(currentLevel===false) {
			// We have no fact type matching this chain.
			return false;
		}
		if(currentLevel.hasOwnProperty(verb)) {
			// We found the verb.
			return true;
		}
		if(currentLevel.hasOwnProperty('__valid') && currentLevel.__valid===true) {
			// We have a valid fact type up to here, try a new one.
			// TODO: Should this actually be looking if the verb before last term is valid?
			return this._isVerb([], verb);
		}
		return false;
	}

	SBVRParser._verbForm = function(verb) {
		// People are eating.. Person is eating
		// Not: Police arest people.. Police isst people
		// I used a mispelling here because I could not find a case with a correct word, however in case I just missed one I'd rather check for the space.
		// People aren't animals.. Person isn't animal. Should probably be allowed, however what are our thoughts on contractions?
		if(verb.slice(0,4) == 'are ') {
			return 'is ' + verb.slice(4)
		}
		// Students are people.. Student is person
		if(verb == 'are') {
			return 'is'
		}
		// People have eyes.. Person has eyes
		if(verb=='have') {
			return 'has'
		}
		return verb;
	}

	SBVRParser._addFactType = function(factType) {
		this._traverseFactType(factType, true).__valid = true;
	}

	SBVRParser._isFctp = function(factType) {
		var currentLevel = this._traverseFactType(factType);
		if(currentLevel === false) {
			return false;
		}
		return currentLevel.__valid = true;
	}

	var removeVerbRegex = new RegExp('^' + ['verb',''].toString()),
		removeTermRegex = new RegExp('^' + ['term',''].toString());
	SBVRParser.reset = function() {
		var self = this;
		this.factTypes = {};
		this.terms = {};
		this.possMap = {
			clearSuggestions: [], //This stops us suggesting any autocomplete before this point.
			startTerm: ['Term:     '],
			startFactType: ['Fact type:'],
			startRule: ['Rule:     '],
			term: function(factTypeSoFar) {
				if(factTypeSoFar == null || factTypeSoFar.length == 0) {
					return _.keys(self.terms);
				}
				var term, currentLevel = self._traverseFactType(factTypeSoFar), terms = [];
				for(term in currentLevel) {
					if(currentLevel.hasOwnProperty(term)) {
						if(removeTermRegex.test(term)) {
							terms.push(term.replace(removeTermRegex,''))
						}
					}
				}
				return terms;
			},
			verb: function(factTypeSoFar) {
				var verb, currentLevel = self._traverseFactType(factTypeSoFar), verbs = [];
				for(verb in currentLevel) {
					if(currentLevel.hasOwnProperty(verb)) {
						if(removeVerbRegex.test(verb)) {
							verbs.push(verb.replace(removeVerbRegex,''))
						}
					}
				}
				return verbs;
			},
			allowedAttrs: [
				'Concept Type:',
				/*#IFDEF server */
					/* Custom Attributes */
					'Database ID Field:',
					'Database Name Field:',
					'Database Table Name:',
					/* End Custom */
				/*#ENDIFDEF*/
				'Definition:',
				'Dictionary Basis:',
				'Example:',
				'General Concept:',
				'Namespace URI:',
				'Necessity:',
				'Note:',
				'Possibility:',
				'Reference Scheme:',
				'See:',
				'Source:',
				'Subject Field:',
				'Synonymous Form:',
				'Synonym:'
			],
			modRule: [
				'It is obligatory that',
				'It is necessary that',
				'It is prohibited that',
				'It is impossible that',
				'It is not possible that',
				'It is possible that',
				'It is permissible that'
			],
			quant: [
				'each',
				'a',
				'an',
				'some',
				'at most',
				'at least',
	//			'and at most',
				'more than',
				"exactly"
			],
			joinQuant: ['and at most'],
			num: [
				'1', '2', '3', '4', '5', '6', '7', '8', '9',
				'one'
			],
			addThat: ['that', 'that the'],
			addThe: ['the'],
			terminator: ['.']
		}
		this.ruleVars = {}
		this.ruleVarsCount = 0
		this.lines = ['model']
	}

	SBVRParser.equals = function(compareTo) {
		if(!_.isEqual(this.terms, compareTo.terms)) return false
		if(!_.isEqual(this.factTypes, compareTo.factTypes)) {
			return false;
		}
		return true;
	}


	/** **/
	SBVRParser.matchForAny = function(rule,arr) {
		var origInput = this.input
		for (var idx = 0; idx < arr.length; idx++)
			try { this.input = origInput; return this._applyWithArgs.call(this, rule, arr[idx]) }
			catch (f) {
				if (f != fail) {
					console.log(f.stack)
					throw f
				}
			}
		throw fail
	}
	SBVRParser.matchForAll = function(rule,arr) {
		var ret
		for (var idx = 0; idx < arr.length; idx++)
			ret = this._applyWithArgs.call(this, rule, arr[idx])
		return ret
	}
	SBVRParser.applyFirstExisting = function(arr) {
		for (var i = 0; i < arr.length; i++)
			if(this[arr[i]] != undefined)
				return this._apply(arr[i])
	}
	/* This is a bit of a hack for case insensitivity, a better solution needs to be implemented in future. */
	SBVRParser.exactly = function(wanted) {
		if (wanted.toLowerCase() === this._apply("anything").toLowerCase())
			return wanted
		throw fail
	}
	
	return SBVRParser;

});