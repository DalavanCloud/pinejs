define(['underscore', 'ometa/ometa-base'], function(_) {
	var SBVRLibs;
	
	ometa SBVRLibs {}
	
	SBVRLibs.initialize = function() {
		this.factTypes = {};
		this.conceptTypes = {};
	}
	
	SBVRLibs.ApplyFirstExisting = function(rules, ruleArgs) {
		if(ruleArgs == null) {
			ruleArgs = [];
		}
		for (var i = 0; i < rules.length; i++) {
			if(this[rules[i]] != undefined) {
				if(ruleArgs != null && ruleArgs.length > 0) {
					ruleArgs.unshift(rules[i]);
					return this._applyWithArgs.apply(this, ruleArgs);
				}
				return this._apply(rules[i], ruleArgs);
			}
		}
	}
	
	SBVRLibs.AddFactType = function(factType, realFactType) {
		realFactType = _.extend([], realFactType)
		this._traverseFactType(factType, realFactType);
		if(factType.length == 3 && factType[1][1] == 'has') {
			this._traverseFactType([factType[2], ['Verb', 'is of'], factType[0]], realFactType);
		}
		else if(factType.length == 3 && factType[1][1] == 'is of') {
			this._traverseFactType([factType[2], ['Verb', 'has'], factType[0]], realFactType);
		}
	};

	SBVRLibs._traverseFactType = function(factType, create) {
		var self = this,
			traverseRecurse = function(currentFactTypePart, remainingFactType, currentLevel) {
			if(currentFactTypePart == null) {
				if(create) {
					currentLevel.__valid = create;
				}
				return currentLevel;
			}
			var finalLevel, finalLevels = {};
			
			if(currentLevel.hasOwnProperty(currentFactTypePart) || (create && (currentLevel[currentFactTypePart] = {})) ) {
				finalLevel = traverseRecurse(remainingFactType[0], remainingFactType.slice(1), currentLevel[currentFactTypePart]);
				if(finalLevel != false) {
					_.extend(finalLevels, finalLevel);
				}
			}
			
			if(!create && currentFactTypePart[0] == 'Term') {
				while( self.conceptTypes.hasOwnProperty(currentFactTypePart[1]) ) {
					currentFactTypePart = ['Term', self.conceptTypes[currentFactTypePart[1]]];
					if( currentLevel.hasOwnProperty(currentFactTypePart) ) {
						// We use recursion so here we go down each branch until we find the suitable one, or run out of branches.
						finalLevel = traverseRecurse(remainingFactType[0], remainingFactType.slice(1), currentLevel[currentFactTypePart]);
						if(finalLevel !== false) {
							_.extend(finalLevels, finalLevel);
						}
					}
				}
			}
			return _.isEmpty(finalLevels) === true ? false : finalLevels;
		};
		return traverseRecurse(factType[0], factType.slice(1), this.factTypes);
	};

	SBVRLibs.ActualFactType = function(factType) {
		var traverseInfo = this._traverseFactType(factType);
		if(traverseInfo===false || !traverseInfo.hasOwnProperty('__valid')) {
			return false;
		}
		return traverseInfo.__valid;
	};

	SBVRLibs.FactTypeRootTerms = function(factType, actualFactType) {
		var $elf = this,
			rootTerms = [],
			rootTermIndex = 0;
		for(var i=0; i<actualFactType.length; i+=2) {
			// Check that terms match.
			if(factType[i][1] != actualFactType[i][1]) {
				// Find the term in the fact type that matches (for synonymous form)
				for(var j=0; j<actualFactType.length; j++ && rootTerms.length == rootTermIndex) {
					var termName = factType[i][1];
					if(termName != actualFactType[j][1]) {
						while( self.conceptTypes.hasOwnProperty(termName) ) {
							termName = self.conceptTypes[termName];
							if( termName == actualFactType[j][1] ) {
								rootTerms[rootTermIndex] = termName;
								break;
							}
						}
					}
					else {
						rootTerms[rootTermIndex] = termName;
						break;
					}
				}
			}
			else {
				rootTerms[rootTermIndex] = factType[i][1];
			}
			rootTermIndex++;
		}
		return rootTerms;
	};
	
	// ometaifyObject = function(variable) {
		// if(_.isArray(variable)) {
			// for(var i=0;i<variable.length;i++) {
				// variable[i] = ometaifyObject(variable[i]);
			// }
			// return variable;
		// }
		// if (typeof variable === 'object') {
			// var ometaArray = [];
			// for(var key in variable) {
				// if(variable.hasOwnProperty(key)) {
					// ometaArray.push([key, ometaifyObject(variable[key])]);
				// }
			// }
			// return ometaArray;
		// }
		// return variable;
	// }
	
	return SBVRLibs;
});	