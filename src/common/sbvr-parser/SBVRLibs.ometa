define(['underscore', 'ometa-core'], function(_) {

	ometa SBVRLibs {}

	SBVRLibs.TYPE_VOCAB = 'Type';
	
	SBVRLibs.initialize = function() {
		this.currentVocabulary = '';
		this.vocabularies = {};
		this.factTypes = {};
	};
	
	SBVRLibs.ApplyFirstExisting = function(rules, ruleArgs) {
		if(ruleArgs == null) {
			ruleArgs = [];
		}
		ruleArgs.unshift('');
		for (var i = 0; i < rules.length; i++) {
			if(this[rules[i]] != undefined) {
				if(ruleArgs != null && ruleArgs.length > 0) {
					ruleArgs[0] = rules[i];
					return this._applyWithArgs.apply(this, ruleArgs);
				}
				return this._apply(rules[i], ruleArgs);
			}
		}
	};

	SBVRLibs.IdentifiersEqual = function(a, b) {
		return a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
	};

	SBVRLibs.IsPrimitive = function(term) {
		// do {
			if (term[2] == this.TYPE_VOCAB) {
				return term[1];
			}
		// } while (this.conceptTypes.hasOwnProperty(termName) && (termName = this.conceptTypes[termName]));
		var conceptTypes = this.vocabularies[term[2]]['ConceptTypes'];
		if (conceptTypes.hasOwnProperty(term) && (term = conceptTypes[term])) {
			if (term[2] == this.TYPE_VOCAB) {
				return term[1];
			}
		}
		return false;
	};
	
	SBVRLibs.AddVocabulary = function(vocabulary, baseSynonym) {
		this.currentVocabulary = baseSynonym;
		if(!this.vocabularies.hasOwnProperty(baseSynonym)) {
			this.vocabularies[baseSynonym] = {
				'Term': {},
				'Name': {},
				'IdentifierChildren': {},
				'ConceptTypes': {}
			};
		}
		if(!this.vocabularies.hasOwnProperty(vocabulary)) {
			this.vocabularies[vocabulary] = this.vocabularies[baseSynonym];
		}
	};
	
	SBVRLibs.AddFactType = function(factType, realFactType) {
		var mappedFactType = [];
		for(var i = 0; i < realFactType.length; i++) {
			var realFactTypePart = realFactType[i];
			mappedFactType[i] = realFactTypePart.slice(0, 3);
			for(var j = 0; j < factType.length; j++) {
				var factTypePart = factType[j];
				if(realFactTypePart[0] != 'Verb' // Not a verb
					&& this.IdentifiersEqual(realFactTypePart, factTypePart) // The term/name matches
					&& realFactTypePart.length == factTypePart.length // And they have the same length (so both have/do not have an instance number
					&& (realFactTypePart.length < 4 || realFactTypePart[3][1] == factTypePart[3][1])) { // And they have no instance number, or the instance number matches.
					mappedFactType[i][3] = j;
				}
			}
		}
		this._traverseFactType(factType, mappedFactType);
		if(factType.length == 3 && (factType[1][1] == 'has' || factType[1][1] == 'is of')) {
			mappedFactType = _.extend([], mappedFactType);
			mappedFactType[0] = mappedFactType[0].slice(0, 3).concat(2);
			mappedFactType[2] = mappedFactType[2].slice(0, 3).concat(0);
			if(factType[1][1] == 'has') {
				this._traverseFactType([factType[2], ['Verb', 'is of', factType[1][2]], factType[0]], mappedFactType);
			}
			else if(factType[1][1] == 'is of') {
				this._traverseFactType([factType[2], ['Verb', 'has', factType[1][2]], factType[0]], mappedFactType);
			}
		}
	};

	SBVRLibs._traverseFactType = function(factType, create) {
		var self = this,
			traverseRecurse = function(currentFactTypePart, remainingFactType, currentLevel) {
			if(currentFactTypePart == null) {
				if(create) {
					currentLevel.__valid = create;
				}
				return currentLevel;
			}
			var finalLevel, finalLevels = {};
			switch(currentFactTypePart[0]) {
				case 'Verb':
					currentFactTypePart = currentFactTypePart.slice(0, 2); // Make sure we only use the first 2 parts for verbs.
				break;
				default:
					currentFactTypePart = currentFactTypePart.slice(0, 3); // Make sure we only use the first 3 parts for everything else.
			}
			
			if(currentLevel.hasOwnProperty(currentFactTypePart) || (create && (currentLevel[currentFactTypePart] = {})) ) {
				finalLevel = traverseRecurse(remainingFactType[0], remainingFactType.slice(1), currentLevel[currentFactTypePart]);
				if(finalLevel != false) {
					_.extend(finalLevels, finalLevel);
				}
			}
			
			if(!create && (currentFactTypePart[0] == 'Term' || currentFactTypePart[0] == 'Name')) {
				var conceptTypes;
				while( (conceptTypes = self.vocabularies[currentFactTypePart[2]]['ConceptTypes'])
						&& conceptTypes.hasOwnProperty(currentFactTypePart) ) {
					currentFactTypePart = conceptTypes[currentFactTypePart];
					if( currentLevel.hasOwnProperty(currentFactTypePart) ) {
						// We use recursion so here we go down each branch until we find the suitable one, or run out of branches.
						finalLevel = traverseRecurse(remainingFactType[0], remainingFactType.slice(1), currentLevel[currentFactTypePart]);
						if(finalLevel !== false) {
							_.extend(finalLevels, finalLevel);
						}
					}
				}
			}
			return _.isEmpty(finalLevels) === true ? false : finalLevels;
		};
		return traverseRecurse(factType[0], factType.slice(1), this.factTypes);
	};

	SBVRLibs.MappedFactType = function(factType) {
		var traverseInfo = this._traverseFactType(factType);
		if(traverseInfo===false || !traverseInfo.hasOwnProperty('__valid')) {
			return false;
		}
		return traverseInfo.__valid;
	};

	SBVRLibs.ActualFactType = function(factType) {
		var mappedFactType = this.MappedFactType(factType);
		if(mappedFactType === false) {
			return false;
		}
		var actualFactType = [];
		for(var i = 0; i < mappedFactType.length; i++) {
			actualFactType[i] = mappedFactType[i].slice(0, 3);
		}
		// Keep the negated status the same as fact type passed in.
		actualFactType[1][2] = factType[1][2];
		return actualFactType;
	};
	
	SBVRLibs.IsChild = function(child, parent) {
		var conceptTypes;
		// Parent should be in the form ['Term', ...], where we care about the ... bit.
		do {
			if(this.IdentifiersEqual(child, parent)) {
				return true;
			}
			conceptTypes = this.vocabularies[parent[2]]['ConceptTypes'];
		} while( conceptTypes.hasOwnProperty(child) && (child = conceptTypes[child]) );
		return false;
	};

	SBVRLibs.FactTypeRootTerms = function(factType) {
		var mappedFactType = this.MappedFactType(factType);
		if(mappedFactType === false) {
			return false;
		}
		var schemaInfo = [],
			schemaInfoIndex = 0,
			usedTermNames = {};
		for(var i=0; i < factType.length; i+=2) {
			for(var j=0; j < mappedFactType.length; j+=2) {
				var mappedFactTypePart = mappedFactType[j];
				if(mappedFactTypePart[3] == i) {
					var term = mappedFactTypePart.slice(0, 3);
					schemaInfo[schemaInfoIndex++] = {
						term: term,
						field: mappedFactTypePart[1]
					};
					// TODO: Should account for vocabulary
					if(usedTermNames.hasOwnProperty(term)) {
						usedTermNames[term] = 0;
					}
					else {
						usedTermNames[term] = null;
					}
				}
			}
		}
		for(var i=0; i < schemaInfo.length; i++) {
			if(usedTermNames[schemaInfo[i].term] != null) {
				schemaInfo[i].field = schemaInfo[i].field + (++usedTermNames[schemaInfo[i].term]);
			}
		}
		return schemaInfo;
	};
	
	SBVRLibs.GetResourceName = function(termOrFactType) {
		var i = 0, resource = [];
		if(_.isString(termOrFactType)) {
			return termOrFactType.replace(new RegExp(' ', 'g'), '_');
		}
		else {
			for(;i < termOrFactType.length; i++) {
				resource.push(termOrFactType[i][1].replace(new RegExp(' ', 'g'), '_'));
			}
			return resource.join('-');
		}
	};
	
	SBVRLibs.GetTableID = function(termOrFactType) {
		switch(termOrFactType[0]) {
			case 'Term':
			case 'Name':
				return termOrFactType[1];
			default:
				return termOrFactType;
		}
	};
	
	SBVRLibs.GetTable = function(termNameOrFactType) {
		return this.tables[this.GetResourceName(termNameOrFactType)];
	};
	
	SBVRLibs.GetTableField = function(table, fieldName) {
		var fieldID = this.GetTableFieldID(table, fieldName);
		if(fieldID === false) {
			return false;
		}
		return table.fields[fieldID];
	};
	
	SBVRLibs.GetTableFieldID = function(table, fieldName) {
		var tableFields = table.fields;
		for(var i = 0; i < tableFields.length; i++) {
			if(tableFields[i][1] == fieldName) {
				return i;
			}
		}
		return false;
	};
	
	// ometaifyObject = function(variable) {
		// if(_.isArray(variable)) {
			// for(var i=0;i<variable.length;i++) {
				// variable[i] = ometaifyObject(variable[i]);
			// }
			// return variable;
		// }
		// if (typeof variable === 'object') {
			// var ometaArray = [];
			// for(var key in variable) {
				// if(variable.hasOwnProperty(key)) {
					// ometaArray.push([key, ometaifyObject(variable[key])]);
				// }
			// }
			// return ometaArray;
		// }
		// return variable;
	// }
	
	return SBVRLibs;
});	
