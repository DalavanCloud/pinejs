define(['sbvr-parser/SBVRParser', 'underscore', 'Prettify', 'sbvr-frame/SBVRModels', 'ometa/ometa-base', 'inflection'], function(SBVRParser, _, Prettify) {
	var SBVR_LF2SE;
	ometa SBVR_LF2SE {
	  $ :x       = token(x):a                              -> [a] 
				 |                                         -> [],

	  trans      [:t apply(t):a]                           -> a,
	  token :x   [:t ?{t==x} apply(x):a]                   -> a,

	  letters    = letter+:l space*                        -> l.join(''),

	  num        number:n ?{!isNaN(n)}                     -> [`num, parseInt(n)],

	  Model      ("Term"|"FactType"|"rule")*:xs                -> ['Model'].concat(xs),
		
	  FactType   {a=[]}("Term":t "Verb":v {a=a.concat([t,v])})* $('Term'):e  (:attr->[attr]|->[]):attr
														   -> a.concat(e),

	  Verb       :v                                        -> ['Verb', v],
	  Term       :t (:attr->[attr]|->[]):attr              -> ['Term', t].concat(attr),
	  rule       ("obl"|"nec"|"pos"|"prm"):x "text":t      -> [`rule, x, t],

	  text	     :a	                                       -> [`text, a],
	  
	  obl        trans*:xs                                 -> [`obl].concat(xs),
	  nec        trans*:xs                                 -> [`nec].concat(xs),
	  pos        trans*:xs                                 -> [`pos].concat(xs),
	  prm        trans*:xs                                 -> [`prm].concat(xs),

	  neg        trans:xs                                  -> [`neg].concat([xs]),

	  quant      = "univQ" | "existQ" | "exactQ" | "atMostQ" | "atLeastQ" | "numRngQ" ,
	  univQ                              "var":v trans*:xs -> [`univQ, v].concat(xs),
	  existQ                             "var":v trans*:xs -> [`existQ, v].concat(xs),
	  exactQ     "card":i                "var":v trans*:xs -> [`exactQ, i, v].concat(xs),
	  atMostQ                "maxCard":a "var":v trans*:xs -> [`atMostQ, a, v].concat(xs),
	  atLeastQ   "minCard":i             "var":v trans*:xs -> [`atLeastQ, i, v].concat(xs),
	  numRngQ    "minCard":i "maxCard":a "var":v trans*:xs -> [`numRngQ, i, a, v].concat(xs),

	  card       "num":n                                   -> [`card, n],
	  minCard    "num":n                                   -> [`minCard, n],
	  maxCard    "num":n                                   -> [`maxCard, n],

	  var        "num":n "Term":t "AtomicFormulation":w //{this.findReplace(w, n[1], t[1]);}
														   -> [`var, n, t, w],
	  var        "num":n "Term":t quant:w                  -> [`var, n, t, w],    
	  var        "num":n "Term":t                          -> [`var, n, t],

	  bind       "Term":t number:n                         -> [`bind, t, n], 
	  AtomicFormulation       "FactType":f "bind"*:b {for(var i = 0; i<b.length; i++) {this.findReplace(f, b[i][1], b[i][2]);}}
								   -> f
	}

	SBVR_LF2SE.initialize = function() { this._didSomething = false }

	SBVR_LF2SE.findReplace = function(targetArray, oldValue) {
	  /* finds oldValue in targetArray and adds the rest 
	  of the arguments as elements in its place */
	  
	  newValues = Array.prototype.slice.call(arguments, 2);
	  //alert([targetArray, oldValue, newValues]);
	  
	  for(var i=0;i<targetArray.length;i++) {
		if(targetArray[i]==oldValue || _.isEqual(targetArray[i], oldValue)) {
		  Array.prototype.splice.apply(targetArray,[i,1].concat(newValues));
		}
	  }
	  
	  //alert(targetArray);
	}

	// tree = SBVRParser.matchAll(model2, "expr")
	// tree = SBVR_LF2SE.match(tree, "trans")
	// Prettify.match(tree, "elem")

	return SBVR_LF2SE;
});