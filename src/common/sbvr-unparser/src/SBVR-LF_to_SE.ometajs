define(['sbvr-parser/SBVRParser', 'ometa!prettify/Prettify', 'underscore', 'sbvr-frame/SBVRModels', 'ometa-core', 'inflection'], function(SBVRParser, Prettify) {
	ometa SBVR_LF2SE {
		$ :x =
				token(x):a
				-> [a] 
			|	-> [],

		trans
			[:t apply(t):a]
			-> a,
		token
			:x [:t ?{t==x} apply(x):a]
			-> a,

		letters =
			letter+:l space*
			-> l.join(''),

		Number
			number:n ?{!isNaN(n)}
			-> ['Number', parseInt(n)],

		Model
			("Term"|"FactType"|"Rule")*:xs
			-> ['Model'].concat(xs),
		
		FactType
			{a=[]}("Term":t "Verb":v {a=a.concat([t,v])})* $('Term'):e (:attr->[attr]|->[]):attr
			-> a.concat(e),

		Verb
			:v
			-> ['Verb', v],
		Term
			:t (:attr->[attr]|->[]):attr
			-> ['Term', t].concat(attr),
		Rule
			(	"ObligationFormulation"
			|	"NecessityFormulation"
			|	"PossibilityFormulation"
			|	"PermissibilityFormulation"
			):x
			"StructuredEnglish":t
			-> ['Rule', x, t],

		StructuredEnglish
			:a
			-> ['StructuredEnglish', a],
	
		ObligationFormulation
			trans*:xs
			-> ['ObligationFormulation'].concat(xs),
		NecessityFormulation
			trans*:xs
			-> ['NecessityFormulation'].concat(xs),
		PossibilityFormulation
			trans*:xs
			-> ['PossibilityFormulation'].concat(xs),
		PermissibilityFormulation
			trans*:xs
			-> ['PermissibilityFormulation'].concat(xs),

		LogicalNegation
			trans:xs
			-> ['LogicalNegation'].concat([xs]),

		quant =
			"UniversalQuantification" | "ExistentialQuantification" | "ExactQuantification" | "AtMostNQuantification" | "AtLeastNQuantification" | "NumericalRangeQuantification",
		UniversalQuantification
			"Variable":v trans*:xs
			-> ['UniversalQuantification', v].concat(xs),
		ExistentialQuantification
			"Variable":v trans*:xs
			-> ['ExistentialQuantification', v].concat(xs),
		ExactQuantification
			"Cardinality":i "Variable":v trans*:xs
			-> ['ExactQuantification', i, v].concat(xs),
		AtMostNQuantification
			"MaximumCardinality":a "Variable":v trans*:xs
			-> ['AtMostNQuantification', a, v].concat(xs),
		AtLeastNQuantification
			"MinimumCardinality":i "Variable":v trans*:xs
			-> ['AtLeastNQuantification', i, v].concat(xs),
		NumericalRangeQuantification
			"MinimumCardinality":i "MaximumCardinality":a "Variable":v trans*:xs
			-> ['NumericalRangeQuantification', i, a, v].concat(xs),

		Cardinality
			"Number":n
			-> ['Cardinality', n],
		MinimumCardinality
			"Number":n
			-> ['MinimumCardinality', n],
		MaximumCardinality
			"Number":n
			-> ['MaximumCardinality', n],

		Variable
			"Number":n "Term":t "AtomicFormulation":w //{this.findReplace(w, n[1], t[1]);}
			-> ['Variable', n, t, w],
		Variable
			"Number":n "Term":t quant:w
			-> ['Variable', n, t, w],
		Variable
			"Number":n "Term":t
			-> ['Variable', n, t],

		RoleBinding
			"Term":t number:n
			-> ['RoleBinding', t, n], 
		AtomicFormulation
			"FactType":f "RoleBinding"*:b {for(var i = 0; i<b.length; i++) {this.findReplace(f, b[i][1], b[i][2]);}}
			-> f
	}

	SBVR_LF2SE.initialize = function() {
		this._didSomething = false;
	};

	SBVR_LF2SE.findReplace = function(targetArray, oldValue) {
		/* finds oldValue in targetArray and adds the rest 
		of the arguments as elements in its place */

		var newValues = Array.prototype.slice.call(arguments, 2);
		//alert([targetArray, oldValue, newValues]);

		for(var i=0;i<targetArray.length;i++) {
			if(targetArray[i]==oldValue || _.isEqual(targetArray[i], oldValue)) {
				Array.prototype.splice.apply(targetArray,[i,1].concat(newValues));
			}
		}

		//alert(targetArray);
	};

	// tree = SBVRParser.matchAll(model2, "expr")
	// tree = SBVR_LF2SE.match(tree, "trans")
	// Prettify.match(tree, "elem")

	return SBVR_LF2SE;
});