define(['ometa!server-glue/uri-parser', 'underscore', 'ometa-core'], function(URIParser, _) {
	ometa ODataParser <: URIParser {
		ProcessURI :body =
			(	?(!_.isObject(body))
				{{}}:body
			)?
			'/'
			(	{this.currentBody = body}
				{this.newBody = {}}
				ResourceName:resourceName
				(	{['Query']}:query
					AddQueryResource(query, resourceName)
					Modifiers(query)
				)?
			|	seq('$metadata'):resourceName
			)
			-> [{resourceName: resourceName, query: query, values: this.newBody}],

		Vocabulary =
			<	(	~'/'
					anything
				)+
			>,

		ResourcePart =
			<	(	letter
				|	'_'
				)+
			>:resourcePart
			-> resourcePart.replace(new RegExp('_', 'g'), ' '),

		ResourceName =
			<	ResourcePart
				(	'-'
					ResourcePart
				)*
			>,

		Comparator =
				seq('eq')
				-> 'Equals'
			|	seq('ne')
				-> 'NotEquals'
			|	seq('gt')
				-> 'GreaterThan'
			|	seq('gte')
				-> 'GreaterThanOrEqual'
			|	seq('lt')
				-> 'LessThan'
			|	seq('lte')
				-> 'LessThanOrEqual',
			// OData doesn't support like
			// |	'like'
				// -> 'Like',

		Modifiers :query =
			'?'
			(	'&'?
				(	Filters(query)
				|	Sorts:sorts
					{query.push(sorts)}
				|	Limit:limit
					{query.push(limit)}
				|	Offset:offset
					{query.push(offset)}
				)
			)*,

		Field =
			(	ResourcePart:resourceName '/' ResourcePart:resourceFieldName
			|	{this.currentResource}:resourceName
				ResourcePart:resourceFieldName
			)
			GetMapping(resourceName, resourceFieldName):mapping
			-> ['ReferencedField'].concat(mapping),

		Filters :query =
			seq('$filter=')
			(	Field:field
				' '
				Comparator:comparator
				' '
				<	(	~ValueBreak
						anything
					)+
				>:value
				seq(' and ')?
				{field[1]}:resourceName
				{field[2]}:resourceFieldName
				GetMapping(resourceName,resourceFieldName):mapping
				AddWhereClause(query, [comparator, field, ['Bind', mapping[0], this.GetTableField(mapping)]])
				AddBodyVar(query, resourceName, resourceFieldName, mapping, value)
			)+,

		Number = <digit+>:d -> ['Number', parseInt(d, 10)],

		Limit =
			seq('$top=')
			Number:num
			->	['Limit', num],

		Offset =
			seq('$skip=')
			Number:num
			->	['Offset', num],

		Sorts =
			seq('$orderby=')
			(	Field:field
				(	' '
					(	seq('asc')
					|	seq('desc')
					):direction
				|	-> 'ASC'
				)
				seq(', ')?
				-> [direction.toUpperCase(), field]
			)+:sorts
			->	['OrderBy'].concat(sorts),

		ValueBreak =
			(	seq(' and ')
			// |	'*'
			// |	'/'
			)
	}

	ODataParser.type = 'OData';

	return ODataParser;
});