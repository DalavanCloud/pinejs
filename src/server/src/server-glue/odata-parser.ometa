define(['ometa!server-glue/uri-parser', 'underscore', 'ometa-core'], function(URIParser, _) {
	ometa ODataParser <: URIParser {
		ProcessURI :body =
			(	?(!_.isObject(body))
				{{}}:body
			)?
			'/'
			(	{this.currentBody = body}
				{this.newBody = {}}
				ResourceName:resourceName
				(	{['Query']}:query
					AddQueryResource(query, resourceName)
					Modifiers(query)
				)?
			|	seq('$metadata'):resourceName
			)
			-> [{resourceName: resourceName, query: query, values: this.newBody}],

		Vocabulary =
			<	(	~'/'
					anything
				)+
			>,

		ResourcePart =
			<	(	letter
				|	'_'
				)+
			>:resourcePart
			-> resourcePart.replace(new RegExp('_', 'g'), ' '),

		ResourceName =
			<	ResourcePart
				(	'-'
					ResourcePart
				)*
			>,

		Comparator =
				seq('eq')
				-> 'Equals'
			|	seq('ne')
				-> 'NotEquals'
			|	seq('gt')
				-> 'GreaterThan'
			|	seq('gte')
				-> 'GreaterThanOrEqual'
			|	seq('lt')
				-> 'LessThan'
			|	seq('lte')
				-> 'LessThanOrEqual',
			// OData doesn't support like
			// |	'like'
				// -> 'Like',

		Modifiers :query =
			'?'
			(	'&'?
				(	Filters(query)
				|	Sorts:sorts
					{query.push(sorts)}
				|	Limit:limit
					{query.push(limit)}
				|	Offset:offset
					{query.push(offset)}
				)
			)*,

		Field =
			(	ResourcePart:resourceName '/' ResourcePart:resourceFieldName
			|	{this.currentResource}:resourceName
				ResourcePart:resourceFieldName
			)
			GetMapping(resourceName, resourceFieldName):mapping
			-> ['ReferencedField'].concat(mapping),

		Filters :query =
			seq('$filter=')
			Filter(query)
			(	seq(' and ')
				Filter(query)
			)*,

		Filter :query =
			(	LikeFunction
			|	Comparison
			):whereClause
			AddWhereClause(query, whereClause),
		
		Comparison =
			(	Field
			|	Text
			|	Number
			):operand1
			' '+
			Comparator:comparator
			' '+
			(	Field
			|	Text
			|	Number
			):operand2
			-> [comparator, operand1, operand2],

		LikeFunction =
			(	seq('substringof')
				{true}:startWild
				{true}:endWild
			|	seq('startswith')
				{true}:endWild
			|	seq('endswith')
				{true}:startWild
			)
			'('
			(	Field
			|	Text
			):needle
			','
			' '*
			(	Field
			|	Text
			):haystack
			seq(')')
			(	?(startWild && endWild)
				{['Concat', ['Text', '%'], needle, ['Text', '%']]}:needle
			|	?(startWild)
				{['Concat', ['Text', '%'], needle]}:needle
			|	?(endWild)
				{['Concat', needle, ['Text', '%']]}:needle
			)?
			{['Like', haystack, needle]}:whereClause
			(	' '+
				seq('eq')
				' '+
				(	seq('true')
				|	seq('false')
					{['Not', whereClause]}:whereClause 
				)
			)?
			-> whereClause,

		Text =
			'\''
			<	(	~'\''
					(	'\\' anything
					|	anything
					)
				)*
			>:text
			'\''
			-> ['Text', text],

		Number =
			<digit+>:d
			-> ['Number', parseInt(d, 10)],

		Limit =
			seq('$top=')
			Number:num
			->	['Limit', num],

		Offset =
			seq('$skip=')
			Number:num
			->	['Offset', num],

		Sorts =
			seq('$orderby=')
			(	Field:field
				(	' '
					(	seq('asc')
					|	seq('desc')
					):direction
				|	-> 'ASC'
				)
				seq(', ')?
				-> [direction.toUpperCase(), field]
			)+:sorts
			->	['OrderBy'].concat(sorts),

		ValueBreak =
			(	seq(' and ')
			// |	'*'
			// |	'/'
			)
	}

	ODataParser.type = 'OData';

	return ODataParser;
});