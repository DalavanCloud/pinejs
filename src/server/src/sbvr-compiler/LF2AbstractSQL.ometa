define([
	'ometa!sbvr-parser/SBVRLibs',
	'ometa-core'
], function(SBVRLibs) {
	//Transformation from SBVR Logical Formulation to SQL
	var _ = require('underscore');

	ometa LF2AbstractSQL <: SBVRLibs {
		Number =
			[	'Number'
				number:num
				?{!isNaN(num)}
			]
			-> num,

		Integer
			[	'Integer'
				number:num
				?{!isNaN(num)}
			]
			-> ['Integer', num],

		Text
			[	'Text'
				anything:text
			]
			-> ['Text', text],
				
		
		/** Terms **/
		Identifier =
			{''}:num
			[	(	'Term'
				|	'Name'
				):type
				:name
				(	// Var number
					Number:num
				|	// Or embedded data, which we ignore the embedded data as it is retreived from the binding instead
					Integer
				|	Text
				)?
			]
			-> {type: type, name: name, num: num},
		
		IdentifierName =
			:identifierName
			GetResourceName(identifierName):resourceName
			(	?(!this.tables.hasOwnProperty(resourceName))
			|	{console.error('We already have an identifier with a name of: ' + identifierName)} ?(false)
			)
			{this.identifiers[identifierName] = identifierName}
			{this.tables[resourceName] = {fields:[], primitive: false, name: null, idField: null}}
			-> identifierName,
		Attributes :tableID =
				end
			|	[	'Attributes'
					(	[	:attributeName ApplyFirstExisting(['Attr' + attributeName, 'DefaultAttr'], [tableID]):attributeValue
						]
					)*
				],
		DefaultAttr :tableID =
			:anything
			{console.log('Default', tableID, anything)},
		AttrConceptType :identifierName = // tableID will be same as identifierName for ConceptType (fact types cannot have a concept type)
			['Term' :conceptType] {this.conceptTypes[identifierName] = conceptType}
			IsPrimitive(conceptType):primitive
			GetTable(conceptType):conceptTable
			GetTable(identifierName):identifierTable
			(	?(primitive !== false && conceptType === primitive)
				{primitive}:dataType
				// If the concept type is primitive then we use that as the "value" field and delete the current.
				(	?(identifierTable.hasOwnProperty('valueField'))
					GetTableFieldID(identifierTable, identifierTable.valueField):fieldID
					?(fieldID !== false)
					{identifierTable.fields.splice(fieldID, 1)}
				)?
				{identifierTable.valueField = conceptType}
			|	{'ConceptType'}:dataType
			)
			AddTableField(identifierTable, conceptType, dataType, true, null, conceptTable.idField),
		AttrDatabaseIDField :tableID =
			:idField
			GetTable(tableID):table
			(	?_.isString(table)
			|	(	AddTableField(table, idField, 'Serial', true, 'PRIMARY KEY'):fieldID
					(	?(fieldID !== false)
						// If the field already exists then update it instead.
						{table.fields[fieldID][3] = 'PRIMARY KEY'}
						?(table.fields[fieldID][0] == 'Value')
						// DIRTY HACK: If the data type is Value then change to Serial (the value field stuff needs to be done properly)
						{table.fields[fieldID][0] = 'Serial'}
					)?
				)
				{table.idField = idField}
			),
		AttrDatabaseValueField :tableID =
			:valueField
			GetTable(tableID):table
			(	?_.isString(table)
			|	// Find existing name field and update it if it exists.
				(	?(table.hasOwnProperty('valueField'))
					GetTableFieldID(table, table.valueField):fieldID
					?(fieldID !== false)
					{table.fields[fieldID][1] = valueField}
				|	// Otherwise add it
					AddTableField(table, valueField, 'Value', true)
				)
				{table.valueField = valueField}
			),
		AttrDatabaseTableName :tableID =
			:tableName
			GetTable(tableID):table
			(	?_.isString(table)
			|	{table.name = tableName}
			),
		AttrDatabasePrimitive :termName =
			:attrVal
			{this.GetTable(termName).primitive = attrVal},
		AttrDatabaseAttribute :factType =
			:attrVal
			(	?attrVal
				{this.attributes[factType] = attrVal}
				{this.tables[this.GetResourceName(factType)] = 'Attribute'}
				GetTable(factType[0][1]):baseTable
				{factType[2][1]}:attributeName
				GetTable(attributeName):attributeTable
				GetTableFieldID(baseTable, attributeName):fieldID
				{baseTable.fields[fieldID][0] = attributeTable.primitive}
			)?,
		AttrForeignKey :factType =
			:required
			GetTable(factType[0][1]):baseTable
			{factType[2][1]}:fkName
			GetTable(fkName):fkTable
			(	?(baseTable.valueField == fkName
					|| baseTable.idField == fkName)
				// If the foreign key matches the value or id fields then delete the current field before adding the new.
				GetTableFieldID(baseTable, fkName):fieldID
				?(fieldID !== false)
				{baseTable.fields.splice(fieldID, 1)}
			)?
			AddTableField(baseTable, fkName, 'ForeignKey', required, null, [fkTable.name, fkTable.idField])
			{this.tables[this.GetResourceName(factType)] = 'ForeignKey'},
		AttrUnique :factType =
			:required
			GetTable(factType):baseTable
			(	?(baseTable === 'Attribute' || baseTable === 'ForeignKey')
				GetTable(factType[0][1]):baseTable
			)?
			{factType[2][1]}:uniqueField
			GetTableFieldID(baseTable, uniqueField):fieldID
			?(fieldID !== false)
			{baseTable.fields[fieldID][3] = 'UNIQUE'},
		// AttrSynonym :term =
			// :synonym {this.identifiers[synonym[1]] = term[1]},
		AttrSynonymousForm :factType =
			:synForm
			AddFactType(synForm, factType),
		AttrTermForm :factType =
			:term
			{this.identifiers[term[1]] = factType}
			{this.tables[this.GetResourceName(term[1])] = this.GetTable(factType)},
		AttrNecessity :tableID =
			{this.linkTableBind = 0}
			{this.bindTerms = []}
			[	&ProcessAtomicFormulations
				RulePart:ruleBody
				[	'StructuredEnglish'
					:ruleText
				]
			]
			{this.rules.push(['Rule', ['StructuredEnglish', ruleText], ['Body', ruleBody]])}
			-> ruleBody,
		
		/** Fact Types **/
		FactType =
			&((:factTypePart &(:attributes) -> factTypePart)+:factType)
			(	?(this.nativePrimitives.hasOwnProperty(factType[0][1]))
				// Eat input
				(:factTypePart &(:attributes))+
			|	AddFactType(factType, factType)
				GetResourceName(factType):resourceName
				(	?(factType.length == 2)
					// Eat input
					(:factTypePart &(:attributes))+
					GetTable(factType[0][1]):identifierTable
					AddTableField(identifierTable, factType[1][1], 'Boolean', true)
					{this.tables[resourceName] = 'BooleanAttribute'}
				|	{this.tables[resourceName] = {fields:[], primitive: false, name: null}}:linkTable
					(	Identifier:identifier
						GetTable(identifier.name):fkTable
						AddTableField(linkTable, identifier.name + identifier.num, 'ForeignKey', true, '', [fkTable.name, fkTable.idField])
					|	['Verb' :verb]
					)+
				)
			)
			-> factType,
		
		Cardinality =
			[
				(	'MinimumCardinality'
				|	'MaximumCardinality'
				|	'Cardinality'
				)
				Number:cardinality
			]
			-> cardinality,

		Variable =
			[	'Variable'
				Number:bind
				Identifier:baseTerm
				(	// Replace this bind if it's an attribute binding.
					{this.bindTerms[bind]}:termNames
					?(termNames)
					-> termNames
				|	-> [baseTerm.name]
				):termNames
				{'var' + bind}:varAlias
				{termNames[0]}:termName
				{termNames.slice(1)}:termNames
				{['SelectQuery', ['Select', []], ['From', this.GetTable(termName).name, varAlias + termName]]}:query
				{	this.ResolveConceptTypes(query, termName, varAlias)
					if(termNames.length > 0) {
						var attributeName = baseTerm.name;
						for(var i=0; i < termNames.length; i++) {
							var extraTermName = termNames[i],
								extraTable = this.GetTable(extraTermName);
							query.push(['From', extraTable.name, varAlias + extraTermName]);
							this.AddWhereClause(query, ['Equals', ['ReferencedField', varAlias + termName, attributeName], ['ReferencedField', varAlias + extraTermName, attributeName]]);
							this.ResolveConceptTypes(query, extraTermName, varAlias)
						}
					}
				}
				(	RulePart:whereBody
					AddWhereClause(query, whereBody)
				)?
			]
			(	RulePart:whereBody
				AddWhereClause(query, whereBody)
			)
			-> query,
		
		RoleBinding =
			[	'RoleBinding'
				Identifier:identifier
				(	number:number
				|	Integer:data
				|	Text:data
				)
			]
			-> {identifier: identifier, number:number, data: data},

		NativeFactType :actualFactType :rootTerms :factType =
			?(actualFactType.length == 3)
			?(this.nativePrimitives.hasOwnProperty(actualFactType[0][1]))
			?(this.nativePrimitives.hasOwnProperty(actualFactType[2][1]))
			(	RoleBinding:bindFrom
				RoleBinding:bindTo
				end
			|	___NativeFactTypeMatchingFailed___.die
			)
			(	?bindFrom.data
				-> bindFrom.data
			|	{bindFrom.identifier.name}:bindFromField
				(	?(this.bindTerms[bindFrom.number])
					-> this.bindTerms[bindFrom.number][0]
				|	-> bindFromField
				):bindFromName
				-> ['ReferencedField', 'var' + bindFrom.number + bindFromName, bindFromField]
			):from
			(	?bindTo.data
				-> bindTo.data
			|	{bindTo.identifier.name}:bindToField
				(	?(this.bindTerms[bindTo.number])
					-> this.bindTerms[bindTo.number][0]
				|	-> bindToField
				):bindToName
				-> ['ReferencedField', 'var' + bindTo.number + bindToName, bindToField]
			):to
			{factType[1][1].toLowerCase()}:verb
			(	?(verb == 'is equal to' || verb == 'equals')
				-> 'Equals'
			|	?(verb == 'is greater than')
				-> 'GreaterThan'
			|	?(verb == 'is greater than or equal to')
				-> 'GreaterThanOrEqual'
			|	?(verb == 'is less than')
				-> 'LessThan'
			|	?(verb == 'is less than or equal to')
				-> 'LessThanOrEqual'
			):comparator
			-> [comparator, from, to],

		LinkTable :actualFactType :rootTerms =
			{'link' + this.linkTableBind++}:tableAlias
			{['SelectQuery', ['Select', []], ['From', this.GetTable(actualFactType).name, tableAlias]]}:query
			{0}:i
			(	?(i < rootTerms.length)
				RoleBinding:bind
				{rootTerms[i].term}:termName
				GetTable(termName):table
				AddWhereClause(query, ['Equals', ['ReferencedField', tableAlias, rootTerms[i].field], ['ReferencedField', 'var' + bind.number + termName, table.idField]])
				{i++}
			)+
			-> ['Exists', query],
		
		ForeignKey :actualFactType :rootTerms =
			?(this.GetTable(actualFactType) == 'ForeignKey')
			(	RoleBinding:bindFrom
				RoleBinding:bindTo
				end
				(	?this.IsChild(bindFrom.identifier.name, actualFactType[0])
					{rootTerms[0]}:fkFrom
					{rootTerms[1]}:fkTo
				|	{bindTo}:temp
					{bindFrom}:bindTo
					{temp}:bindFrom
					{rootTerms[1]}:fkFrom
					{rootTerms[0]}:fkTo
				)
				GetTable(fkTo.term):tableTo
			|	___ForeignKeyMatchingFailed___.die
			)
			(	?(bindTo.identifier.type == 'Name')
				{bindTo.identifier.name}:name
				GetTable(name):nameTable
				{'name-' + name + '-'}:varAlias
				{['SelectQuery', ['Select', [[['ReferencedField', varAlias + fkTo.term, tableTo.idField]]]], ['From', nameTable.name, varAlias + name]]}:query
				ResolveConceptTypes(query, name, varAlias, fkTo.term)
				-> query
			|	-> ['ReferencedField', 'var' + bindTo.number + fkTo.term, tableTo.idField]
			):toField
			-> ['Equals', ['ReferencedField', 'var' + bindFrom.number + fkFrom.term, fkTo.field], toField],

		BooleanAttribute :actualFactType =
			?(this.GetTable(actualFactType) == 'BooleanAttribute')
			(	RoleBinding:bindFrom
				end
				{actualFactType[0][1]}:termFrom
				{actualFactType[1][1]}:attributeName
			|	{console.error(this.input)}
				___BooleanAttributeMatchingFailed___.die
			)
			-> ['Equals', ['ReferencedField', 'var' + bindFrom.number + termFrom, attributeName], ['Boolean', true]],

		Attribute :actualFactType :rootTerms =
			?(this.GetTable(actualFactType) == 'Attribute')
			{['SelectQuery', ['Select', []]]}:query
			(	RoleBinding:bindReal
				RoleBinding:bindAttr
				end
				(	?this.IsChild(bindReal.identifier.name, actualFactType[0])
					{rootTerms[0].term}:termNameReal
					{rootTerms[1].field}:attrField
				|	{bindAttr}:temp
					{bindReal}:bindAttr
					{temp}:bindReal
					{rootTerms[1].term}:termNameReal
					{rootTerms[0].field}:attrField
				)
				|	___AttributeMatchingFailed___.die
			)
			AddWhereClause(query, ['Equals', ['ReferencedField', 'var' + bindAttr.number + termNameReal, attrField], ['ReferencedField', 'var' + bindReal.number + termNameReal, attrField]])
			-> ['Exists', query],
		
		AtomicFormulation =
			[	'AtomicFormulation'
				[	'FactType'
					anything+:factType
				]
				ActualFactType(factType):actualFactType
				FactTypeRootTerms(factType):rootTerms
				(	NativeFactType(actualFactType, rootTerms, factType)
				|	ForeignKey(actualFactType, rootTerms)
				|	BooleanAttribute(actualFactType)
				|	Attribute(actualFactType, rootTerms)
				|	LinkTable(actualFactType, rootTerms)
				):whereClause
			]
			-> whereClause,
		AtLeast =
			[	'AtLeastNQuantification'
				Cardinality:minCard
				Variable:query
				{query[1][1].push(['Count', '*'])}
			]
			-> ['GreaterThanOrEqual', query, ['Number', minCard]],
		Exactly =
			[	'ExactQuantification'
				Cardinality:card
				Variable:query
				{query[1][1].push(['Count', '*'])}
			]
			-> ['Equals', query, ['Number', card]],
		Range =
			[	'NumericalRangeQuantification'
				Cardinality:minCard
				Cardinality:maxCard
				Variable:query
				{query[1][1].push(['Count', '*'])}
			]
			-> ['Between', query, ['Number', minCard], ['Number', maxCard]],
		Exists =
			[	'ExistentialQuantification'
				Variable:query
			]
			-> ['Exists', query],
		Negation =
			[	'LogicalNegation'
				RulePart:whereBody
			]
			-> ['Not', whereBody],
			
		
		RulePart =
			(	AtomicFormulation
			|	AtLeast
			|	Exactly
			|	Exists
			|	Negation
			|	Range
			|	:x {console.error('Hit unhandled operation:', x)} ?(false)
			):whereBody
			-> whereBody,
		
		RuleBody =
			[
				(	'ObligationFormulation'
				|	'NecessityFormulation'
				|	'PossibilityFormulation'
				|	'PermissibilityFormulation'
				)
				RulePart:rule
			]
			-> rule,
		
		ProcessAtomicFormulations =
			(	// Bit of a hack, but we only want to drill into the input if it's an array, otherwise we get infinite recursion.
				?(_.isArray(this.input.lst))
				[	'AtomicFormulation'
					[	'FactType'
						anything+:factType
					]
					ActualFactType(factType):actualFactType
					?(this.attributes.hasOwnProperty(actualFactType) && this.attributes[actualFactType])
					{null}:tableTerm
					{	for(var i=0; i < actualFactType.length; i+=2) {
							if(!(this.GetTable(actualFactType[i][1]).primitive)) {
								tableTerm = actualFactType[i][1];
								break;
							}
						}
					}
					(	RoleBinding:bind
						(	?(this.GetTable(bind.identifier.name).primitive)
							{(this.bindTerms[bind.number] = this.bindTerms[bind.number] || []).push(tableTerm)}
						)?
					)*
				|	ProcessAtomicFormulations
				]
			|	anything
			)*,
		
		Process =
			[	'Model'
				(	[	(	'Term'
						|	'Name'
						)
						 IdentifierName:identifierName
						 Attributes(identifierName)
					|	'FactType' FactType:factType Attributes(factType)
					|	'Rule'
						{this.linkTableBind = 0}
						{this.bindTerms = []}
						&ProcessAtomicFormulations
						RuleBody:ruleBody
						[	'StructuredEnglish'
							:ruleText
						]
						{this.rules.push(['Rule', ['StructuredEnglish', ruleText], ['Body', ruleBody]])}
					]
				)+
			]
			{{}}:tables
			-> {tables:this.tables, rules:this.rules}
	}
	
	LF2AbstractSQL.AddTableField = function(table, fieldName, dataType, required, index, references) {
		var fieldID = this.GetTableFieldID(table, fieldName);
		if(fieldID === false) {
			table.fields.push([dataType, fieldName, required, index, references]);
		}
		return fieldID;
	}
	
	LF2AbstractSQL.AddWhereClause = function(query, whereBody) {
		// TODO: Move this to an optimisation pass?
		// Check if it's a place where we can do a join optimisation.
		if(whereBody[0] == 'Exists' && (
				whereBody[1][0] == 'SelectQuery' || whereBody[1][0] == 'InsertQuery' ||
				whereBody[1][0] == 'UpdateQuery' || whereBody[1][0] == 'UpsertQuery')) {
			whereBody = whereBody[1].slice(1);
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'From') {
					query.push(whereBody[i]);
				}
			}
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'Where') {
					this.AddWhereClause(query, whereBody[i][1]);
				}
			}
		}
		else {
			for(var i=1; i < query.length; i++) {
				if(query[i][0] == 'Where') {
					query[i][1] = ['And', query[i][1], whereBody];
					return;
				}
			}
			query.push(['Where', whereBody]);
		}
	};
	
	LF2AbstractSQL.ResolveConceptTypes = function(query, termName, varAlias, untilConcept) {
		var conceptAlias,
			parentAlias = varAlias + termName,
			conceptName = termName,
			conceptTable;
		while(conceptName != untilConcept && this.conceptTypes.hasOwnProperty(conceptName)) {
			conceptName = this.conceptTypes[conceptName];
			conceptAlias = varAlias + conceptName;
			conceptTable = this.GetTable(conceptName);
			if(conceptTable.primitive !== false) {
				break;
			}
			query.push(['From', conceptTable.name, conceptAlias]);
			this.AddWhereClause(query, ['Equals', ['ReferencedField', parentAlias, conceptName], ['ReferencedField', conceptAlias, conceptTable.idField]]);
			parentAlias = conceptAlias;
		}
	};
	
	LF2AbstractSQL.initialize = function() {
		SBVRLibs.initialize.call(this);
		this.tables = {};
		this.identifiers = {}; // TODO: Is this needed?
		this.rules = [];
		this.linkTableBind = 0;
		this.attributes = {};
		this.bindTerms = [];
	};

	
	return LF2AbstractSQL;
});
