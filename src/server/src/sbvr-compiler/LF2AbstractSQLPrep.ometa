define([
	'ometa!sbvr-compiler/LFOptimiser'
], function(LFOptimiser) {
	ometa LF2AbstractSQLPrep <: LFOptimiser {
		AttrConceptType :termName =
			^AttrConceptType(termName):conceptType
			(	?(this.primitives[termName] === false && this.primitives[conceptType] !== false)
				{this.primitives[conceptType] = false}
				SetHelped
			)?
			-> conceptType,
		AttrDatabaseAttribute :termOrFactType =
			:attrVal
			{	(termOrFactType[0] == 'Term' && (!this.attributes.hasOwnProperty(termOrFactType[3]) || this.attributes[termOrFactType[3]] === true))
				|| (termOrFactType[0] == 'FactType' && termOrFactType.length == 4
					&& (!this.attributes.hasOwnProperty(termOrFactType[3]) || this.attributes[termOrFactType[3]] === true)
					&& this.primitives.hasOwnProperty(termOrFactType[3]) && this.primitives[termOrFactType[3]] !== false)
			}:newAttrVal
			{this.attributes[termOrFactType] = newAttrVal}
			(	?(newAttrVal != attrVal)
				// {console.log('Changing DatabaseAttribute attr to:', newAttrVal, termOrFactType)}
				SetHelped
			)?
			-> newAttrVal,
		AttrDatabasePrimitive :termOrFactType =
			:attrVal
			{attrVal}:newAttrVal
			(	?(this.primitives.hasOwnProperty(termOrFactType))
				{this.primitives[termOrFactType]}:newAttrVal
				?(newAttrVal != attrVal)
				// {console.log('Changing DatabasePrimitive attr to:', newAttrVal, termOrFactType)}
				SetHelped
			)?
			{this.primitives[termOrFactType] = newAttrVal}
			-> newAttrVal,
		
		UniversalQuantification
			"Variable":v trans*:xs SetHelped
			-> ['LogicalNegation', ['ExistentialQuantification', v, ['LogicalNegation'].concat(xs)]],
		
		AtMostNQuantification
			"MaximumCardinality":maxCard "Variable":v trans*:xs SetHelped
			{maxCard[1][1]++}
			-> ['LogicalNegation', ['AtLeastNQuantification', ['MinimumCardinality', maxCard[1]], v].concat(xs)],
		
		CardinalityOptimisation2 :v1 =
			// Just a basic var
			?(v1.length == 3)
			(	[	'ExactQuantification'
					"Cardinality":card
					?(card[1][1] == 1)
					"Variable":v2
					// Just a basic var
					?(v2.length == 3)
					"AtomicFormulation":atomicForm
					{true}:required
				]
			|	[	'AtMostNQuantification'
					"MaximumCardinality":card
					?(card[1][1] == 1)
					"Variable":v2
					// Just a basic var
					?(v2.length == 3)
					"AtomicFormulation":atomicForm
					{false}:required
				]
			)
			end
			{atomicForm[1]}:factType
			// A term verb term fact type
			?(atomicForm.length == 4 && factType.length == 4)
			ActualFactType(factType.slice(1)):actualFactType
			{['FactType'].concat(actualFactType)}:actualFactType
			(	// In the same order as the vars appear.
				?(v1[2][1] == actualFactType[1][1] && v2[2][1] == actualFactType[3][1])
				{this.foreignKeys[actualFactType] = required}
			|	// In reverse order
				?(v1[2][1] == actualFactType[3][1] && v2[2][1] == actualFactType[1][1])
				{this.uniqueKeys[actualFactType] = required}
			)
			// We have matched a foreign key or unique, so call SetHelped.
			SetHelped,
		
		CardinalityOptimisation
			[	'UniversalQuantification'
				"Variable":v1
				// A basic var, no ClosedProjection.
				?(v1.length == 3)
				CardinalityOptimisation2(v1)
			|	'LogicalNegation'
				[	'ExistentialQuantification'
					"Variable":v1
					[	'LogicalNegation'
						CardinalityOptimisation2(v1)
					]
				]
			],
		
		NecessityOptimisation =
			CardinalityOptimisation,
		ObligationOptimisation =
			CardinalityOptimisation,
		
		Rule
			(	[	'ObligationFormulation'
					ObligationOptimisation
				|	'NecessityFormulation'
					NecessityOptimisation
				]
				"StructuredEnglish"
				// We have matched a foreign key, return an empty array to remove the rule.
				-> null
			|	^Rule
			)
	}
	
	LF2AbstractSQLPrep.initialize = function() {
		LFOptimiser.initialize.call(this);
		this.foreignKeys = {};
		this.uniqueKeys = {};
		this.primitives = {};
		this.attributes = {};
	};
	
	LF2AbstractSQLPrep.defaultAttributes = function(termOrFactType, attrsFound, attrs) {
		// We don't add a DatabaseIDField to a native primitive or vocabulary.
		if(termOrFactType[0] != 'Vocabulary'
			&& !this.nativePrimitives.hasOwnProperty(termOrFactType[1][1])
			&& !attrsFound.hasOwnProperty('DatabaseIDField')) {
			attrs.splice(1, 0, ['DatabaseIDField', 'id']);
			this.SetHelped();
		}
		switch(termOrFactType[0]) {
			case 'Name':
			case 'Term':
				if(!attrsFound.hasOwnProperty('DatabaseValueField')) {
					attrs.splice(1, 0, ['DatabaseValueField', 'value']);
					this.SetHelped();
				}
				if(!attrsFound.hasOwnProperty('DatabaseTableName')) {
					attrs.splice(1, 0, ['DatabaseTableName', termOrFactType[1].replace(new RegExp(' ','g'),'_')]);
					this.SetHelped();
				}
				if(!attrsFound.hasOwnProperty('DatabasePrimitive')) {
					if(!this.primitives.hasOwnProperty(termOrFactType)) {
						this.primitives[termOrFactType] = this.IsPrimitive(termOrFactType);
					}
					// console.log('Adding primitive attr', this.primitives[termOrFactType], termOrFactType);
					attrs.splice(1, 0, ['DatabasePrimitive', this.primitives[termOrFactType]]);
					this.SetHelped();
				}
			break;
			case 'FactType':
				// We don't add extra attributes to a fact type starting with a native primitive.
				if(!this.nativePrimitives.hasOwnProperty(termOrFactType[1][1])) {
					if(!attrsFound.hasOwnProperty('DatabaseTableName')) {
						var tableName = termOrFactType[1][1].replace(new RegExp(' ','g'),'_');
						for(var i=2;i<termOrFactType.length;i++) {
							tableName += '-' + termOrFactType[i][1].replace(new RegExp(' ','g'),'_');
						}
						attrs.splice(1, 0, ['DatabaseTableName', tableName]);
						this.SetHelped();
					}
					if(this.uniqueKeys.hasOwnProperty(termOrFactType)) {
						if(!attrsFound.hasOwnProperty('Unique')) {
							attrs.splice(1, 0, ['Unique', this.uniqueKeys[termOrFactType]]);
							this.SetHelped();
						}
						else if(attrsFound['Unique'] != this.uniqueKeys[termOrFactType]) {
							console.error(attrsFound['Unique'], this.uniqueKeys[termOrFactType]);
							___MISMATCHED_UNIQUE_KEY___.die();
						}
					}
					if(this.foreignKeys.hasOwnProperty(termOrFactType)) {
						if(!attrsFound.hasOwnProperty('DatabaseAttribute')) {
							attrs.splice(1, 0, ['DatabaseAttribute', false]);
							this.SetHelped();
						}
						if(!attrsFound.hasOwnProperty('ForeignKey')) {
							// console.log('Adding FK attr', this.foreignKeys[termOrFactType], termOrFactType);
							attrs.splice(1, 0, ['ForeignKey', this.foreignKeys[termOrFactType]]);
							this.SetHelped();
						}
						else if(attrsFound['ForeignKey'] != this.foreignKeys[termOrFactType]) {
							console.error(attrsFound['ForeignKey'], this.foreignKeys[termOrFactType]);
							___MISMATCHED_FOREIGN_KEY___.die();
						}
					}
					
					// Boolean fact type
					if(termOrFactType.length == 3) {
						if(!this.primitives.hasOwnProperty(termOrFactType[1]) || this.primitives[termOrFactType[1]] !== false) {
							this.SetHelped();
						}
						// The term of a boolean fact type cannot be a primitive.
						this.primitives[termOrFactType[1]] = false;
					} // Tertiary or higher fact type
					else if(termOrFactType.length > 4) {
						// The terms in a tertiary or higher fact type cannot become attributes.
						for(var i = 1;i < termOrFactType.length; i+=2) {
							if(!this.attributes.hasOwnProperty(termOrFactType[i]) || this.attributes[termOrFactType[i]] !== false) {
								this.SetHelped();
							}
							this.attributes[termOrFactType[i]] = false;
						}
					}
				}
			break;
		}
		termOrFactType.push(attrs);
	};
	return LF2AbstractSQLPrep;
});
