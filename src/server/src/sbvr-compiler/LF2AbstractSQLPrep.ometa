define([
	'ometa!sbvr-compiler/LFOptimiser'
], function(LFOptimiser) {
	ometa LF2AbstractSQLPrep <: LFOptimiser {
		AttrConceptType :termName =
			^AttrConceptType(termName):conceptType
			(	?(this.primitives[termName] === false && this.primitives[conceptType] !== false)
				{this.primitives[conceptType] = false}
				SetHelped
			)?
			-> conceptType,
		AttrDatabaseAttribute :termOrFactType =
			:attrVal
			{	(termOrFactType[0] == 'Term' && (!this.attributes.hasOwnProperty(termOrFactType[3]) || this.attributes[termOrFactType[3]] === true))
				|| (termOrFactType[0] == 'FactType' && termOrFactType.length == 4
					&& (!this.attributes.hasOwnProperty(termOrFactType[3]) || this.attributes[termOrFactType[3]] === true)
					&& this.primitives.hasOwnProperty(termOrFactType[3]) && this.primitives[termOrFactType[3]] !== false)
			}:newAttrVal
			{this.attributes[termOrFactType] = newAttrVal}
			(	?(newAttrVal != attrVal)
				// {console.log('Changing DatabaseAttribute attr to:', newAttrVal, termOrFactType)}
				SetHelped
			)?
			-> newAttrVal,
		AttrDatabasePrimitive :termOrFactType =
			:attrVal
			{attrVal}:newAttrVal
			(	?(this.primitives.hasOwnProperty(termOrFactType))
				{this.primitives[termOrFactType]}:newAttrVal
				?(newAttrVal != attrVal)
				// {console.log('Changing DatabasePrimitive attr to:', newAttrVal, termOrFactType)}
				SetHelped
			)?
			{this.primitives[termOrFactType] = newAttrVal}
			-> newAttrVal,
		AttrNecessity :termOrFactType =
				NecessityOptimisation
				-> null
			|	DefaultAttr,
		
		UniversalQuantification
			"Variable":v trans*:xs SetHelped
			-> ['LogicalNegation', ['ExistentialQuantification', v, ['LogicalNegation'].concat(xs)]],
		
		AtMostNQuantification
			"MaximumCardinality":maxCard "Variable":v trans*:xs SetHelped
			{maxCard[1][1]++}
			-> ['LogicalNegation', ['AtLeastNQuantification', ['MinimumCardinality', maxCard[1]], v].concat(xs)],
		
		ForeignKeyOptimisation2 :v1 =
			// Just a basic var
			?(v1.length == 3)
			(	[	'ExactQuantification'
					"Cardinality":card
					?(card[1][1] == 1)
					"Variable":v2
					// Just a basic var
					?(v2.length == 3)
					"AtomicFormulation":atomicForm
					{true}:required
				]
			|	[	'AtMostNQuantification'
					"MaximumCardinality":card
					?(card[1][1] == 1)
					"Variable":v2
					// Just a basic var
					?(v2.length == 3)
					"AtomicFormulation":atomicForm
					{false}:required
				]
			)
			{atomicForm[1]}:factType
			// A term verb term fact type
			?(atomicForm.length == 4 && factType.length == 4)
			ActualFactType(factType.slice(1)):actualFactType
			{['FactType'].concat(actualFactType)}:actualFactType
			(	// In the same order as the vars appear.
				?(v1[2][1] == actualFactType[1][1] && v2[2][1] == actualFactType[3][1])
				{this.foreignKeys[actualFactType] = required}
			|	// In reverse order
				?(v1[2][1] == actualFactType[3][1] && v2[2][1] == actualFactType[1][1])
				{this.uniqueKeys[actualFactType] = required}
			)
			// We have matched a foreign key or unique, so call SetHelped.
			SetHelped,
		
		ForeignKeyOptimisation
			[	'UniversalQuantification'
				"Variable":v1
				ForeignKeyOptimisation2(v1)
			|	'LogicalNegation'
				[	'ExistentialQuantification'
					"Variable":v1
					[	'LogicalNegation'
						ForeignKeyOptimisation2(v1)
					]
				]
			],
		
		NecessityOptimisation =
			ForeignKeyOptimisation,
		ObligationOptimisation =
			ForeignKeyOptimisation,
		
		Rule
			(	[	'ObligationFormulation'
					ObligationOptimisation
				|	'NecessityFormulation'
					NecessityOptimisation
				]
				"StructuredEnglish"
				// We have matched a foreign key, return an empty array to remove the rule.
				-> null
			|	^Rule
			)
	}
	
	LF2AbstractSQLPrep.initialize = function() {
		LFOptimiser.initialize.call(this);
		this.foreignKeys = {};
		this.uniqueKeys = {};
		this.primitives = {};
		this.attributes = {};
	};
	
	LF2AbstractSQLPrep.defaultAttributes = function(termOrVerb, attrsFound, attrs) {
		if(!attrsFound.hasOwnProperty('DatabaseIDField')) {
			attrs.push(['DatabaseIDField', 'id']);
			this.SetHelped();
		}
		switch(termOrVerb[0]) {
			case 'Term':
				if(!attrsFound.hasOwnProperty('DatabaseValueField')) {
					attrs.push(['DatabaseValueField', 'value']);
					this.SetHelped();
				}
				if(!attrsFound.hasOwnProperty('DatabaseTableName')) {
					attrs.push(['DatabaseTableName', termOrVerb[1].replace(new RegExp(' ','g'),'_')]);
					this.SetHelped();
				}
				if(!attrsFound.hasOwnProperty('DatabasePrimitive')) {
					if(!this.primitives.hasOwnProperty(termOrVerb)) {
						this.primitives[termOrVerb] = this.IsPrimitive(termOrVerb[1]);
					}
					// console.log('Adding primitive attr', this.primitives[termOrVerb], termOrVerb);
					attrs.push(['DatabasePrimitive', this.primitives[termOrVerb]]);
					this.SetHelped();
				}
			break;
			case 'FactType':
				if(!attrsFound.hasOwnProperty('DatabaseTableName')) {
					var tableName = termOrVerb[1][1].replace(new RegExp(' ','g'),'_');
					for(var i=2;i<termOrVerb.length;i++) {
						tableName += '-' + termOrVerb[i][1].replace(new RegExp(' ','g'),'_');
					}
					attrs.push(['DatabaseTableName', tableName]);
					this.SetHelped();
				}
				if(this.foreignKeys.hasOwnProperty(termOrVerb)) {
					if(!attrsFound.hasOwnProperty('ForeignKey')) {
						// console.log('Adding FK attr', this.foreignKeys[termOrVerb], termOrVerb);
						attrs.push(['ForeignKey', this.foreignKeys[termOrVerb]]);
						this.SetHelped();
					}
					else if(attrsFound['ForeignKey'] != this.foreignKeys[termOrVerb]) {
						console.error(attrsFound['ForeignKey'], this.foreignKeys[termOrVerb]);
						___MISMATCHED_FOREIGN_KEY___.die();
					}
					if(!attrsFound.hasOwnProperty('DatabaseAttribute')) {
						attrs.push(['DatabaseAttribute', false]);
						this.SetHelped();
					}
				}
				if(this.uniqueKeys.hasOwnProperty(termOrVerb)) {
					if(!attrsFound.hasOwnProperty('Unique')) {
						attrs.push(['Unique', this.uniqueKeys[termOrVerb]]);
						this.SetHelped();
					}
					else if(attrsFound['Unique'] != this.uniqueKeys[termOrVerb]) {
						console.error(attrsFound['Unique'], this.uniqueKeys[termOrVerb]);
						___MISMATCHED_UNIQUE_KEY___.die();
					}
				}
				
				// Boolean fact type
				if(termOrVerb.length == 3) {
					if(!this.primitives.hasOwnProperty(termOrVerb[1]) || this.primitives[termOrVerb[1]] !== false) {
						this.SetHelped();
					}
					// The term of a boolean fact type cannot be a primitive.
					this.primitives[termOrVerb[1]] = false;
				} // Tertiary or higher fact type
				else if(termOrVerb.length > 4) {
					// The terms in a tertiary or higher fact type cannot become attributes.
					for(var i = 1;i < termOrVerb.length; i+=2) {
						if(!this.attributes.hasOwnProperty(termOrVerb[i]) || this.attributes[termOrVerb[i]] !== false) {
							this.SetHelped();
						}
						this.attributes[termOrVerb[i]] = false;
					}
				}
			break;
		}
		termOrVerb.push(attrs);
	};
	return LF2AbstractSQLPrep;
});
