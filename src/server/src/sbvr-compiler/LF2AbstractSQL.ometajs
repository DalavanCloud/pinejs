define([
	'ometa!sbvr-compiler/sbvr-compiler-libs',
	'lodash',
	'cs!sbvr-compiler/types'
], function(SBVRCompilerLibs, _, sbvrTypes) {
	//Transformation from SBVR Logical Formulation to SQL

	ometa LF2AbstractSQL <: SBVRCompilerLibs {
		Number =
			[	'Number'
				number:num
				?{!isNaN(num)}
			]
			-> num,

		Real =
			[	'Real'
				number:num
				?{!isNaN(num)}
			]
			-> ['Real', num],

		Integer =
			[	'Integer'
				number:num
				?{!isNaN(num)}
			]
			-> ['Integer', num],

		Text =
			[	'Text'
				anything:text
			]
			-> ['Text', text],
			
		Value =
				Real
			|	Integer
			|	Text,
		
		/** Terms **/
		Identifier =
			{''}:num
			[	(	'Term'
				|	'Name'
				):type
				:name
				:vocab
				(	// Var number
					Number:num
				|	// Or embedded data, which we ignore the embedded data as it is retreived from the binding instead
					Value
				)?
			]
			-> {type: type, name: name, num: num, vocab: vocab},
		
		IdentifierName =
			:identifierName
			GetResourceName(identifierName):resourceName
			(	?(!this.tables.hasOwnProperty(resourceName))
			|	{console.error('We already have an identifier with a name of: ' + identifierName)} ?(false)
			)
			{this.identifiers[identifierName] = identifierName}
			{this.tables[resourceName] = {fields: [], primitive: false, name: null, idField: null}}
			-> identifierName,
		Attributes :termOrFactType =
				end
			|	[	'Attributes'
					(	[	:attributeName ApplyFirstExisting(['Attr' + attributeName, 'DefaultAttr'], [termOrFactType]):attributeValue
						]
					)*
				],
		DefaultAttr :termOrFactType =
			:anything
			{console.log('Default', termOrFactType, anything)},
		AttrConceptType :termOrFactType =
			[	'Term'
				:conceptType
				:vocab
			]:term
			{this.vocabularies[termOrFactType[2]]['ConceptTypes'][termOrFactType] = term}

			IsPrimitive(term):primitive
			GetTable(conceptType):conceptTable
			GetTable(termOrFactType[1]):identifierTable
			(	?(primitive !== false && conceptType === primitive)
				{primitive}:dataType
				// If the concept type is primitive then we use that as the "value" field and delete the current.
				(	?(identifierTable.hasOwnProperty('referenceScheme'))
					GetTableFieldID(identifierTable, identifierTable.referenceScheme):fieldID
					?(fieldID !== false)
					{identifierTable.fields.splice(fieldID, 1)}
				)?
				{identifierTable.referenceScheme = conceptType}
			|	{'ConceptType'}:dataType
			)
			AddTableField(identifierTable, conceptType, dataType, true, null, conceptTable.idField),
		AttrDatabaseIDField :termOrFactType =
			:idField
			GetTableID(termOrFactType):tableID
			GetTable(tableID):table
			(	?_.isString(table)
			|	(	AddTableField(table, idField, 'Serial', true, 'PRIMARY KEY'):fieldID
					(	?(fieldID !== false)
						// If the field already exists then update it instead.
						{table.fields[fieldID].index = 'PRIMARY KEY'}
					)?
				)
				{table.idField = idField}
			),
		AttrReferenceScheme :termOrFactType =
			:referenceScheme
			(	?_.isArray(referenceScheme)
				-> referenceScheme[1]
			|	-> referenceScheme
			):referenceScheme
			GetTableID(termOrFactType):tableID
			GetTable(tableID):table
			(	?_.isString(table)
			|	// Find existing name field and update it if it exists.
				(	?(table.hasOwnProperty('referenceScheme'))
					GetTableFieldID(table, table.referenceScheme):fieldID
					?(fieldID !== false)
					{table.fields[fieldID].fieldName = referenceScheme}
				)?
				{table.referenceScheme = referenceScheme}
			),
		AttrDatabaseTableName :termOrFactType =
			:tableName
			GetTableID(termOrFactType):tableID
			GetTable(tableID):table
			(	?_.isString(table)
			|	{table.name = tableName}
			),
		AttrDatabasePrimitive :termOrFactType =
			:attrVal
			GetTableID(termOrFactType):tableID
			{this.GetTable(tableID).primitive = attrVal},
		AttrDatabaseAttribute :factType =
			:attrVal
			(	?attrVal
				{this.attributes[factType] = attrVal}
				{this.tables[this.GetResourceName(factType)] = 'Attribute'}
				GetTable(factType[0][1]):baseTable
				{factType[2][1]}:attributeName
				GetTable(attributeName):attributeTable
				GetTableFieldID(baseTable, attributeName):fieldID
				{baseTable.fields[fieldID].dataType = attributeTable.primitive}
			)?,
		AttrForeignKey :factType =
			:required
			GetTable(factType[0][1]):baseTable
			{factType[2][1]}:fkName
			GetTable(fkName):fkTable
			(	?(baseTable.idField == fkName)
				// If the foreign key matches the id field then delete the current field before adding the new.
				GetTableFieldID(baseTable, fkName):fieldID
				?(fieldID !== false)
				{baseTable.fields.splice(fieldID, 1)}
			)?
			AddTableField(baseTable, fkName, 'ForeignKey', required, null, {tableName: fkTable.name, fieldName: fkTable.idField})
			{this.tables[this.GetResourceName(factType)] = 'ForeignKey'},
		AttrUnique :factType =
			// TODO: This needs to have the dependency of coming after ForeignKey/Attribute attrs removed.
			:required
			GetTable(factType):baseTable
			(	?(baseTable === 'Attribute' || baseTable === 'ForeignKey')
				GetTable(factType[0][1]):baseTable
			)?
			{factType[2][1]}:uniqueField
			GetTableFieldID(baseTable, uniqueField):fieldID
			?(fieldID !== false)
			{baseTable.fields[fieldID].index = 'UNIQUE'},
		// AttrSynonym :term =
			// :synonym {this.identifiers[synonym[1]] = term[1]},
		AttrSynonymousForm :factType =
			:synForm
			AddFactType(synForm, factType),
		AttrTermForm :factType =
			:term
			{this.identifiers[term[1]] = factType}
			{this.tables[this.GetResourceName(term[1])] = this.GetTable(factType)},
		AttrNecessity :tableID =
			Rule,
		
		/** Fact Types **/
		FactType =
			&((:factTypePart &(:attributes) -> factTypePart)+:factType)
			AddFactType(factType, factType)
			(	?(this.IsPrimitive(factType[0]))
				// Eat input
				(:factTypePart &(:attributes))+
			|	GetResourceName(factType):resourceName
				(	?(factType.length == 2)
					// Eat input
					(:factTypePart &(:attributes))+
					GetTable(factType[0][1]):identifierTable
					AddTableField(identifierTable, factType[1][1], 'Boolean', true)
					{this.tables[resourceName] = 'BooleanAttribute'}
				|	{this.tables[resourceName] = {fields: [], primitive: false, name: null}}:linkTable
					(	Identifier:identifier
						GetTable(identifier.name):fkTable
						(	?fkTable.primitive
							AddTableField(linkTable, identifier.name + identifier.num, fkTable.primitive, true)
						|	AddTableField(linkTable, identifier.name + identifier.num, 'ForeignKey', true, null, {tableName: fkTable.name, fieldName: fkTable.idField})
						)
					|	['Verb' :verb :negated]
					)+
				)
			)
			-> factType,
		
		Cardinality =
			[
				(	'MinimumCardinality'
				|	'MaximumCardinality'
				|	'Cardinality'
				)
				Number:cardinality
			]
			-> cardinality,

		Variable =
			[	'Variable'
				Number:num
				Identifier:identifier
				(	// Don't add this var if it's an attribute binding.
					{this.bindAttributes[num]}:bind
					?bind
				|	{'var' + num}:varAlias
					{['SelectQuery', ['Select', []], ['From', this.GetTable(identifier.name).name, varAlias + identifier.name]]}:query
					ResolveConceptTypes(query, identifier, varAlias)
				)
				(	RulePart:whereBody
					(	?query
						AddWhereClause(query, whereBody)
					)?
				)?
			]
			(	NativePropertyAtomicFormulation:data
				-> {data: data}
			|	RulePart:whereBody2
				(	?query
					AddWhereClause(query, whereBody2)
					-> query
				|	// We ignore whereBody2, as it not useful for attributes
					(	?bind
						(	?bind.data
							// Embedded data
							-> {identifier: identifier, data: bind.data, whereBody: whereBody}
						|	-> {identifier: identifier, tableAlias: bind.tableAlias, whereBody: whereBody}
						)
					|	// A rule directly on a primitive, this should not be being processed..
						___PROCESSING_PRIMITIVE_RULE___.die
					)
				)
			),

		// Return role bindings as they would be found in the actual fact type.
		RoleBindings :actualFactType =
			{[]}:binds
			{0}:i
			(	?(i < actualFactType.length)
				RoleBinding:bind
				{_.findIndex(actualFactType, {3: i})}:j
				{actualFactType[j][1]}:termName
				GetTable(termName):table
				(	?table.primitive
				|	-> ('var' + bind.number + termName)
				):tableAlias
				{bind.tableAlias = tableAlias}
				{bind.baseIdentifierName = termName}
				{i+2}:i
				{binds[j/2] = bind}
			)+
			end
			-> binds
		,

		RoleBinding =
			[	'RoleBinding'
				Identifier:identifier
				(	number:number
				|	Value:data
				)
			]
			-> {
				identifier: identifier,
				number: number,
				data: data
			},

		NativeBinding =
			RoleBinding:bind
			(	?bind.data
				-> bind.data
			|	{this.bindAttributes[bind.number]}:baseBind
				?baseBind
				?baseBind.data
				-> baseBind.data
			|	(	?baseBind
					-> baseBind.tableAlias
				|	-> bind.tableAlias
				):bindName
				-> ['ReferencedField', 'var' + bindName, bind.identifier.name]
			),

		NativeProperty :actualFactType =
			?(this.IsPrimitive(actualFactType[0]))
			?(this.IsPrimitive(actualFactType[2]))
			NativeBinding:from
			NativeBinding:to
			end
			(	?(actualFactType[0][3] != 0)
				// If the first bind is not the first term (ie. reversed synonymous form), we go to -> from
				{to}:from
			)?
			{actualFactType[0][1]}:primitive
			{actualFactType[1][1]}:verb
			{actualFactType[2][1]}:property
			?(sbvrTypes[primitive] &&
				sbvrTypes[primitive].nativeProperties &&
				sbvrTypes[primitive].nativeProperties[verb] &&
				sbvrTypes[primitive].nativeProperties[verb][property])
			-> sbvrTypes[primitive].nativeProperties[verb][property](from, to),

		NativeFactType :actualFactType =
			?(actualFactType.length == 3)
			?(this.IsPrimitive(actualFactType[0]))
			?(this.IsPrimitive(actualFactType[2]))
			(	NativeBinding:from
				NativeBinding:to
				end
				(	?(actualFactType[0][3] != 0)
					// If the first term is not mapped to the first term (ie. reversed synonymous form), then we need to reverse the binds to match
					{to}:temp
					{from}:to
					{temp}:from
				)?
				{actualFactType[0][1]}:primitive
				{actualFactType[1][1]}:verb
				{actualFactType[2][1]}:secondPrimitive
				?(sbvrTypes[primitive] &&
					sbvrTypes[primitive].nativeFactTypes &&
					sbvrTypes[primitive].nativeFactTypes[secondPrimitive] &&
					sbvrTypes[primitive].nativeFactTypes[secondPrimitive][verb])
				-> sbvrTypes[primitive].nativeFactTypes[secondPrimitive][verb](from, to)
			|	___NativeFactTypeMatchingFailed___.die
			),

		LinkTable :actualFactType =
			{'link' + this.linkTableBind++}:tableAlias
			{['SelectQuery', ['Select', []], ['From', this.GetTable(actualFactType).name, tableAlias]]}:query
			{0}:i
			RoleBindings(actualFactType):binds
			(	?(i < binds.length)
				GetTable(binds[i].baseIdentifierName):table
				(	?table.primitive
				|	AddWhereClause(query, ['Equals', ['ReferencedField', tableAlias, binds[i].baseIdentifierName], ['ReferencedField', binds[i].tableAlias, table.idField]])
				)
				{i+1}:i
			)+
			-> ['Exists', query],
		
		ForeignKey :actualFactType =
			?(this.GetTable(actualFactType) == 'ForeignKey')
			(	RoleBindings(actualFactType):binds
				?(binds.length == 2)
				{binds[0]}:bindFrom
				{binds[1]}:bindTo
				GetTable(bindTo.baseIdentifierName):tableTo
			|	___ForeignKeyMatchingFailed___.die
			)
			(	?(bindTo.identifier.type == 'Name')
				{bindTo.identifier.name}:name
				GetTable(name):nameTable
				{'name-' + name + '-'}:varAlias
				{['SelectQuery', ['Select', [[['ReferencedField', bindTo.tableAlias, tableTo.idField]]]], ['From', nameTable.name, varAlias + name]]}:query
				ResolveConceptTypes(query, bindTo.identifier, varAlias, bindTo.baseIdentifierName)
				-> query
			|	-> ['ReferencedField', bindTo.tableAlias, tableTo.idField]
			):toField
			-> ['Equals', ['ReferencedField', bindFrom.tableAlias, bindTo.baseIdentifierName], toField],

		BooleanAttribute :actualFactType =
			?(this.GetTable(actualFactType) == 'BooleanAttribute')
			(	RoleBindings(actualFactType):binds
				?(binds.length == 1)
				{actualFactType[1][1]}:attributeName
				{actualFactType[1][2]}:negated
			|	{console.error(this.input)}
				___BooleanAttributeMatchingFailed___.die
			)
			-> ['Equals', ['ReferencedField', binds[0].tableAlias, attributeName], ['Boolean', !negated]],

		Attribute :actualFactType =
			?(this.GetTable(actualFactType) == 'Attribute')
			(	RoleBindings(actualFactType):binds
				?(binds.length == 2)
				{binds[0]}:bindReal
				{binds[1]}:bindAttr
				|	___AttributeMatchingFailed___.die
			)
			(	{this.bindAttributes[bindAttr.number]}:bind
				?(bind.number != bindReal.number)
				// If we're not the first bind we make sure we match it.
				-> ['Equals', ['ReferencedField', bind.tableAlias, bindAttr.identifier.name], ['ReferencedField', bindReal.tableAlias, bindAttr.identifier.name]]
			|	// Otherwise return true = true, just so things work.
				-> ['Equals', ['Boolean', true], ['Boolean', true]]
			),
		
		NativePropertyAtomicFormulation =
			[	'AtomicFormulation'
				[	'FactType'
					anything+:factType
				]
				MappedFactType(factType):actualFactType
				NativeProperty(actualFactType):whereClause
			]
			-> whereClause,
		
		AtomicFormulation =
			[	'AtomicFormulation'
				[	'FactType'
					anything+:factType
				]
				MappedFactType(factType):actualFactType
				(	NativeFactType(actualFactType)
				|	ForeignKey(actualFactType)
				|	BooleanAttribute(actualFactType)
				|	Attribute(actualFactType)
				|	LinkTable(actualFactType)
				):whereClause
			]
			-> whereClause,
		AtLeast =
			[	'AtLeastNQuantification'
				Cardinality:minCard
				Variable:variable
			]
			(	?(minCard == 0)
				// At least 0? Well that's always true..
				-> ['Boolean', true]
			|	(	?_.isArray(variable)
					// Variable is a query so we do a count.
					{variable[1][1].push(['Count', '*'])}
					-> ['GreaterThanOrEqual', variable, ['Number', minCard]]
				|	// Otherwise we're an attribute
					(	?(minCard > 1)
						// And to have more than one of an attribute is impossible.
						-> ['Boolean', false]
					|	?variable.data
						-> ['Boolean', true]
					|	-> ['Exists', ['ReferencedField', variable.tableAlias, variable.identifier.name]]
					)
				)
			):where
			(	?variable.whereBody
				-> ['And', variable.whereBody, where]
			|	-> where
			),
		Exactly =
			[	'ExactQuantification'
				Cardinality:card
				Variable:variable
			]
			(	?_.isArray(variable)
				// Variable is a query so we do a count.
				{variable[1][1].push(['Count', '*'])}
				-> ['Equals', variable, ['Number', card]]
			|	// Otherwise we're an attribute
				(	?variable.data
					-> ['Boolean', true]
				|	-> ['Exists', ['ReferencedField', variable.tableAlias, variable.identifier.name]]
				):exists
				(	?(card == 0)
					// Exactly 0 attributes is a non-existent (null) attribute
					-> ['Not', exists]
				|	?(card == 1)
					// Exactly 1 is existent.
					-> exists
				|	// And anything else is impossible.
					-> ['Boolean', false]
				)
			):where
			(	?variable.whereBody
				-> ['And', variable.whereBody, where]
			|	-> where
			),
		Range =
			[	'NumericalRangeQuantification'
				Cardinality:minCard
				Cardinality:maxCard
				Variable:variable
			]
			(	?_.isArray(variable)
				// Variable is a query so we do a count.
				{variable[1][1].push(['Count', '*'])}
				-> ['Between', variable, ['Number', minCard], ['Number', maxCard]]
			|	// Otherwise we're an attribute
				(	?variable.data
					-> ['Boolean', true]
				|	-> ['Exists', ['ReferencedField', variable.tableAlias, variable.identifier.name]]
				):exists
				(	?(minCard == 0)
					(	?(maxCard == 0)
						// Between 0 and 0 is not exists.
						-> ['Not', exists]
						// Between 0 and 1+ is always the case for an attribute as the max is 1
					|	-> ['Boolean', true]
					)
				|	?(minCard == 1)
					// Between 1 and .. is existent.
					-> exists
				|	// And anything else is impossible.
					-> ['Boolean', false]
				)
			):where
			(	?variable.whereBody
				-> ['And', variable.whereBody, where]
			|	-> where
			),
		Exists =
			[	'ExistentialQuantification'
				Variable:variable
			]
			(	?_.isArray(variable)
				// Variable is a query so we directly check for existence.
				-> ['Exists', variable]
			|	// Otherwise we're an attribute so we check for the field.
				(	?variable.data
					-> ['Boolean', true]
				|	-> ['Exists', ['ReferencedField', variable.tableAlias, variable.identifier.name]]
				)
			):where
			(	?variable.whereBody
				-> ['And', variable.whereBody, where]
			|	-> where
			),
		Negation =
			[	'LogicalNegation'
				RulePart:whereBody
			]
			-> ['Not', whereBody],
			
		
		RulePart =
			(	AtomicFormulation
			|	AtLeast
			|	Exactly
			|	Exists
			|	Negation
			|	Range
			|	:x
				{console.error('Hit unhandled operation:', x)}
				?(false)
			)+:whereBody
			(	?(whereBody.length == 1)
				-> whereBody[0]
			|	-> ['And'].concat(whereBody)
			),
		
		RuleBody =
			[
				(	'ObligationFormulation'
				|	'NecessityFormulation'
				|	'PossibilityFormulation'
				|	'PermissibilityFormulation'
				)
				RulePart:rule
			]
			-> rule,
		
		ProcessAtomicFormulations =
			{this.bindAttributes = []}
			{this.bindAttributeDepth = []}
			{this.nonPrimitiveExists = false}
			&ProcessAtomicFormulationsRecurse(0, 'ProcessAtomicFormulationsAttributes')
			&ProcessAtomicFormulationsRecurse(0, 'ProcessAtomicFormulationsNonPrimitive'),
		ProcessAtomicFormulationsRecurse :depth :rule =
			(	// Bit of a hack, but we only want to drill into the input if it's an array, otherwise we get infinite recursion.
				?(_.isArray(this.input.hd))
				[	'AtomicFormulation'
					[	'FactType'
						anything+:factType
					]
					UnmappedFactType(factType):unmappedFactType
					MappedFactType(factType):actualFactType
					{this._applyWithArgs(rule, depth, unmappedFactType, actualFactType)}
				|	ProcessAtomicFormulationsRecurse(depth+1, rule)
				]
			|	anything
			)*,
		ProcessAtomicFormulationsNonPrimitive :depth :unmappedFactType :actualFactType =
			RoleBindings(actualFactType):binds
			{	for(var i=0; i < binds.length; i++) {
					if(!this.IsPrimitive([binds[i].identifier.type, binds[i].identifier.name, binds[i].identifier.vocab])) {
						this.nonPrimitiveExists = true;
						break;
					}
				}
			},
		ProcessAtomicFormulationsAttributes :depth :unmappedFactType :actualFactType =
			RoleBindings(actualFactType):binds
			?(this.attributes.hasOwnProperty(unmappedFactType) && this.attributes[unmappedFactType])
			// Find the "base" binding - the one that isn't primitive
			{_.find(binds, function(bind) {
				return !$elf.IsPrimitive([bind.identifier.type, bind.identifier.name, bind.identifier.vocab]);
			})}:baseBinding
			// Use the "base" binding in the attribute binding list, but only if we are as shallow as possible.
			{_.find(binds, function(bind) {
				return $elf.IsPrimitive([bind.identifier.type, bind.identifier.name, bind.identifier.vocab])
						&& ($elf.bindAttributeDepth[bind.number] == null || $elf.bindAttributeDepth[bind.number] > depth);
			})}:attrBinding
			{	this.bindAttributeDepth[attrBinding.number] = depth;
				this.bindAttributes[attrBinding.number] = baseBinding;
			},
		
		Rule =
			[	'Rule'
				{this.linkTableBind = 0}
				&ProcessAtomicFormulations
				(	?this.nonPrimitiveExists
					RuleBody:ruleBody
				|	anything
				)
				[	'StructuredEnglish'
					:ruleText
				]
				(	?this.nonPrimitiveExists
					{this.rules.push(['Rule', ['StructuredEnglish', ruleText], ['Body', ruleBody]])}
				|	{console.warn('Ignoring rule with only primitives: ', ruleText)}
				)
			],
		
		Process =
			[	'Model'
				(	[	'Vocabulary'
						:vocab
						:attributes
					|	(	'Term'
						|	'Name'
						):type
						 IdentifierName:identifierName
						 :vocab
						 AddVocabulary(vocab)
						 Attributes([type, identifierName, vocab])
					|	'FactType'
						FactType:factType
						Attributes(factType)
					]
				|	Rule
				)+
			]
			{{}}:tables
			-> {tables:this.tables, rules:this.rules}
	}
	
	LF2AbstractSQL.AddTableField = function(table, fieldName, dataType, required, index, references) {
		var fieldID = this.GetTableFieldID(table, fieldName);
		if(fieldID === false) {
			table.fields.push({
				dataType: dataType,
				fieldName: fieldName,
				required: required,
				index: index,
				references: references
			});
		}
		return fieldID;
	}
	
	LF2AbstractSQL.AddWhereClause = function(query, whereBody) {
		// TODO: Move this to an optimisation pass?
		// Check if it's a place where we can do a join optimisation.
		if(whereBody[0] == 'Exists' && (
				whereBody[1][0] == 'SelectQuery' || whereBody[1][0] == 'InsertQuery' ||
				whereBody[1][0] == 'UpdateQuery' || whereBody[1][0] == 'UpsertQuery')) {
			whereBody = whereBody[1].slice(1);
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'From') {
					query.push(whereBody[i]);
				}
			}
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'Where') {
					this.AddWhereClause(query, whereBody[i][1]);
				}
			}
		}
		else {
			for(var i=1; i < query.length; i++) {
				if(query[i][0] == 'Where') {
					query[i][1] = ['And', query[i][1], whereBody];
					return;
				}
			}
			query.push(['Where', whereBody]);
		}
	};
	
	LF2AbstractSQL.ResolveConceptTypes = function(query, identifier, varAlias, untilConcept) {
		var conceptAlias,
			parentAlias = varAlias + identifier.name,
			concept = [identifier.type, identifier.name, identifier.vocab],
			conceptTable;
		while((untilConcept == null || !this.IdentifiersEqual(concept, untilConcept))
				&& (concept = this.FollowConceptType(concept)) !== false) {
			conceptAlias = varAlias + concept[1];
			conceptTable = this.GetTable(concept[1]);
			if(conceptTable.primitive !== false) {
				break;
			}
			query.push(['From', conceptTable.name, conceptAlias]);
			this.AddWhereClause(query, ['Equals', ['ReferencedField', parentAlias, concept[1]], ['ReferencedField', conceptAlias, conceptTable.idField]]);
			parentAlias = conceptAlias;
		}
	};
	
	LF2AbstractSQL.initialize = function() {
		SBVRCompilerLibs.initialize.call(this);
		this.tables = {};
		this.identifiers = {}; // TODO: Is this needed?
		this.rules = [];
		this.linkTableBind = 0;
		this.attributes = {};
		this.bindAttributes = [];
		this.bindAttributeDepth = [];
	};

	
	return LF2AbstractSQL;
});
