define(['has', 'ometa-core'], function(has) {
	var comparisons = {
			'Equals': ' = ',
			'GreaterThan': ' > ',
			'GreaterThanOrEqual': ' >= ',
			'LessThan': ' < ',
			'LessThanOrEqual': ' <= ',
			'NotEquals': ' != ',
			'Like': ' LIKE '
		};
	
	ometa AbstractSQLRules2SQL {
		NestedIndent :indent =
			-> (indent + '\t'),
	
		Not :indent =
			[	'Not'
				NestedIndent(indent):nestedIndent
				RuleBody(nestedIndent):ruleBody
				{'NOT (' + nestedIndent + ruleBody + indent + ')'}:notStatement
			]
			-> notStatement,

		Exists :indent =
			[	'Exists'
				(	// We need to create a SelectQuery differently to other comparators, so we check for it first.
					NestedIndent(indent):nestedIndent
					SelectQuery(nestedIndent):ruleBody
				|	Comparator:comparator
				)
			]
			(	?comparator
				-> (comparator + ' IS NOT NULL')
			|	-> ('EXISTS (' + nestedIndent + ruleBody + indent + ')')
			),
		
		ProcessQuery =
				(	SelectQuery('\n')
				|	InsertQuery('\n')
				|	UpdateQuery('\n')
				|	DeleteQuery('\n')
				):query
				-> {query: query, bindings: this.fieldOrderings}
			|	UpsertQuery('\n'),
		
		SelectQuery :indent =
			NestedIndent(indent):nestedIndent
			{[]}:tables
			{''}:where
			{''}:orderBy
			{''}:limit
			{''}:offset
			[	'SelectQuery'
				[	Select:fields
				|	Table:table
					{tables.push(table)}
				|	Where(indent):where
					{indent + where}:where
				|	OrderBy(indent):orderBy
					{indent + orderBy}:orderBy
				|	Limit(indent):limit
					{indent + limit}:limit
				|	Offset(indent):offset
					{indent + offset}:offset
				]*
			]
			-> ('SELECT ' + fields.join(', ') + indent + 'FROM ' + tables.join(',' + nestedIndent) + where + orderBy + limit + offset),

		DeleteQuery :indent =
			{[]}:tables
			{''}:where
			[	'DeleteQuery'
				[	Table:table
					{tables.push(table)}
				|	Where(indent):where
					{indent + where}:where
				]*
			]
			-> ('DELETE FROM ' + tables.join(', ') + where),
		
		InsertBody :indent =
			{[]}:tables
			[	Fields:fieldValues
			|	Table:table
				{tables.push(table)}
			|	// Ignore a where - we're probably in an Upsert.
				'Where'
				anything*
			]*
			(	?(fieldValues[0].length > 0)
				-> ('INSERT INTO ' + tables.join(', ') + ' (' + fieldValues[0].join(', ') + ')' + indent + ' VALUES (' + fieldValues[1].join(', ') + ')')
			|	-> ('INSERT INTO ' + tables.join(', ') + ' DEFAULT VALUES')
			),
		
		UpdateBody :indent =
			{[]}:tables
			{''}:where
			[	Fields:fieldValues
			|	Table:table
				{tables.push(table)}
			|	Where(indent):where
				{indent + where}:where
			]*
			(	?(fieldValues[0].length > 0)
			|	___UPDATE_QUERY_WITH_NO_FIELDS___.die
			)
			{[]}:sets
			{	for(var i=0; i < fieldValues[0].length; i++) {
					sets[i] = fieldValues[0][i] + ' = ' + fieldValues[1][i];
				}
			}
			-> ('UPDATE ' + tables.join(', ') + indent + ' SET ' + sets.join(',' + indent) + where),
		
		UpsertQuery :indent =
			{[]}:tables
			[	'UpsertQuery'
				&InsertBody(indent):insert
				{{query: insert, bindings: this.fieldOrderings}}:insert
				{this.fieldOrderings = []}
				UpdateBody(indent):update
				{{query: update, bindings: this.fieldOrderings}}:update
			]
			-> [insert, update],
		
		InsertQuery :indent =
			[	'InsertQuery'
				InsertBody(indent):insert
			]
			-> insert,
		
		UpdateQuery :indent =
			[	'UpdateQuery'
				UpdateBody(indent):update
			]
			-> update,
		
		Null =
			:next
			?(next===null)
			-> null,
		
		Fields =
			'Fields'
			{[]}:fields
			{[]}:values
			[
				[	anything:field
					{fields.push('"' + field + '"')}
					(	'?'
					|	true
						-> 1
					|	false
						-> 0
					|	Null
						-> 'NULL'
					|	Bind
					|	anything:value
						// TODO: Should escape this.
						-> ("'" + value + "'")
					):value
					{values.push(value)}
				]*
			]
			-> [fields, values],
		
		Select =
			'Select'
			{[]}:fields
			[	end
				{fields.push('1')}
			|
				(	[
						(	'Count'
							'*'
							-> 'COUNT(*)'
						|	(	Field
							|	ReferencedField
							):field
							(	anything:as
								-> (field + ' AS "' + as + '"')
							|	-> field
							)
						):field
						{fields.push(field)}
					]
				|	'*'
					{fields.push('*')}
				|	Null
					{fields.push('NULL')}
				|	anything:field
					// TODO: Should escape "
					{fields.push('"' + field + '"')}
				)*
			]
			-> fields,
		
		Table =
			'From'
			anything:table
			{[]}:alias
			(	:alias
				{['"' + alias + '"']}:alias
			)?
			-> ['"' + table + '"'].concat(alias).join(' AS '),
		
		Where :indent =
			'Where'
			RuleBody(indent):ruleBody
			-> ('WHERE ' + ruleBody),
		
		OrderBy :indent =
			'OrderBy'
			{[]}:orders
			[	(	'ASC'
				|	'DESC'
				):order
				(	Field
				|	ReferencedField
				):field
				{orders.push(field + ' ' + order)}
			]+
			-> ('ORDER BY ' + orders.join(', ')),
		
		Limit :indent =
			'Limit'
			Number:num
			-> ('LIMIT ' + num),
		
		Offset :indent =
			'Offset'
			Number:num
			-> ('OFFSET ' + num),
		
		Field =
			[	'Field'
				:field
			]
			-> ('"' + field + '"'),
		
		ReferencedField =
			[	'ReferencedField'
				:binding
				:field
			]
			-> ('"' + binding + '"."' + field + '"'),
		
		// TODO: Integer should actually be separate from number, for the case of bitwise operations that need an integral type.
		Number =
			[	(	'Number'
				|	'Real'
				|	'Integer'
				)
				:number
			]
			-> number,
		
		Boolean =
			[	'Boolean'
				(	true
					-> 1
				|	false
					-> 0
				):bool
			]
			-> bool,
		Bind =
			[	'Bind'
				:tableName
				:field
			]
			{this.fieldOrderings.push([tableName, field])}
			-> '?',
		
		Text =
			[	(	'Value'
				|	'Text'
				)
				:text
			]
			// TODO: This should have quotes escaped
			-> ("'" + text + "'"),
			
		CharacterLength =
			[	'CharacterLength'
				(	ReferencedField
				|	Field
				|	Text
				):text
			]
			(	?has('USE_MYSQL')
				-> ('CHAR_LENGTH(' + text + ')')
			|	-> ('LENGTH(' + text + ')')
			),
		
		Concat =
			[	(	'Concat'
				|	'Concatenate'
				)
				Comparator+:comparators
			]
			(	?has('USE_MYSQL')
				-> ('CONCAT(' + comparators.join(', ') + ')')
			|	-> ('(' + comparators.join(' || ') + ')')
			),
		
		NumericValue =
			(	ReferencedField
			|	Field
			|	Number
			|	BitwiseAnd
			|	BitwiseShiftRight
			|	CharacterLength
			),
		
		BitwiseAnd =
			[	'BitwiseAnd'
				NumericValue:operand
				NumericValue:mask
			]
			-> ('(' + operand + ' & ' + mask + ')'),
		
		BitwiseShiftRight =
			[	'BitwiseShiftRight'
				NumericValue:operand
				NumericValue:shift
			]
			-> ('(' + operand + ' >> ' + shift + ')'),
		
		And :indent =
			[	'And'
				RuleBody(indent)*:ruleBodies
			]
		->	ruleBodies.join(indent + 'AND '),
		
		Comparison :indent =
			[	(	'Equals'
				|	'GreaterThan'
				|	'GreaterThanOrEqual'
				|	'LessThan'
				|	'LessThanOrEqual'
				|	'NotEquals'
				|	'Like'
				):comparison
				RuleBody(indent):a
				RuleBody(indent):b
			]
			-> (a + comparisons[comparison] + b),
		
		Between :indent =
			[	'Between'
				Comparator(indent):val
				Comparator(indent):a
				Comparator(indent):b
			]
			-> (val + ' BETWEEN ' + a + ' AND ' + b),
		
		Comparator :indent =
				NestedIndent(indent):nestedIndent
				SelectQuery(nestedIndent):query
				-> ('(' + nestedIndent + query + indent + ')')
			|	Field
			|	ReferencedField
			|	Number
			|	Boolean
			|	Text
			|	Bind
			|	CharacterLength
			|	BitwiseAnd
			|	BitwiseShiftRight
			|	Concat,
			
		
		RuleBody :indent =
				Comparator(indent)
			|	Not(indent)
			|	Exists(indent)
			|	Comparison(indent)
			|	Between(indent)
			|	And(indent)
			|	Boolean,
		
		Process =
			(	SelectQuery('\n')
			|	RuleBody('\n'):ruleBody
				-> ('SELECT ' + ruleBody + ' AS "result";')
			)
	}
	
	AbstractSQLRules2SQL.initialize = function() {
		this.fieldOrderings = [];
	};
	
	return AbstractSQLRules2SQL;
});