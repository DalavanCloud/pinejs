define(['sbvr-parser/SBVRLibs', 'ometa/ometa-base'], function(SBVRLibs) {
	var LFValidator;
	
	// TODO: Make the LFValidator validate that it is actually correctly structured LF.
	ometa LFValidator <: SBVRLibs {
		$ :x =
			(	token(x):a
				-> [a] 
			|	-> []
			),

		trans
			[:t apply(t):a]
			-> a,
		token :x =
			[:t ?{t==x} apply(x):a]
			-> a,

		letters =
			letter+:l space*
			-> l.join(''),

		num
			number:n ?{!isNaN(n)}
			-> ['num', parseInt(n)],

		Model
			{[]}:xs
			(
				(	"Term"
				|	"FactType"
				|	"Rule"
				):x
				(	?(x != null)
					{xs.push(x)}
				)?
			)*
			-> ['Model'].concat(xs),

		FactType
			{[]}:factType
			(	"Term":t
				"Verb":v
				{factType.concat([t,v])}:factType
			)*
			$('Term'):t
			{factType.concat(t)}:factType
			&(:attrs AddFactType(factType, factType))?
			addAttributes(['FactType'].concat(factType)),

		Term
			:t addAttributes(['Term', t]),
		Verb
			:v
			-> ['Verb', v],
		Rule
			("ObligationF"|"NecessityF"|"PossibilityF"|"PermissibilityF"):x "text":t
			-> ['Rule', x, t],
		addAttributes :termOrVerb =
			(	end
			|	{{}}:attrsFound
				[	(
						[	:attrName {attrsFound[attrName] = true}
							(	?(this['attr'+attrName]) {this._applyWithArgs.call(this, 'attr'+attrName, termOrVerb)}
							|	anything
							):attrVal
						]
						-> [attrName, attrVal]
					)*:attrs
					end
				]
				defaultAttributes(termOrVerb, attrsFound, attrs)
			)
			-> termOrVerb,
		attrDefinition :termOrVerb =
			(	['Enum' :values]
			|	trans
			),
		attrSynonymousForm :factType =
			:synForm
			AddFactType(synForm.slice(0, -1), factType.slice(1))
			-> synForm,

		text
			:a
			-> ['text', a],
		
		ObligationF
			trans*:xs
			-> ['ObligationF'].concat(xs),
		NecessityF
			trans*:xs
			-> ['NecessityF'].concat(xs),
		PossibilityF
			trans*:xs
			-> ['PossibilityF'].concat(xs),
		PermissibilityF
			trans*:xs
			-> ['PermissibilityF'].concat(xs),

		LogicalNegation
			trans:xs
			-> ['LogicalNegation'].concat([xs]),

		quant =
			(	"UniversalQ"
			|	"ExistentialQ"
			|	"ExactQ"
			|	"AtMostNQ"
			|	"AtLeastNQ"
			|	"NumericalRangeQ"
			),
		UniversalQ
			"Variable":v trans*:xs
			-> ['UniversalQ', v].concat(xs),
		ExistentialQ
			"Variable":v trans*:xs
			-> ['ExistentialQ', v].concat(xs),
		ExactQ
			"card":i
			"Variable":v trans*:xs
			-> ['ExactQ', i, v].concat(xs),
		AtMostNQ
			"maxCard":a
			"Variable":v trans*:xs
			-> ['AtMostNQ', a, v].concat(xs),
		AtLeastNQ
			"minCard":i
			"Variable":v trans*:xs
			-> ['AtLeastNQ', i, v].concat(xs),
		NumericalRangeQ
			"minCard":i "maxCard":a
			"Variable":v trans*:xs
			-> ['NumericalRangeQ', i, a, v].concat(xs),

		card
			"num":n
			-> ['card', n],
		minCard
			"num":n
			-> ['minCard', n],
		maxCard
			"num":n
			-> ['maxCard', n],

		Variable
			"num":n "Term":t ("AtomicFormulation"|quant):w
			-> ['Variable', n, t, w],
		Variable
			"num":n "Term":t
			-> ['Variable', n, t],

		RoleBinding
			"Term":t number:n
			-> ['RoleBinding', t, n], 
		AtomicFormulation
			"FactType":f "RoleBinding"*:b
			-> ['AtomicFormulation', f].concat(b)
	}
	
	LFValidator.initialize = function() {
		SBVRLibs.initialize.call(this);
	}

	LFValidator.defaultAttributes = function(termOrVerb, attrsFound, attrs) {
		termOrVerb.push(attrs);
	}
	
	return LFValidator;
});