// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty;

  define(['sbvr-compiler/AbstractSQLRules2SQL', 'sbvr-compiler/AbstractSQLOptimiser', 'Prettify', 'underscore'], function(AbstractSQLRules2SQL, AbstractSQLOptimiser, Prettify, _) {
    var dataTypeValidate, generate, postgresDataType, websqlDataType;
    dataTypeValidate = function(originalValue, field) {
      var bcrypt, salt, validated, value;
      value = originalValue;
      validated = true;
      if (value === null || value === '') {
        switch (field[2]) {
          case 'PRIMARY KEY':
          case 'NOT NULL':
            validated = 'cannot be null';
        }
      } else {
        switch (field[0]) {
          case 'Serial':
          case 'Integer':
          case 'ForeignKey':
          case 'ConceptType':
            value = parseInt(value, 10);
            if (_.isNaN(value)) {
              validated = 'is not a number: ' + originalValue;
            }
            break;
          case 'Date':
          case 'Date Time':
          case 'Time':
            value = Date.parse(value);
            if (_.isNaN(value)) {
              validated = 'is not a ' + field[0] + ': ' + originalValue;
            }
            break;
          case 'Interval':
            value = parseInt(value, 10);
            if (_.isNaN(value)) {
              validated = 'is not a number: ' + originalValue;
            }
            break;
          case 'Real':
            value = parseFloat(value);
            if (_.isNaN(value)) {
              validated = 'is not a number: ' + originalValue;
            }
            break;
          case 'Short Text':
            if (!_.isString(value)) {
              validated = 'is not a string: ' + originalValue;
            } else if (value.length > 20) {
              validated = 'longer than 20 characters (' + value.length + ')';
            }
            break;
          case 'Long Text':
            if (!_.isString(value)) {
              validated = 'is not a string: ' + originalValue;
            }
            break;
          case 'Boolean':
            value = parseInt(value, 10);
            if (_.isNaN(value) || (value !== 0 && value !== 1)) {
              validated = 'is not a boolean: ' + originalValue;
            }
            break;
          case 'Hashed':
            if (!_.isString(value)) {
              validated = 'is not a string';
            } else if ((typeof window !== "undefined" && window !== null) && window === (function() {
              return this;
            })()) {
              if (value.length > 60) {
                validated = 'longer than 60 characters (' + value.length + ')';
              }
            } else {
              bcrypt = require('bcrypt');
              salt = bcrypt.genSaltSync();
              value = bcrypt.hashSync(value, salt);
            }
            break;
          default:
            if (!_.isString(value)) {
              validated = 'is not a string: ' + originalValue;
            } else if (value.length > 100) {
              validated = 'longer than 100 characters (' + value.length + ')';
            }
        }
      }
      return {
        validated: validated,
        value: value
      };
    };
    postgresDataType = function(dataType, necessity) {
      switch (dataType) {
        case 'Serial':
          return 'SERIAL ' + necessity;
        case 'Date':
          return 'DATE ' + necessity;
        case 'Date Time':
          return 'TIMESTAMP ' + necessity;
        case 'Time':
          return 'TIME ' + necessity;
        case 'Interval':
          return 'Interval ' + necessity;
        case 'Real':
          return 'REAL ' + necessity;
        case 'Integer':
        case 'ForeignKey':
        case 'ConceptType':
          return 'INTEGER ' + necessity;
        case 'Short Text':
          return 'VARCHAR(20) ' + necessity;
        case 'Long Text':
          return 'TEXT ' + necessity;
        case 'Boolean':
          return 'INTEGER NOT NULL DEFAULT 0';
        case 'Hashed':
          return 'CHAR(60) ' + necessity;
        case 'Value':
          return 'VARCHAR(100) NOT NULL';
        default:
          return 'VARCHAR(100)';
      }
    };
    websqlDataType = function(dataType, necessity) {
      switch (dataType) {
        case 'Serial':
          return 'INTEGER ' + necessity + ' AUTOINCREMENT';
        case 'Date':
          return 'TEXT ' + necessity;
        case 'Date Time':
          return 'TEXT ' + necessity;
        case 'Time':
          return 'TEXT ' + necessity;
        case 'Interval':
          return 'INTEGER ' + necessity;
        case 'Real':
          return 'REAL ' + necessity;
        case 'Integer':
        case 'ForeignKey':
        case 'ConceptType':
          return 'INTEGER ' + necessity;
        case 'Short Text':
          return 'VARCHAR(20) ' + necessity;
        case 'Long Text':
          return 'TEXT ' + necessity;
        case 'Boolean':
          return 'INTEGER NOT NULL DEFAULT 0';
        case 'Hashed':
          return 'CHAR(60) ' + necessity;
        case 'Value':
          return 'VARCHAR(100) ' + necessity;
        default:
          return 'VARCHAR(100)';
      }
    };
    generate = function(sqlModel, dataTypeGen) {
      var createSQL, createSchemaStatements, dependency, depends, dropSQL, dropSchemaStatements, field, foreignKey, foreignKeys, hasDependants, instance, resourceName, rule, ruleSQL, ruleStatements, schemaDependencyMap, schemaInfo, table, tableName, tableNames, unsolvedDependency, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      hasDependants = {};
      schemaDependencyMap = {};
      _ref = sqlModel.tables;
      for (resourceName in _ref) {
        if (!__hasProp.call(_ref, resourceName)) continue;
        table = _ref[resourceName];
        if (!(!_.isString(table))) {
          continue;
        }
        foreignKeys = [];
        depends = [];
        dropSQL = 'DROP TABLE "' + table.name + '";';
        createSQL = 'CREATE TABLE "' + table.name + '" (\n\t';
        _ref1 = table.fields;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          field = _ref1[_i];
          createSQL += '"' + field[1] + '" ' + dataTypeGen(field[0], field[2]) + '\n,\t';
          if ((_ref2 = field[0]) === 'ForeignKey' || _ref2 === 'ConceptType') {
            foreignKeys.push([field[1], field[3]]);
            depends.push(field[1]);
            hasDependants[field[1]] = true;
          }
        }
        for (_j = 0, _len1 = foreignKeys.length; _j < _len1; _j++) {
          foreignKey = foreignKeys[_j];
          createSQL += 'FOREIGN KEY ("' + foreignKey[0] + '") REFERENCES "' + foreignKey[0] + '" ("' + foreignKey[1] + '")' + '\n,\t';
        }
        createSQL = createSQL.slice(0, -2) + ');';
        schemaDependencyMap[table.name] = {
          resourceName: resourceName,
          primitive: table.primitive,
          createSQL: createSQL,
          dropSQL: dropSQL,
          depends: depends
        };
      }
      createSchemaStatements = [];
      dropSchemaStatements = [];
      tableNames = [];
      while (tableNames.length !== (tableNames = Object.keys(schemaDependencyMap)).length && tableNames.length > 0) {
        for (_k = 0, _len2 = tableNames.length; _k < _len2; _k++) {
          tableName = tableNames[_k];
          schemaInfo = schemaDependencyMap[tableName];
          unsolvedDependency = false;
          _ref3 = schemaInfo.depends;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            dependency = _ref3[_l];
            if (schemaDependencyMap.hasOwnProperty(dependency)) {
              unsolvedDependency = true;
              break;
            }
          }
          if (unsolvedDependency === false) {
            if (sqlModel.tables[schemaInfo.resourceName].exists = schemaInfo.primitive === false || (hasDependants[tableName] != null)) {
              if (schemaInfo.primitive !== false) {
                console.warn("We're adding a primitive table??", schemaInfo.resourceName);
              }
              createSchemaStatements.push(schemaInfo.createSQL);
              dropSchemaStatements.push(schemaInfo.dropSQL);
              console.log(schemaInfo.createSQL);
            }
            delete schemaDependencyMap[tableName];
          }
        }
      }
      dropSchemaStatements = dropSchemaStatements.reverse();
      try {
        _ref4 = sqlModel.rules;
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          rule = _ref4[_m];
          instance = AbstractSQLOptimiser.createInstance();
          rule[2][1] = instance.match(rule[2][1], 'Process');
        }
      } catch (e) {
        console.log(e);
        console.log(instance.input);
      }
      ruleStatements = [];
      try {
        _ref5 = sqlModel.rules;
        for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
          rule = _ref5[_n];
          instance = AbstractSQLRules2SQL.createInstance();
          ruleSQL = instance.match(rule[2][1], 'Process');
          console.log(rule[1][1]);
          console.log(ruleSQL);
          ruleStatements.push({
            structuredEnglish: rule[1][1],
            sql: ruleSQL
          });
        }
      } catch (e) {
        console.log(e);
        console.log(instance.input);
      }
      return {
        tables: sqlModel.tables,
        createSchema: createSchemaStatements,
        dropSchema: dropSchemaStatements,
        rules: ruleStatements
      };
    };
    return {
      websql: {
        generate: function(sqlModel) {
          return generate(sqlModel, websqlDataType);
        },
        dataTypeValidate: dataTypeValidate
      },
      postgres: {
        generate: function(sqlModel) {
          return generate(sqlModel, postgresDataType);
        },
        dataTypeValidate: dataTypeValidate
      }
    };
  });

}).call(this);
