define(['sbvr-compiler/LFOptimiser', 'underscore'], function(LFOptimiser, _) {
	var LF2AbstractSQLPrep;

	ometa LF2AbstractSQLPrep <: LFOptimiser {
		AttrConceptType :termName =
			^AttrConceptType(termName):conceptType
			{this.primitives[conceptType] = false}
			-> conceptType,
		AttrDatabaseAttribute :termOrFactType =
			:attrVal
			{	(termOrFactType[0] == 'Term' && (!this.attributes.hasOwnProperty(termOrFactType[3]) || this.attributes[termOrFactType[3]] === true))
				|| (termOrFactType[0] == 'FactType' && termOrFactType.length == 4
					&& (!this.attributes.hasOwnProperty(termOrFactType[3]) || this.attributes[termOrFactType[3]] === true)
					&& this.primitives.hasOwnProperty(termOrFactType[3]) && this.primitives[termOrFactType[3]] !== false)
			}:newAttrVal
			{this.attributes[termOrFactType] = newAttrVal}
			(	?(newAttrVal != attrVal)
				{console.log('Changing DatabaseAttribute attr to:', newAttrVal, termOrFactType)}
				SetHelped
			)?
			-> newAttrVal,
		AttrDatabasePrimitive :termOrFactType =
			:attrVal
			{attrVal}:newAttrVal
			(	?(this.primitives.hasOwnProperty(termOrFactType))
				{this.primitives[termOrFactType]}:newAttrVal
				?(newAttrVal != attrVal)
				{console.log('Changing DatabaseAttribute attr to:', newAttrVal, termOrFactType)}
				SetHelped
			)?
			{this.primitives[termOrFactType] = newAttrVal}
			-> newAttrVal,

		Variable
			^Variable:variable
			(	{variable[2]}:term
				// Replace the term if it's a primitive and we're processing an attribute rule.
				?(this.processingAttributeRule && this.primitives.hasOwnProperty(term) && this.primitives[term] !== false)
				{	for(var i=1; i < this.processingAttributeRule.length; i+=2) {
						if(!this.IsChild(term[1], this.processingAttributeRule[i][1])) {
							return this.processingAttributeRule[i][1];
						}
					}
				}:newTerm
				{console.log('Switched variable term', term, 'to', newTerm)}
				{variable[2][1] = newTerm}
			)?
			-> variable,
			
		AtomicFormulation =
			&"FactType":factType
			ActualFactType(factType.slice(1)):actualFactType
			{['FactType'].concat(actualFactType)}:actualFactType
			// {console.log(actualFactType.toString(), ['FactType'].concat(actualFactType).toString(), this.attributes)}
			(	?(this.attributes.hasOwnProperty(actualFactType))
				{console.log('Atomic Formulation Attr', this.processingAttributeRule)}
				(	?this.processingAttributeRule
					^AtomicFormulation
				|	{this.processingAttributeRule = actualFactType}
					?false
				)
			|	?(!this.attributes.hasOwnProperty(actualFactType))
				^AtomicFormulation
			),
		
		UniversalQ
			"Variable":v trans*:xs SetHelped
			-> ['LogicalNegation', ['ExistentialQ', v, ['LogicalNegation'].concat(xs)]],
		
		AtMostNQ
			"MaximumCardinality":maxCard "Variable":v trans*:xs SetHelped
			{maxCard[1][1]++}
			-> ['LogicalNegation', ['AtLeastNQ', ['MinimumCardinality', maxCard[1]], v].concat(xs)],
		
		ForeignKey :v1 =
			// Just a basic var
			?(v1.length == 3)
			(
				[	'ExactQ'
					"Cardinality":card
					?(card[1][1] == 1)
					"Variable":v2
					// Just a basic var
					?(v2.length == 3)
					"AtomicFormulation":atomicForm
					{'NOT NULL'}:necessity
				]
			|
				[	'AtMostNQ'
					"MaximumCardinality":card
					?(card[1][1] == 1)
					"Variable":v2
					// Just a basic var
					?(v2.length == 3)
					"AtomicFormulation":atomicForm
					{'NULL'}:necessity
				]
			)
			// A term verb term fact type, in the same order as the vars appear.
			{atomicForm[1]}:factType
			?(atomicForm.length == 4 && factType.length == 4)
			ActualFactType(factType.slice(1)):actualFactType
			?(v1[2][1] == actualFactType[0][1] && v2[2][1] == actualFactType[2][1])
			{this.foreignKeys[factType] = necessity}
			// We have matched a foreign key, so call SetHelped.
			SetHelped,
			
		
		Rule
			{this.processingAttributeRule = false}
			(	[	'ObligationF'
					[	'UniversalQ'
						"Variable":v1
						ForeignKey(v1)
					|
						'LogicalNegation'
						[	'ExistentialQ'
							"Variable":v1
							[	'LogicalNegation'
								ForeignKey(v1)
							]
						]
					]
				]
				"StructuredEnglish"
				// We have matched a foreign key, return an empty array to remove the rule.
				-> null
			|	^Rule
			|	?this.processingAttributeRule
				^Rule
			)
	}
	
	LF2AbstractSQLPrep.initialize = function() {
		LFOptimiser.initialize.call(this);
		this.foreignKeys = [];
		this.primitives = [];
		this.attributes = [];
		this.processingAttributeRule = false;
	}
	
	LF2AbstractSQLPrep.defaultAttributes = function(termOrVerb, attrsFound, attrs) {
		if(!attrsFound.hasOwnProperty('DatabaseIDField')) {
			attrs.push(['DatabaseIDField', 'id']);
			this.SetHelped();
		}
		switch(termOrVerb[0]) {
			case 'Term':
				if(!attrsFound.hasOwnProperty('DatabaseNameField')) {
					attrs.push(['DatabaseNameField', '_name']);
					this.SetHelped();
				}
				if(!attrsFound.hasOwnProperty('DatabaseTableName')) {
					attrs.push(['DatabaseTableName', termOrVerb[1].replace(new RegExp(' ','g'),'_')]);
					this.SetHelped();
				}
				if(!attrsFound.hasOwnProperty('DatabasePrimitive')) {
					if(!this.primitives.hasOwnProperty(termOrVerb)) {
						this.primitives[termOrVerb] = this.isPrimitive(termOrVerb[1]);
					}
					console.log('Adding primitive attr', this.primitives[termOrVerb], termOrVerb);
					attrs.push(['DatabasePrimitive', this.primitives[termOrVerb]]);
					this.SetHelped();
				}
			break;
			case 'FactType':
				if(!attrsFound.hasOwnProperty('DatabaseTableName')) {
					var tableName = termOrVerb[1][1].replace(new RegExp(' ','g'),'_');
					for(var i=2;i<termOrVerb.length;i++) {
						tableName += '-' + termOrVerb[i][1].replace(new RegExp(' ','g'),'_');
					}
					attrs.push(['DatabaseTableName', tableName]);
					this.SetHelped();
				}
				if(this.foreignKeys.hasOwnProperty(termOrVerb)) {
					if(!attrsFound.hasOwnProperty('ForeignKey')) {
						console.log('Adding FK attr', this.foreignKeys[termOrVerb], termOrVerb);
						attrs.push(['ForeignKey', this.foreignKeys[termOrVerb]]);
						this.SetHelped();
					}
					else if(attrsFound['ForeignKey'] != this.foreignKeys[termOrVerb]) {
						console.error(attrsFound['ForeignKey'], this.foreignKeys[termOrVerb])
						___MISMATCHED_FOREIGN_KEY___.die();
					}
					if(!attrsFound.hasOwnProperty('DatabaseAttribute')) {
						attrs.push(['DatabaseAttribute', false]);
						this.SetHelped();
					}
				}
				// Boolean fact type
				if(termOrVerb.length == 3) {
					if(!this.primitives.hasOwnProperty(termOrVerb[1]) || this.primitives[termOrVerb[1]] !== false) {
						this.SetHelped();
					}
					// The term of a boolean fact type cannot be a primitive.
					this.primitives[termOrVerb[1]] = false;
				} // Tertiary or higher fact type
				else if(termOrVerb.length > 4) {
					// The terms in a tertiary or higher fact type cannot become attributes.
					for(var i = 1;i < termOrVerb.length; i+=2) {
						if(!this.attributes.hasOwnProperty(termOrVerb[i]) || this.attributes[termOrVerb[i]] !== false) {
							this.SetHelped();
						}
						this.attributes[termOrVerb[i]] = false;
					}
				}
			break;
		}
		termOrVerb.push(attrs);
	}

	var primitives = {
		'Integer': true,
		'Short Text': true,
		'Long Text': true
	};
	LF2AbstractSQLPrep.isPrimitive = function(termName) {
		// do {
			if (primitives.hasOwnProperty(termName)) {
				return termName;
			}
		// } while (this.conceptTypes.hasOwnProperty(termName) && (termName = this.conceptTypes[termName]));
		if (this.conceptTypes.hasOwnProperty(termName) && (termName = this.conceptTypes[termName])) {
			if (primitives.hasOwnProperty(termName)) {
				return termName;
			}
		}
		return false;
	}
	return LF2AbstractSQLPrep;
});