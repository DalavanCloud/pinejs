define(['ometa/ometa-base'], function() {
	var AbstractSQLRules2SQL,
		comparisons = {
			'Equals': ' = ',
			'EqualOrGreater': ' >= ',
			'NotEquals': ' != '
		};
	
	ometa AbstractSQLRules2SQL {
		NestedIndent :indent =
			-> (indent + '\t'),
	
		Not :indent =
			[	'Not'
				(	Exists(indent):ruleBody
					-> ('NOT ' + ruleBody)
				|	NestedIndent(indent):nestedIndent
					RuleBody(nestedIndent):ruleBody
					-> ('NOT (' + nestedIndent + ruleBody + indent + ')')
				):notStatement
			]
			-> notStatement,

		Exists :indent =
			[	'Exists'
				NestedIndent(indent):nestedIndent
				SelectQuery(nestedIndent):ruleBody
			]
			-> ('EXISTS (' + nestedIndent + ruleBody + indent + ')'),
		
		ProcessQuery =
				(	SelectQuery('\n')
				|	InsertQuery('\n')
				|	UpdateQuery('\n')
				|	DeleteQuery('\n')
				):query
				-> {query: query, bindings: this.fieldOrderings}
			|	UpsertQuery('\n'),
		
		SelectQuery :indent =
			NestedIndent(indent):nestedIndent
			{[]}:tables
			[	'SelectQuery'
				[	Select:fields
				|	Table:table
					{tables.push(table)}
				|	Where(indent):where
					{indent + 'WHERE ' + where}:where
				|	OrderBy(indent):orderBy
					{indent + 'ORDER BY ' + orderBy}:orderBy
				]*
			]
			-> ('SELECT ' + fields.join(', ') + indent + 'FROM ' + tables.join(',' + nestedIndent) + (where!=null ? where : '') + (orderBy!=null ? orderBy : '')),

		DeleteQuery :indent =
			{[]}:tables
			[	'DeleteQuery'
				[	Table:table
					{tables.push(table)}
				|	Where(indent):where
					{indent + 'WHERE ' + where}:where
				]*
			]
			-> ('DELETE FROM ' + tables.join(', ') + indent + (where!=null ? where : '')),
		
		InsertBody :indent =
			{[]}:tables
			[	Fields:fieldValues
			|	Table:table
				{tables.push(table)}
			|	// Ignore a where - we're probably in an Upsert.
				'Where'
				anything*
			]*
			-> ('INSERT INTO ' + tables.join(', ') + ' (' + fieldValues[0].join(', ') + ')' + indent + ' VALUES (' + fieldValues[1].join(', ') + ')'),
		
		UpdateBody :indent =
			{[]}:tables
			[	Fields:fieldValues
			|	Table:table
				{tables.push(table)}
			|	Where(indent):where
				{indent + 'WHERE ' + where}:where
			]*
			{[]}:sets
			{	for(var i=0; i < fieldValues[0].length; i++) {
					sets[i] = fieldValues[0][i] + ' = ' + fieldValues[1][i];
				}
			}
			-> ('UPDATE ' + tables.join(', ') + indent + ' SET ' + sets.join(',' + indent) + (where!=null ? where : '')),
		
		UpsertQuery :indent =
			{[]}:tables
			[	'UpsertQuery'
				&InsertBody(indent):insert
				{{query: insert, bindings: this.fieldOrderings}}:insert
				{this.fieldOrderings = []}
				UpdateBody(indent):update
				{{query: update, bindings: this.fieldOrderings}}:update
			]
			-> [insert, update],
		
		InsertQuery :indent =
			[	'InsertQuery'
				InsertBody(indent):insert
			]
			-> insert,
		
		UpdateQuery :indent =
			[	'UpdateQuery'
				UpdateBody(indent):update
			]
			-> update,
		
		Null =
			:next
			?(next===null)
			-> null,
		
		Fields =
			'Fields'
			{[]}:fields
			{[]}:values
			[
				[	anything:field
					{fields.push('"' + field + '"')}
					(	'?'
					|	true
						-> 1
					|	false
						-> 0
					|	Null
						-> 'NULL'
					|	Bind
					|	anything:value
						// TODO: Should escape this.
						-> ("'" + value + "'")
					):value
					{values.push(value)}
				]+
			]
			-> [fields, values],
		
		Select =
			'Select'
			{[]}:fields
			[	end
				{fields.push('1')}
			|
				(	[
						(	'Count'
							'*'
							-> 'COUNT(*)'
						|	(	Field
							|	ReferencedField
							):field
							anything:as
							-> (field + ' AS "' + as + '"')
						):field
						{fields.push(field)}
					]
				|	'*'
					{fields.push('*')}
				|	Null
					{fields.push('NULL')}
				|	anything:field
					// TODO: Should escape "
					{fields.push('"' + field + '"')}
				)*
			]
			-> fields,
		
		Table =
			'From'
			anything:table
			{[]}:alias
			(	:alias
				{['"' + alias + '"']}:alias
			)?
			-> ['"' + table + '"'].concat(alias).join(' AS '),
		
		Where :indent =
			'Where'
			RuleBody(indent),
		
		OrderBy :indent =
			'OrderBy'
			{[]}:orders
			[	(	'ASC'
				|	'DESC'
				):order
				Field:field
				{orders.push(field + ' ' + order)}
			]+
			-> orders.join(', '),
		
		Field =
			[	'Field'
				:field
			]
			-> ('"' + field + '"'),
		
		ReferencedField =
			[	'ReferencedField'
				:binding
				:field
			]
			-> ('"' + binding + '"."' + field + '"'),
		
		Number =
			[	'Number'
				:number
			]
			-> number,
		
		Boolean =
			[	'Boolean'
				(	true
					-> 1
				|	false
					-> 2
				):bool
			]
			-> bool,
		Bind =
			[	'Bind'
				:tableName
				:field
			]
			{this.fieldOrderings.push([tableName, field])}
			-> '?',
		
		// A generic value, no idea what data type it may be..
		Value =
			[	'Value'
				:value
			]
			-> ("'" + value + "'"),
		
		And :indent =
			[	'And'
				RuleBody(indent)*:ruleBodies
			]
		->	ruleBodies.join(' AND '),
		
		Comparison :indent =
			[	(	'Equals'
				|	'EqualOrGreater'
				|	'NotEquals'
				):comparison
				RuleBody(indent):a
				RuleBody(indent):b
			]
			-> (a + comparisons[comparison] + b),
		
		Between :indent =
			[	'Between'
				Comparator(indent):val
				Comparator(indent):a
				Comparator(indent):b
			]
			-> (val + ' BETWEEN ' + a + ' AND ' + b),
		
		Comparator :indent =
				SelectQuery(indent):query
				NestedIndent(indent):nestedIndent
				-> ('(' + nestedIndent + query + indent + ')')
			|	Field
			|	ReferencedField
			|	Number
			|	Boolean
			|	Value
			|	Bind,
			
		
		RuleBody :indent =
				Comparator(indent)
			|	Not(indent)
			|	Exists(indent)
			|	Comparison(indent)
			|	Between(indent)
			|	And(indent),
		
		Process =
			RuleBody('\n'):ruleBody
			-> ('SELECT ' + ruleBody + ' AS "result";')
	}
	
	AbstractSQLRules2SQL.initialize = function() {
		this.fieldOrderings = [];
	}
	
	return AbstractSQLRules2SQL;
});