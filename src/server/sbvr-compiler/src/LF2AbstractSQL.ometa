define(['sbvr-parser/SBVRLibs', 'underscore', 'ometa/ometa-base'], function(SBVRLibs, _) {
	var LF2AbstractSQL;
	//Transformation from SBVR Logical Formulation to SQL

	ometa LF2AbstractSQL <: SBVRLibs {
		
		/** Terms **/
		TermName =
			:termName {this.terms[termName] = termName}
			(	?(!this.tables.hasOwnProperty(termName))
			|	{console.error('We already have a term with a name of: ' + termName)} ?(false)
			)
			{this.tables[termName] = {fields:[], primitive: false, name: null, idField: null}}
			-> termName,
		Attributes :tableID =
			[(
				[ :attributeName ApplyFirstExisting(['Attr' + attributeName, 'DefaultAttr'], [tableID]):attributeValue ]
			)*],
		DefaultAttr :tableID =
			:anything
			{console.log('Default', tableID, anything)},
		AttrConceptType :termName = // tableID will be same as termName for ConceptType (fact types cannot have a concept type)
			['Term' :conceptType] {this.conceptTypes[termName] = conceptType}
			IsPrimitive(conceptType):primitive
			{['ConceptType', this.tables[conceptType].name, 'NOT NULL', this.tables[conceptType].idField]}:field
			(	?(primitive !== false && conceptType === primitive)
				{field[0] = primitive}
				// Find existing name field and remove it if it exists.
				(	{this.tables[termName]}:table
					?(table.hasOwnProperty('valueField'))
					GetTableFieldID(table, table.valueField):fieldID
					?(fieldID !== false)
					{field[1] = table.fields[fieldID][1]}
					{table.fields.splice(fieldID, 1)}
				|	{table.valueField = this.tables[conceptType].name}
				)
			)?
			{this.tables[termName].fields.push(field)},
		AttrDatabaseIDField :tableID =
			:idField
			{this.tables[this.GetResourceName(tableID)]}:table
			(	?_.isString(table)
			|	{table.fields.push(['Serial', idField, 'PRIMARY KEY'])}
				{table.idField = idField}
			),
		AttrDatabaseValueField :tableID =
			:valueField
			{this.tables[this.GetResourceName(tableID)]}:table
			(	?_.isString(table)
			|	// Find existing name field and update it if it exists.
				(	?(table.hasOwnProperty('valueField'))
					GetTableFieldID(table, table.valueField):fieldID
					?(fieldID !== false)
					{table.fields[fieldID][1] = valueField}
				|	// Add a name field if there isn't one already to rename.
					{table.fields.push(['Value', valueField, 'NOT NULL'])}
				)
				{table.valueField = valueField}
			),
		AttrDatabaseTableName :tableID =
			:tableName
			{this.tables[this.GetResourceName(tableID)]}:table
			(	?_.isString(table)
			|	{table.name = tableName}
			),
		AttrDatabasePrimitive :termName =
			:attrVal
			{this.tables[termName].primitive = attrVal},
		AttrDatabaseAttribute :factType =
			:attrVal
			(	?attrVal
				{this.tables[this.GetResourceName(factType)] = 'Attribute'}
				GetTableFieldID(this.tables[factType[0][1]], this.tables[factType[2][1]].name):fieldID
				{this.tables[factType[0][1]].fields[fieldID][0] = this.tables[factType[2][1]].primitive}
			)?,
		AttrForeignKey :factType =
			:type
			(	?(this.tables[factType[0][1]].valueField == this.tables[factType[2][1]].name
					|| this.tables[factType[0][1]].idField == this.tables[factType[2][1]].name)
				// If the value field for the first term matches the name of the FK term then update the value field to be a FK.
				GetTableFieldID(this.tables[factType[0][1]], this.tables[factType[2][1]].name):fieldID
				?(fieldID !== false)
				{this.tables[factType[0][1]].fields[fieldID][0] = 'ForeignKey'}
			|	{this.tables[factType[0][1]].fields.push(['ForeignKey', this.tables[factType[2][1]].name, type, this.tables[factType[2][1]].idField])}
			)
			{this.tables[this.GetResourceName(factType)] = 'ForeignKey'},
		// AttrSynonym :term =
			// :synonym {this.terms[synonym[1]] = term[1]},
		AttrSynonymousForm :factType =
			:synForm
			AddFactType(synForm.slice(0, -1), factType),
		AttrTermForm :factType =
			:term
			{this.terms[term[1]] = factType}
			{this.tables[term[1]] = this.tables[this.GetResourceName(factType)]},
			
			
		
		/** Fact Types **/
		FactType =
			&((:factTypePart &(:attributes) -> factTypePart)+:factType)
			AddFactType(factType, factType)
			{this.GetResourceName(factType)}:resourceName
			(	?(factType.length == 2)
				// Eat input
				(:factTypePart &(:attributes))+
				
				{this.tables[factType[0][1]].fields.push(['Boolean', factType[1][1]])}
				{this.tables[resourceName] = 'BooleanAttribute'}
			|	{this.tables[resourceName] = {fields:[], primitive: false, name: null}}
				(	['Term' :termName]
					{this.tables[resourceName].fields.push(['ForeignKey', this.tables[termName].name, 'NOT NULL', this.tables[termName].idField])}
				|	['Verb' :verb]
				)+
			)
			-> factType,
		
		Cardinality =
			[
				(	'MinimumCardinality'
				|	'MaximumCardinality'
				|	'Cardinality'
				)
				Number:cardinality
			]
			-> cardinality,
		Number =
			[	'Number'
				:num ?{!isNaN(num)}
			]
			-> num,
		Variable =
			[	'Variable'
				Number:bind
				['Term' :termName]
				{'var' + bind}:varAlias
				{['SelectQuery', ['Select', []], ['From', this.tables[termName].name, varAlias + termName]]}:query
				ResolveConceptTypes(query, termName, varAlias)
				(	
					(	RulePart:whereBody
						AddWhereClause(query, whereBody)
					)
				)?
			]
			(	RulePart:whereBody
				AddWhereClause(query, whereBody)
			)
			-> query,
		
		RoleBinding =
			[	'RoleBinding'
				['Term' :termName]
				:bind
			]
			-> [termName, bind],

		LinkTable :actualFactType :rootTerms =
			{'link' + this.linkTableBind++}:tableAlias
			{['SelectQuery', ['Select', []], ['From', this.tables[this.GetResourceName(actualFactType)].name, tableAlias]]}:query
			{0}:i
			(	?(i < rootTerms.length)
				RoleBinding:bind
				{rootTerms[i]}:termName
				AddWhereClause(query, ['Equals', ['ReferencedField', tableAlias, this.tables[termName].name], ['ReferencedField', 'var' + bind[1] + termName, this.tables[termName].idField]])
				{i++}
			)+
			-> ['Exists', query],
		
		ForeignKey :actualFactType :rootTerms =
			?(this.tables[this.GetResourceName(actualFactType)] == 'ForeignKey')
			(	RoleBinding:bindFrom
				RoleBinding:bindTo
				end
				(	?this.IsChild(bindFrom[0], actualFactType[0])
					{rootTerms[0]}:termFrom
					{rootTerms[1]}:termTo
				|	{bindTo}:temp
					{bindFrom}:bindTo
					{temp}:bindFrom
					{rootTerms[1]}:termFrom
					{rootTerms[0]}:termTo
				)
			|	___ForeignKeyMatchingFailed___.die
			)
			-> ['Equals', ['ReferencedField', 'var' + bindFrom[1] + termFrom, this.tables[termTo].name], ['ReferencedField', 'var' + bindTo[1] + termTo, this.tables[termTo].idField]],

		BooleanAttribute :actualFactType =
			?(this.tables[this.GetResourceName(actualFactType)] == 'BooleanAttribute')
			(	RoleBinding:bindFrom
				end
				{actualFactType[0][1]}:termFrom
				{actualFactType[1][1]}:attributeName
			|	{console.error(this.input)}
				___BooleanAttributeMatchingFailed___.die
			)
			-> ['Equals', ['ReferencedField', 'var' + bindFrom[1] + termFrom, attributeName], ['Boolean', true]],

		Attribute :actualFactType :rootTerms =
			?(this.tables[this.GetResourceName(actualFactType)] == 'Attribute')
			{['SelectQuery', ['Select', []]]}:query
			RoleBinding:bindReal
			RoleBinding:bindAttr
			end
			(	?this.IsChild(bindReal[0], actualFactType[0])
				{rootTerms[0]}:termNameReal
				{rootTerms[1]}:termNameAttr
			|	{bindAttr}:temp
				{bindReal}:bindAttr
				{temp}:bindReal
				{rootTerms[1]}:termNameReal
				{rootTerms[0]}:termNameAttr
			)
			AddWhereClause(query, ['Equals', ['ReferencedField', 'var' + bindAttr[1] + termNameReal, this.tables[termNameAttr].name], ['ReferencedField', 'var' + bindReal[1] + termNameReal, this.tables[termNameAttr].name]])
			-> ['Exists', query],
		
		AtomicFormulation =
			[	'AtomicFormulation'
				['FactType' anything+:factType]
				ActualFactType(factType):actualFactType
				FactTypeRootTerms(factType, actualFactType):rootTerms
				(	ForeignKey(actualFactType, rootTerms)
				|	BooleanAttribute(actualFactType)
				|	Attribute(actualFactType, rootTerms)
				|	LinkTable(actualFactType, rootTerms)
				):whereClause
			]
			-> whereClause,
		AtLeast =
			[	'AtLeastNQ'
				Cardinality:minCard
				Variable:query
				{query[1][1].push(['Count', '*'])}
			]
			-> ['EqualOrGreater', query, ['Number', minCard]],
		Exactly =
			[	'ExactQ'
				Cardinality:card
				Variable:query
				{query[1][1].push(['Count', '*'])}
			]
			-> ['Equals', query, ['Number', card]],
		Range =
			[	'NumericalRangeQ'
				Cardinality:minCard
				Cardinality:maxCard
				Variable:query
				{query[1][1].push(['Count', '*'])}
			]
			-> ['Between', query, ['Number', minCard], ['Number', maxCard]],
		Exists =
			[	'ExistentialQ'
				Variable:query
			]
			-> ['Exists', query],
		Negation =
			[	'LogicalNegation'
				RulePart:whereBody
			]
			-> ['Not', whereBody],
			
		
		RulePart =
			(	AtomicFormulation
			|	AtLeast
			|	Exactly
			|	Exists
			|	Negation
			|	Range
			|	:x {console.error('Hit unhandled operation:', x)} ?(false)
			):whereBody
			-> whereBody,
		
		RuleBody =
			[
				(	'ObligationF'
				|	'NecessityF'
				|	'PossibilityF'
				|	'PermissibilityF'
				)
				RulePart:rule
			]
			-> rule,
		
		Process =
			[	'Model'
				(
					[	'Term' TermName:termName Attributes(termName)
					|	'FactType' FactType:factType Attributes(factType)
					|	'Rule' RuleBody:ruleBody ['StructuredEnglish' :ruleText]
						{this.linkTableBind = 0}
						{this.rules.push(['Rule', ['StructuredEnglish', ruleText], ['Body', ruleBody]])}
					]
				)+
			]
			{{}}:tables
			-> {tables:this.tables, rules:this.rules}
	}
	
	LF2AbstractSQL.AddWhereClause = function(query, whereBody) {
		// TODO: Move this to an optimisation pass?
		// Check if it's a place where we can do a join optimisation.
		if(whereBody[0] == 'Exists' && (
				whereBody[1][0] == 'SelectQuery' || whereBody[1][0] == 'InsertQuery' ||
				whereBody[1][0] == 'UpdateQuery' || whereBody[1][0] == 'UpsertQuery')) {
			whereBody = whereBody[1].slice(1);
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'From') {
					query.push(whereBody[i]);
				}
			}
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'Where') {
					this.AddWhereClause(query, whereBody[i][1]);
				}
			}
		}
		else {
			for(var i=1; i < query.length; i++) {
				if(query[i][0] == 'Where') {
					query[i][1] = ['And', query[i][1], whereBody];
					return;
				}
			}
			query.push(['Where', whereBody]);
		}
	}
	
	LF2AbstractSQL.ResolveConceptTypes = function(query, termName, varAlias) {
		var conceptAlias,
			parentAlias = varAlias + termName,
			conceptName = termName;
		while(this.conceptTypes.hasOwnProperty(conceptName)) {
			conceptName = this.conceptTypes[termName];
			conceptAlias = varAlias + conceptName;
			{query.push(['From', this.tables[conceptName].name, conceptAlias])}
			this.AddWhereClause(query, ['Equals', ['ReferencedField', parentAlias, this.tables[conceptName].name], ['ReferencedField', conceptAlias, this.tables[conceptName].idField]])
			parentAlias = conceptAlias;
		}
	}
	
	LF2AbstractSQL.initialize = function() {
		SBVRLibs.initialize.call(this);
		this.tables = {};
		this.terms = {}; // TODO: Is this needed?
		this.rules = [];
		this.linkTableBind = 0;
	}

	
	return LF2AbstractSQL;
});