define(['sbvr-parser/SBVRLibs', 'underscore', 'ometa/ometa-base'], function(SBVRLibs, _) {
	var ServerURIParser;
	ometa ServerURIParser <: SBVRLibs {
		Process =
			[	(	'GET'
				|	'PUT'
				|	'POST'
				|	'DELETE'
				):method
				{this.currentMethod = method}
				anything:body
				(	?(!_.isArray(body))
					{[{}]}:body
				)?
				[	'/' Vocabulary:vocab '/'?
					{this.currentVocab = vocab}
					{['URI', ['Vocabulary', vocab]]}:uri
					{[]}:resources
					{0}:i
					(	{	for(;i<body.length;i++) {
								this.currentBody = body[i];
								if(i<body.length-1) {
									this._lookahead(function() {
										resources.push(this._apply('Resource'));
									});
								}
								else {
									resources.push(this._apply('Resource'));
								}
							}
						}
					)?
					'/'?
				]
			]
			-> uri.concat(resources),

		Vocabulary =
			<	(	~'/'
					anything
				)+
			>,

		ResourcePart =
			<	(	letter
				|	'_'
				)+
			>:resourcePart
			-> resourcePart.replace(new RegExp('_', 'g'), ' '),

		Term =
			ResourcePart:term
			-> ['Term', term],
		Verb =
			ResourcePart:verb
			-> ['Verb', verb],

		TermOrFactType =
			<	Term:term
				{[term]}:factType
				(	'-'
					Verb:verb {factType.push(verb)}
					(	'-'
						Term:term
						{factType.push(term)}
					)?
				)*
			>:resourceName
			(	?verb
				-> factType
			|	-> term[1]
			):tableName
			-> {resourceName: resourceName, tableName: tableName},

		Resource =
			TermOrFactType:resourceInfo
			(	(	?(this.currentMethod != 'GET')
				|	&'*'
				)
				{['Query']}:query
				AddQueryResource(query, resourceInfo.tableName, resourceInfo.resourceName)
				Modifiers(query)
				'*'?
			)?
			-> {resourceName: resourceInfo.resourceName, query: query, values: this.newBody},

		Comparator =
				'='
				-> 'Equals'
			|	seq('!=')
				-> 'NotEquals'
			|	'~'
				-> 'Like',

		Modifiers :query =
			(	Filters(query)
			|	Sorts:sorts
				{query.push(sorts)}
			)*,

		Field =
				ResourcePart:table '.' ResourcePart:field
				-> ['ReferencedField', table, field]
			|	ResourcePart:field
				-> ['Field', field],

		Filters :query =
			seq('*filt:')
			(	Field:field
				Comparator:comparator
				<	(	~ValueBreak
						anything
					)+
				>:value
				';'?
				(	?(field[0] == 'ReferencedField')
					{field[1]}:resourceName
					{field[2]}:resourceFieldName
				|	{this.currentResource}:resourceName
					{field[1]}:resourceFieldName
				)
				{this.clientModels[this.currentVocab].resourceToSQLMappings[resourceName][resourceFieldName]}:mapping
				AddWhereClause(query, [comparator, field, ['Bind', mapping[0], this.GetTableField(this.sqlModels[this.currentVocab].tables[mapping[0]], mapping[1])]])
				AddBodyVar(resourceName, resourceFieldName, mapping, value)
				AddQueryTable(query, mapping[0])
			)+,

		Sorts =
			seq('*sort:')
			(	';'?
				Field:field
				'='
				(	seq('ASC')
				|	seq('DESC')
				):direction
				-> [direction, field]
			)+:sorts
			->	['OrderBy'].concat(sorts),

		ValueBreak =
			(	';'
			|	'*'
			|	'/'
			)
	}
	
	ServerURIParser.initialize = function() {
		this.sqlModels = {};
		this.clientModels = {};
		this.currentVocab = '';
		this.currentMethod = '';
		this.currentBody = [];
		this.newBody = [];
		this.currentResource = null;
	};
	
	ServerURIParser.setSQLModel = function(vocab, model) {
		this.sqlModels[vocab] = model;
	};
	
	ServerURIParser.setClientModel = function(vocab, model) {
		this.clientModels[vocab] = model;
	};
	
	ServerURIParser.AddWhereClause = function(query, whereBody) {
		// TODO: Move this to an optimisation pass?
		// Check if it's a place where we can do a join optimisation.
		if(whereBody[0] == 'Exists' && (
				whereBody[1][0] == 'SelectQuery' || whereBody[1][0] == 'InsertQuery' ||
				whereBody[1][0] == 'UpdateQuery' || whereBody[1][0] == 'UpsertQuery')) {
			whereBody = whereBody[1].slice(1);
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'From') {
					query.push(whereBody[i]);
				}
			}
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'Where') {
					this.AddWhereClause(query, whereBody[i][1]);
				}
			}
		}
		else {
			for(var i=1; i < query.length; i++) {
				if(query[i][0] == 'Where') {
					query[i][1] = ['And', query[i][1], whereBody];
					return;
				}
			}
			query.push(['Where', whereBody]);
		}
		
		if(query[0] == 'UpsertQuery' && whereBody[0] == 'Equals') {
			var field, value;
			if(whereBody[1][0] == 'Field') {
				field = whereBody[1][1];
			}
			else if(whereBody[1][0] == 'ReferencedField') {
				field = whereBody[1][2];
			}
			else if(whereBody[2][0] == 'Field') {
				field = whereBody[2][1];
			}
			else if(whereBody[2][0] == 'ReferencedField') {
				field = whereBody[2][2];
			}
			
			if(whereBody[1][0] == 'Bind') {
				bind = whereBody[1];
			}
			else if(whereBody[2][0] == 'Bind') {
				bind = whereBody[2];
			}
			
			for(var i=1; i < query.length; i++) {
				var queryPart = query[i];
				if(queryPart[0] == 'Fields') {
					for(var j=0; j < queryPart[1].length; j++) {
						var queryFields = queryPart[1][j];
						if(queryFields[0] == field) {
							// Update the value field for the query
							queryFields[1] = bind;
							break;
						}
					}
					if(j === queryPart[1].length) {
						// We need to add it to field and values list of query.
						queryPart[1].push([field, bind]);
					}
					break;
				}
			}
		}
	};

	ServerURIParser.AddBodyVar = function(resourceName, resourceFieldName, mapping, value) {
		if(value === undefined) {
			if(this.currentBody.hasOwnProperty(resourceName + '.' + resourceFieldName)) {
				value = this.currentBody[resourceName + '.' + resourceFieldName];
			}
			else if(this.currentBody.hasOwnProperty(resourceFieldName)) {
				value = this.currentBody[resourceFieldName];
			}
			else {
				return;
			}
		}
		return this.newBody[mapping.join('.')] = value;
	}

	ServerURIParser.AddQueryTable = function(query, tableName) {
		var i = 0;
		for(;i < query.length; i++) {
			if(query[i][0] === 'From' && query[i][1] === tableName) {
				return;
			}
		}
		query.push(['From', tableName]);
	}

	ServerURIParser.AddQueryResource = function(query, termOrFactType, resourceName) {
		var newValue, fieldName, value, fields, i, field, mapping, resourceField, resourceFieldName, self = this,
			clientModel = this.clientModels[this.currentVocab],
			resourceModel = clientModel.resources[resourceName],
			resourceToSQLMappings = clientModel.resourceToSQLMappings[resourceName],
			sqlTables = this.sqlModels[this.currentVocab].tables,
			table = sqlTables[resourceName],
			getSelectFields = function() {
				var mapping, resourceField, fields = [];
				for(resourceField in resourceToSQLMappings) {
					if(resourceToSQLMappings.hasOwnProperty(resourceField)) {
						mapping = resourceToSQLMappings[resourceField];
						self.AddQueryTable(query, mapping[0]);
						fields.push([['ReferencedField'].concat(mapping), resourceField]);
					}
				}
				return fields;
			};
		this.currentResource = resourceName;
		switch(table) {
			case 'ForeignKey':
				__TODO__.die();
			break;
			case 'Attribute':
				// The attribute is value field
				resourceFieldName = resourceModel.valueField;
				mapping = resourceToSQLMappings[resourceFieldName];
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'UpdateQuery';
						this.AddQueryTable(query, mapping[0]);
						query.push(['Fields', [[mapping[1], 'NULL']]]);
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', getSelectFields()]);
					break;
					case 'PUT':
					case 'POST':
						query[0] = 'UpdateQuery';
						if(this.AddBodyVar(resourceName, resourceFieldName, mapping) !== undefined) {
							this.AddQueryTable(query, mapping[0]);
							query.push(['Fields', [[mapping[0], ['Bind', mapping[0], this.GetTableField(sqlTables[mapping[0]], mapping[1])]]]]);
						}
					break;
				}
			break;
			case 'BooleanAttribute':
				// The attribute is value field
				resourceFieldName = resourceModel.valueField;
				mapping = resourceToSQLMappings[resourceFieldName];
				switch(this.currentMethod) {
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', getSelectFields()]);
						this.AddQueryTable(query, mapping[0]);
						this.AddWhereClause(query, ['Equals', ['ReferencedField'].concat(mapping), ['Boolean', true]]);
					break;
					case 'DELETE':
						newValue = false;
						// Fallthrough
					case 'PUT':
					case 'POST':
						if(newValue == null) {
							newValue = true;
						}
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[mapping[1], newValue]]]);
						this.AddQueryTable(query, mapping[0]);
						resourceFieldName = resourceModel.idField;
						mapping = resourceToSQLMappings[resourceFieldName];
						fieldName = mapping[1];
						if(this.AddBodyVar(resourceName, resourceFieldName, mapping) !== undefined) {
							this.AddQueryTable(query, mapping[0]);
							this.AddWhereClause(query, ['Equals', ['ReferencedField'].concat(mapping), ['Bind', mapping[0], this.GetTableField(sqlTables[mapping[0]], mapping[1])]]);
						}
					break;
				}
			break;
			default:
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'DeleteQuery';
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', getSelectFields()]);
					break;
					case 'PUT':
					case 'POST':
						if(this.currentMethod === 'PUT') {
							query[0] = 'UpsertQuery';
						}
						else {
							query[0] = 'InsertQuery';
						}
						fields = [];
						for(resourceFieldName in resourceToSQLMappings) {
							if(resourceToSQLMappings.hasOwnProperty(resourceFieldName)) {
								mapping = resourceToSQLMappings[resourceFieldName];
								if(this.AddBodyVar(resourceName, resourceFieldName, mapping) !== undefined) {
									this.AddQueryTable(query, mapping[0]);
									fields.push([mapping[1], ['Bind', mapping[0], this.GetTableField(sqlTables[mapping[0]], mapping[1])] ]);
								}
							}
						}
						query.push(['Fields', fields]);
					break;
				}
				// All good.
			break;
		}
	};

	return ServerURIParser;
});