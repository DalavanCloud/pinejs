define(['sbvr-parser/SBVRLibs', 'underscore', 'ometa/ometa-base'], function(SBVRLibs, _) {
	var ServerURIParser;
	ometa ServerURIParser <: SBVRLibs {
		Process =
			[	(	'GET'
				|	'PUT'
				|	'POST'
				|	'DELETE'
				):method
				{this.currentMethod = method}
				anything:body
				(	?(!_.isArray(body))
					{[{}]}:body
				)?
				[	'/' Vocabulary:vocab '/'?
					{this.currentVocab = vocab}
					{['URI', ['Vocabulary', vocab]]}:uri
					{[]}:resources
					{0}:i
					(	{	for(;i<body.length;i++) {
								this.currentBody = body[i];
								if(i<body.length-1) {
									this._lookahead(function() {
										resources.push(this._apply('Resource'));
									});
								}
								else {
									resources.push(this._apply('Resource'));
								}
							}
						}
					)?
					'/'?
				]
			]
			-> uri.concat(resources),

		Vocabulary =
			<	(	~'/'
					anything
				)+
			>,

		ResourcePart =
			<	(	letter
				|	'_'
				)+
			>:resourcePart
			-> resourcePart.replace(new RegExp('_', 'g'), ' '),

		Term =
			ResourcePart:term
			-> ['Term', term],
		Verb =
			ResourcePart:verb
			-> ['Verb', verb],

		TermOrFactType =
			<	Term:term
				{[term]}:factType
				(	'-'
					Verb:verb {factType.push(verb)}
					(	'-'
						Term:term
						{factType.push(term)}
					)?
				)*
			>:resourceName
			(	?verb
				-> factType
			|	-> term[1]
			):tableName
			-> {resourceName: resourceName, tableName: tableName},

		Resource =
			{['Query']}:query
			TermOrFactType:resourceInfo
			AddQueryTable(query, resourceInfo.tableName)
			Modifiers(query)
			-> {resourceName: resourceInfo.resourceName, query: query, values: this.currentBody},

		Comparator =
				'='
				-> 'Equals'
			|	seq('!=')
				-> 'NotEquals'
			|	'~'
				-> 'Like',

		Modifiers :query =
			(	Filters(query)
			|	Sorts:sorts
				{query.push(sorts)}
			)*,

		Field =
				ResourcePart:table '.' ResourcePart:field
				-> ['ReferencedField', table, field]
			|	ResourcePart:field
				-> ['Field', field],

		Filters :query =
			seq('*filt:')
			(	Field:field
				Comparator:comparator
				<	(	~ValueBreak
						anything
					)+
				>:value
				';'?
				(	?(field[0] == 'ReferencedField')
					{this.sqlModels[this.currentVocab].tables[field[1]]}:table
					{field[2]}:fieldName
				|	{this.currentTable}:table
					{field[1]}:fieldName
				)
				AddWhereClause(query, [comparator, field, ['Bind', table.name, this.GetTableField(table, fieldName)]])
				{this.currentBody[table.name + '.' + fieldName] = value}
			)+,

		Sorts =
			seq('*sort:')
			(	';'?
				Field:field
				'='
				(	seq('ASC')
				|	seq('DESC')
				):direction
				-> [direction, field]
			)+:sorts
			->	['OrderBy'].concat(sorts),

		ValueBreak =
			(	';'
			|	'*'
			|	'/'
			)
	}
	
	ServerURIParser.initialize = function() {
		this.sqlModels = {}
		this.currentVocab = '';
		this.currentMethod = '';
		this.currentBody = [];
		this.currentTable = null;
	};
	
	ServerURIParser.setSQLModel = function(vocab, model) {
		this.sqlModels[vocab] = model;
	};
	
	ServerURIParser.AddWhereClause = function(query, whereBody) {
		// TODO: Move this to an optimisation pass?
		// Check if it's a place where we can do a join optimisation.
		if(whereBody[0] == 'Exists' && (
				whereBody[1][0] == 'SelectQuery' || whereBody[1][0] == 'InsertQuery' ||
				whereBody[1][0] == 'UpdateQuery' || whereBody[1][0] == 'UpsertQuery')) {
			whereBody = whereBody[1].slice(1);
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'From') {
					query.push(whereBody[i]);
				}
			}
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'Where') {
					this.AddWhereClause(query, whereBody[i][1]);
				}
			}
		}
		else {
			for(var i=1; i < query.length; i++) {
				if(query[i][0] == 'Where') {
					query[i][1] = ['And', query[i][1], whereBody];
					return;
				}
			}
			query.push(['Where', whereBody]);
		}
		
		if(query[0] == 'UpsertQuery' && whereBody[0] == 'Equals') {
			var field, value;
			if(whereBody[1][0] == 'Field') {
				field = whereBody[1][1];
			}
			else if(whereBody[1][0] == 'ReferencedField') {
				field = whereBody[1][2];
			}
			else if(whereBody[2][0] == 'Field') {
				field = whereBody[2][1];
			}
			else if(whereBody[2][0] == 'ReferencedField') {
				field = whereBody[2][2];
			}
			
			if(whereBody[1][0] == 'Bind') {
				bind = whereBody[1];
			}
			else if(whereBody[2][0] == 'Bind') {
				bind = whereBody[2];
			}
			
			for(var i=1; i < query.length; i++) {
				var queryPart = query[i];
				if(queryPart[0] == 'Fields') {
					for(var j=0; j < queryPart[1].length; j++) {
						var queryFields = queryPart[1][j];
						if(queryFields[0] == field) {
							// Update the value field for the query
							queryFields[1] = bind;
							break;
						}
					}
					if(j === queryPart[1].length) {
						// We need to add it to field and values list of query.
						queryPart[1].push([field, bind]);
					}
					break;
				}
			}
		}
	};
	
	ServerURIParser.AddQueryTable = function(query, termOrFactType) {
		var tables = this.sqlModels[this.currentVocab].tables;
		var table = tables[termOrFactType];
		switch(table) {
			case 'ForeignKey':
				__TODO__.die();
			break;
			case 'Attribute':
				table = tables[termOrFactType[0][1]];
				attributeName = termOrFactType[1][1];
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[attributeName, 'NULL']]]);
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', ['*']]);
					break;
					case 'PUT':
					case 'POST':
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[attributeName, ['Bind', table.name, this.GetTableField(table, attributeName)]]]]);
					break;
				}
				query.push(['From', table.name])
			break;
			case 'BooleanAttribute':
				// Return table for the term.
				table = tables[termOrFactType[0][1]];
				attributeName = termOrFactType[1][1];
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[attributeName, false]]]);
						// TODO: This should be added by checking the body.
						this.AddWhereClause(query, ['Equals', ['Field', table.idField], ['Bind', table.name, this.GetTableField(table, table.idField)]]);
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', ['*']]);
					break;
					case 'PUT':
					case 'POST':
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[attributeName, true]]]);
						// TODO: This should be added by checking the body.
						this.AddWhereClause(query, ['Equals', ['Field', table.idField], ['Bind', table.name, this.GetTableField(table, table.idField)]]);
					break;
				}
				query.push(['From', table.name])
				switch(this.currentMethod) {
					case 'GET':
					case 'DELETE':
						this.AddWhereClause(query, ['Equals', ['Field', attributeName], ['Boolean', true]])
				}
			break;
			default:
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'DeleteQuery';
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', ['*']]);
					break;
					case 'PUT':
					case 'POST':
						if(this.currentMethod == 'PUT') {
							query[0] = 'UpsertQuery';
						}
						else {
							query[0] = 'InsertQuery';
						}
						var fields = [];
						for(var i=0; i < table.fields.length; i++) {
							var field = table.fields[i],
								fieldName = field[1];
							if((field[2] == 'NOT NULL' || this.currentBody.hasOwnProperty(table.name + '.' + fieldName) || this.currentBody.hasOwnProperty(fieldName))
								|| (field[2] == 'PRIMARY KEY' && field[0] != 'Serial')) {
								fields.push([fieldName, ['Bind', table.name, field]]);
							}
						}
						query.push(['Fields', fields]);
					break;
				}
				query.push(['From', table.name])
				// All good.
			break;
		}
		this.currentTable = table;
	};

	return ServerURIParser;
});