define(['sbvr-parser/SBVRLibs', 'underscore', 'ometa/ometa-base'], function(SBVRLibs, _) {
	var ServerURIParser;
	ometa ServerURIParser <: SBVRLibs {
		Process =
			[	(	'GET'
				|	'PUT'
				|	'POST'
				|	'DELETE'
				):method
				{this.currentMethod = method}
				anything:body
				(	?(!_.isArray(body))
					{console.error('Body is not an array:', body)}
					{[{}]}:body
				)?
				[	'/' Vocabulary:vocab '/'?
					{this.currentVocab = vocab}
					{['URI', ['Vocabulary', vocab]]}:uri
					{[]}:resources
					{0}:i
					{	for(;i<body.length;i++) {
							this.currentBody = body[i];
							if(i<body.length-1) {
								this._lookahead(function() {
									resources.push(this._apply('Resource'));
								});
							}
							else {
								resources.push(this._apply('Resource'));
							}
						}
					}
					'/'?
				]
			]
			-> uri.concat(resources),

		Vocabulary =
			<	(	~'/'
					anything
				)+
			>,

		ResourcePart =
			<	(	letter
				|	'_'
				)+
			>:resourcePart
			-> resourcePart.replace(new RegExp('_', 'g'), ' '),

		Term =
			ResourcePart:term
			-> ['Term', term],
		Verb =
			ResourcePart:verb
			-> ['Verb', verb],

		TermOrFactType :query =
			Term:term
			{[term]}:factType
			(	'-'
				Verb:verb {factType.push(verb)}
				(	'-'
					Term:term
					{factType.push(term)}
				)?
			)*
			(	?verb
				AddQueryTable(query, factType)
			|	AddQueryTable(query, term[1])
			),

		Resource =
			{['Query']}:query
			TermOrFactType(query):fields
			Modifiers(query, fields)
			-> [query].concat(fields),

		Comparator =
				'='
				-> 'Equals'
			|	seq('!=')
				-> 'NotEquals'
			|	'~'
				-> 'Like',

		Modifiers :query :fields =
			(	Filters(query, fields)
			|	Sorts:sorts
				{query.push(sorts)}
			)*,

		Field =
				ResourcePart:table '.' ResourcePart:field
				-> ['ReferencedField', table, field]
			|	ResourcePart:field
				-> ['Field', field],

		Filters :query :fields =
			seq('*filt:')
			(	Field:field
				Comparator:comparator
				<	(	~ValueBreak
						anything
					)+
				>:value
				';'?
				AddWhereClause(query, [comparator, field, ['Value', value]], fields)
			)+,

		Sorts =
			seq('*sort:')
			(	';'?
				Field:field
				'='
				(	seq('ASC')
				|	seq('DESC')
				):direction
				-> [direction, field]
			)+:sorts
			->	['OrderBy'].concat(sorts),

		ValueBreak =
			(	';'
			|	'*'
			|	'/'
			)
	}
	
	ServerURIParser.initialize = function() {
		this.sqlModels = {}
		this.currentVocab = '';
		this.currentMethod = '';
		this.currentBody = [];
	};
	
	ServerURIParser.setSQLModel = function(vocab, model) {
		this.sqlModels[vocab] = model;
	};
	
	ServerURIParser.AddWhereClause = function(query, whereBody, fields) {
		// TODO: Move this to an optimisation pass?
		// Check if it's a place where we can do a join optimisation.
		if(whereBody[0] == 'Exists' && (
				whereBody[1][0] == 'SelectQuery' || whereBody[1][0] == 'InsertQuery' ||
				whereBody[1][0] == 'UpdateQuery' || whereBody[1][0] == 'UpsertQuery')) {
			whereBody = whereBody[1].slice(1);
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'From') {
					query.push(whereBody[i]);
				}
			}
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'Where') {
					this.AddWhereClause(query, whereBody[i][1], fields);
				}
			}
		}
		else {
			for(var i=1; i < query.length; i++) {
				if(query[i][0] == 'Where') {
					query[i][1] = ['And', query[i][1], whereBody];
					return;
				}
			}
			query.push(['Where', whereBody]);
		}
		
		if(query[0] == 'UpsertQuery' && whereBody[0] == 'Equals') {
			var field, value;
			if(whereBody[1][0] == 'Field') {
				field = whereBody[1][1];
			}
			else if(whereBody[1][0] == 'ReferencedField') {
				field = whereBody[1][2];
			}
			else if(whereBody[2][0] == 'Field') {
				field = whereBody[2][1];
			}
			else if(whereBody[2][0] == 'ReferencedField') {
				field = whereBody[2][2];
			}
			
			if(whereBody[1][0] == 'Value') {
				value = whereBody[1][1];
			}
			else if(whereBody[2][0] == 'Value') {
				value = whereBody[2][1];
			}
			
			for(var i=1; i < query.length; i++) {
				var queryPart = query[i];
				if(queryPart[0] == 'Fields') {
					for(var j=0; j < queryPart[1].length; j++) {
						var queryFields = queryPart[1][j];
						if(queryFields[0] == field) {
							// Update the value field for the query
							queryFields[1] = value;
							for(var k=0; k < fields[0].length; k++) {
								// If the field we just set is in bind fields then remove it.
								if(fields[0][k][1] == field) {
									fields[0].splice(k, 1);
									break;
								}
							}
							break;
						}
					}
					if(j === queryPart[1].length) {
						// We need to add it to field and values list of query.
						queryPart[1].push([field, value]);
					}
					break;
				}
			}
		}
	};
	
	ServerURIParser.AddQueryTable = function(query, termOrFactType) {
		var tables = this.sqlModels[this.currentVocab].tables;
		var table = tables[termOrFactType];
		var fieldOrdering = [];
		console.log(termOrFactType, table, this.sqlModels[this.currentVocab]);
		switch(table) {
			case 'ForeignKey':
				__TODO__.die();
			break;
			case 'Attribute':
				table = tables[termOrFactType[0][1]];
				attributeName = termOrFactType[1][1];
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[attributeName, 'NULL']]]);
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', ['*']]);
					break;
					case 'PUT':
					case 'POST':
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[attributeName, '?']]]);
						fieldOrdering.push(this.GetTableField(table, attributeName))
					break;
				}
				query.push(['From', table.name])
			break;
			case 'BooleanAttribute':
				// Return table for the term.
				table = tables[termOrFactType[0][1]];
				attributeName = termOrFactType[1][1];
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[attributeName, false]]]);
						// TODO: This should be added by checking the body.
						this.AddWhereClause(query, ['Equals', ['Field', table.idField], ['Bind']])
						var field = this.GetTableField(table, table.idField);
						fieldOrdering.push([field[0], table.name, field[1]]);
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', ['*']]);
					break;
					case 'PUT':
					case 'POST':
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[attributeName, true]]]);
						// TODO: This should be added by checking the body.
						this.AddWhereClause(query, ['Equals', ['Field', table.idField], ['Bind']])
						var field = this.GetTableField(table, table.idField);
						fieldOrdering.push([field[0], table.name, field[1]]);
					break;
				}
				query.push(['From', table.name])
				switch(this.currentMethod) {
					case 'GET':
					case 'DELETE':
						this.AddWhereClause(query, ['Equals', ['Field', attributeName], ['Boolean', true]])
				}
			break;
			default:
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'DeleteQuery';
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', ['*']]);
					break;
					case 'PUT':
					case 'POST':
						if(this.currentMethod == 'PUT') {
							query[0] = 'UpsertQuery';
						}
						else {
							query[0] = 'InsertQuery';
						}
						var fields = [];
						for(var i=0; i < table.fields.length; i++) {
							var field = table.fields[i];
							if(field[2] == 'NOT NULL' || (field[2] == 'PRIMARY KEY' && field[0] != 'Serial')) {
								fieldOrdering.push(field)
								fields.push([field[1], '?']);
							}
						}
						query.push(['Fields', fields]);
					break;
				}
				query.push(['From', table.name])
				// All good.
			break;
		}
		return [fieldOrdering];
	};

	return ServerURIParser;
});