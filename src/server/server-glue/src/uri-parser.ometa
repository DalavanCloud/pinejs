define(['ometa!sbvr-parser/SBVRLibs', 'underscore', 'ometa-core'], function(SBVRLibs, _) {
	ometa URIParser <: SBVRLibs {
		Process =
			[	(	'GET'
				|	'PUT'
				|	'POST'
				|	'DELETE'
				):method
				{this.currentMethod = method}
				anything:body
				[	// Get the vocabulary, ie the "Service Root"
					'/' Vocabulary:vocab
					{this.currentVocab = vocab}
					ProcessURI(body)?:requests
					'/'?
				]
			]
			-> {
				type: this.type,
				requests: requests,
				vocabulary: vocab
			},

		Vocabulary =
			<	(	~'/'
					anything
				)+
			>
	}

	URIParser.initialize = function() {
		this.sqlModels = {};
		this.clientModels = {};
		this.currentVocab = '';
		this.currentMethod = '';
		this.currentBody = [];
		this.currentResource = null;
	};

	URIParser.GetTableField = function(mapping) {
		return SBVRLibs.GetTableField.call(this, this.sqlModels[this.currentVocab].tables[mapping[0]], mapping[1]);
	};

	URIParser.GetMapping = function(resourceName, resourceFieldName) {
		var resourceMapping = this.clientModels[this.currentVocab].resourceToSQLMappings[resourceName]
		if(resourceMapping.hasOwnProperty(resourceFieldName)) {
			return resourceMapping[resourceFieldName];
		}
		resourceFieldName = resourceFieldName.replace(/ /g, '_');
		if(resourceMapping.hasOwnProperty(resourceFieldName)) {
			return resourceMapping[resourceFieldName];
		}
		throw 'Could not map resource: ' + resourceName + ' - ' + resourceFieldName;
	};

	URIParser.setSQLModel = function(vocab, model) {
		this.sqlModels[vocab] = model;
	};

	URIParser.setClientModel = function(vocab, model) {
		this.clientModels[vocab] = model;
	};

	URIParser.AddWhereClause = function(query, whereBody) {
		// TODO: Move this to an optimisation pass?
		// Check if it's a place where we can do a join optimisation.
		if(whereBody[0] == 'Exists' && (
				whereBody[1][0] == 'SelectQuery' || whereBody[1][0] == 'InsertQuery' ||
				whereBody[1][0] == 'UpdateQuery' || whereBody[1][0] == 'UpsertQuery')) {
			whereBody = whereBody[1].slice(1);
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'From') {
					query.push(whereBody[i]);
				}
			}
			for(var i=0; i < whereBody.length; i++) {
				if(whereBody[i][0] == 'Where') {
					this.AddWhereClause(query, whereBody[i][1]);
				}
			}
		}
		else {
			for(var i=1; i < query.length; i++) {
				if(query[i][0] == 'Where') {
					query[i][1] = ['And', query[i][1], whereBody];
					return;
				}
			}
			query.push(['Where', whereBody]);
		}
		
		if(query[0] == 'UpsertQuery' && whereBody[0] == 'Equals') {
			var field, bind;
			if(whereBody[1][0] == 'Field') {
				field = whereBody[1][1];
			}
			else if(whereBody[1][0] == 'ReferencedField') {
				field = whereBody[1][2];
			}
			else if(whereBody[2][0] == 'Field') {
				field = whereBody[2][1];
			}
			else if(whereBody[2][0] == 'ReferencedField') {
				field = whereBody[2][2];
			}
			
			if(whereBody[1][0] == 'Bind') {
				bind = whereBody[1];
			}
			else if(whereBody[2][0] == 'Bind') {
				bind = whereBody[2];
			}
			
			for(var i=1; i < query.length; i++) {
				var queryPart = query[i];
				if(queryPart[0] == 'Fields') {
					for(var j=0; j < queryPart[1].length; j++) {
						var queryFields = queryPart[1][j];
						if(queryFields[0] == field) {
							// Update the value field for the query
							queryFields[1] = bind;
							break;
						}
					}
					if(j === queryPart[1].length) {
						// We need to add it to field and values list of query.
						queryPart[1].push([field, bind]);
					}
					break;
				}
			}
		}
	};

	URIParser.AddBodyVar = function(query, resourceName, resourceFieldName, mapping, value) {
		if(value === undefined) {
			if(this.currentBody.hasOwnProperty(resourceName + '/' + resourceFieldName)) {
				value = this.currentBody[resourceName + '/' + resourceFieldName];
			}
			else if(this.currentBody.hasOwnProperty(resourceName + '.' + resourceFieldName)) {
				value = this.currentBody[resourceName + '.' + resourceFieldName];
			}
			else if(this.currentBody.hasOwnProperty(resourceFieldName)) {
				value = this.currentBody[resourceFieldName];
			}
			else {
				// We haven't got a value for this field, but we should check if it's an autogenerated field and if so add the table anyway.
				var sqlTable = this.sqlModels[this.currentVocab].tables[mapping[0]];
				if(sqlTable.hasOwnProperty('fields')) {
					for(var i = 0; i < sqlTable.fields.length; i++) {
						var sqlField = sqlTable.fields[i];
						if(sqlField[1] == mapping[1]) {
							if(sqlField[0] == 'Serial') {
								this.AddQueryTable(query, mapping[0]);
							}
							return;
						}
					}
				}
				return;
			}
		}
		this.AddQueryTable(query, mapping[0]);
		return this.newBody[mapping.join('.')] = value;
	};

	URIParser.AddQueryTable = function(query, tableName) {
		var i = 0;
		for(;i < query.length; i++) {
			if(query[i][0] === 'From' && query[i][1] === tableName) {
				return;
			}
		}
		query.push(['From', tableName]);
	};

	URIParser.AddQueryResource = function(query, resourceName) {
		var newValue, fieldName, fields, mapping, resourceFieldName, self = this,
			clientModel = this.clientModels[this.currentVocab],
			resourceModel = clientModel.resources[resourceName],
			resourceToSQLMappings = clientModel.resourceToSQLMappings[resourceName],
			getSelectFields = function() {
				var mapping, resourceField, fields = [];
				for(resourceField in resourceToSQLMappings) {
					if(resourceToSQLMappings.hasOwnProperty(resourceField)) {
						mapping = resourceToSQLMappings[resourceField];
						self.AddQueryTable(query, mapping[0]);
						fields.push([['ReferencedField'].concat(mapping), resourceField]);
					}
				}
				return fields;
			};
		this.currentResource = resourceName;
		switch(this.sqlModels[this.currentVocab].tables[resourceName]) {
			case 'ForeignKey':
				switch(this.currentMethod) {
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', getSelectFields()]);
					break;
					default:
						__TODO__.die();
				}
			break;
			case 'Attribute':
				// The attribute is value field
				resourceFieldName = resourceModel.referenceScheme;
				mapping = this.GetMapping(resourceName, resourceFieldName);
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'UpdateQuery';
						this.AddQueryTable(query, mapping[0]);
						query.push(['Fields', [[mapping[1], 'NULL']]]);
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', getSelectFields()]);
					break;
					case 'PUT':
					case 'POST':
						query[0] = 'UpdateQuery';
						if(this.AddBodyVar(query, resourceName, resourceFieldName, mapping) !== undefined) {
							query.push(['Fields', [[mapping[1], ['Bind', mapping[0], this.GetTableField(mapping)]]]]);
						}
					break;
				}

				resourceFieldName = resourceModel.idField;
				mapping = this.GetMapping(resourceName, resourceFieldName);
				fieldName = mapping[1];
				if(this.AddBodyVar(query, resourceName, resourceFieldName, mapping) !== undefined) {
					this.AddWhereClause(query, ['Equals', ['ReferencedField'].concat(mapping), ['Bind', mapping[0], this.GetTableField(mapping)]]);
				}
			break;
			case 'BooleanAttribute':
				// The attribute is value field
				resourceFieldName = resourceModel.referenceScheme;
				mapping = this.GetMapping(resourceName, resourceFieldName);
				switch(this.currentMethod) {
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', getSelectFields()]);
						this.AddQueryTable(query, mapping[0]);
						this.AddWhereClause(query, ['Equals', ['ReferencedField'].concat(mapping), ['Boolean', true]]);
					break;
					case 'DELETE':
						newValue = false;
						// Fallthrough
					case 'PUT':
					case 'POST':
						if(newValue == null) {
							newValue = true;
						}
						query[0] = 'UpdateQuery';
						query.push(['Fields', [[mapping[1], newValue]]]);
						this.AddQueryTable(query, mapping[0]);

						resourceFieldName = resourceModel.idField;
						mapping = this.GetMapping(resourceName, resourceFieldName);
						fieldName = mapping[1];
						if(this.AddBodyVar(query, resourceName, resourceFieldName, mapping) !== undefined) {
							this.AddWhereClause(query, ['Equals', ['ReferencedField'].concat(mapping), ['Bind', mapping[0], this.GetTableField(mapping)]]);
						}
					break;
				}
			break;
			default:
				switch(this.currentMethod) {
					case 'DELETE':
						query[0] = 'DeleteQuery';
					break;
					case 'GET':
						query[0] = 'SelectQuery';
						query.push(['Select', getSelectFields()]);
					break;
					case 'PUT':
					case 'POST':
						if(this.currentMethod === 'PUT') {
							query[0] = 'UpsertQuery';
						}
						else {
							query[0] = 'InsertQuery';
						}
						fields = [];
						for(resourceFieldName in resourceToSQLMappings) {
							if(resourceToSQLMappings.hasOwnProperty(resourceFieldName)) {
								mapping = resourceToSQLMappings[resourceFieldName];
								if(this.AddBodyVar(query, resourceName, resourceFieldName, mapping) !== undefined) {
									fields.push([mapping[1], ['Bind', mapping[0], this.GetTableField(mapping)] ]);
								}
							}
						}
						query.push(['Fields', fields]);
					break;
				}
				// All good.
			break;
		}
	};

	return URIParser;
});