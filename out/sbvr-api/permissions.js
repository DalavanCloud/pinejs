// Generated by CoffeeScript 1.12.6
(function() {
  var BluebirdLRU, ODataParser, PermissionError, PermissionParsingError, Promise, TypedError, _, collapsePermissionFilters, env, memoize, metadataEndpoints, methodPermissions, nestedCheck, parsePermissions, rootRead, userModel,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  Promise = require('bluebird');

  BluebirdLRU = require('bluebird-lru-cache');

  env = require('../config-loader/env');

  userModel = require('./user.sbvr');

  metadataEndpoints = require('./uri-parser').metadataEndpoints;

  ODataParser = require('@resin/odata-parser').ODataParser;

  memoize = require('memoizee');

  TypedError = require('typed-error');

  exports.PermissionError = PermissionError = (function(superClass) {
    extend(PermissionError, superClass);

    function PermissionError() {
      return PermissionError.__super__.constructor.apply(this, arguments);
    }

    return PermissionError;

  })(TypedError);

  exports.PermissionParsingError = PermissionParsingError = (function(superClass) {
    extend(PermissionParsingError, superClass);

    function PermissionParsingError() {
      return PermissionParsingError.__super__.constructor.apply(this, arguments);
    }

    return PermissionParsingError;

  })(TypedError);

  exports.root = {
    user: {
      permissions: ['resource.all']
    }
  };

  exports.rootRead = rootRead = {
    user: {
      permissions: ['resource.get']
    }
  };

  methodPermissions = {
    GET: {
      or: ['get', 'read']
    },
    PUT: {
      or: [
        'set', {
          and: ['create', 'update']
        }
      ]
    },
    POST: {
      or: ['set', 'create']
    },
    PATCH: {
      or: ['set', 'update']
    },
    MERGE: {
      or: ['set', 'update']
    },
    DELETE: 'delete'
  };

  parsePermissions = (function() {
    var _parsePermissions, odataParser;
    odataParser = ODataParser.createInstance();
    _parsePermissions = memoize(function(filter, bindsLength) {
      var tree;
      odataParser.binds = new Array(bindsLength);
      tree = odataParser.matchAll(['FilterByExpression', filter], 'ProcessRule');
      return {
        tree: tree,
        extraBinds: odataParser.binds.slice(bindsLength)
      };
    }, {
      primitive: true
    });
    return function(filter, odataBinds) {
      var extraBinds, ref, tree;
      ref = _parsePermissions(filter, odataBinds.length), tree = ref.tree, extraBinds = ref.extraBinds;
      odataBinds.push.apply(odataBinds, extraBinds);
      return tree;
    };
  })();

  exports.nestedCheck = nestedCheck = function(check, stringCallback) {
    var checkType, checkTypes, i, j, len, len1, ref, result, results, subcheck;
    if (_.isString(check)) {
      return stringCallback(check);
    } else if (_.isBoolean(check)) {
      return check;
    } else if (_.isArray(check)) {
      results = [];
      for (i = 0, len = check.length; i < len; i++) {
        subcheck = check[i];
        result = nestedCheck(subcheck, stringCallback);
        if (result === false) {
          return false;
        } else if (result !== true) {
          results = results.concat(result);
        }
      }
      if (results.length === 1) {
        return results[0];
      } else if (results.length > 1) {
        return _.uniq(results);
      } else {
        return true;
      }
    } else if (_.isObject(check)) {
      checkTypes = _.keys(check);
      if (checkTypes.length > 1) {
        throw new Error('More than one check type: ' + checkTypes);
      }
      checkType = checkTypes[0];
      switch (checkType.toUpperCase()) {
        case 'AND':
          return nestedCheck(check[checkType], stringCallback);
        case 'OR':
          results = [];
          ref = check[checkType];
          for (j = 0, len1 = ref.length; j < len1; j++) {
            subcheck = ref[j];
            result = nestedCheck(subcheck, stringCallback);
            if (result === true) {
              return true;
            } else if (result !== false) {
              results = results.concat(result);
            }
          }
          if (results.length === 1) {
            return results[0];
          } else if (results.length > 1) {
            return _.uniq(results);
          } else {
            return false;
          }
          break;
        default:
          throw new Error('Cannot parse required checking logic: ' + checkType);
      }
    } else {
      throw new Error('Cannot parse required checks: ' + check);
    }
  };

  collapsePermissionFilters = function(v) {
    if (_.isArray(v)) {
      return collapsePermissionFilters({
        or: v
      });
    } else if (_.isObject(v)) {
      if (v.hasOwnProperty('filter')) {
        return v.filter;
      } else {
        return _(v).toPairs().flattenDeep().map(collapsePermissionFilters).value();
      }
    } else {
      return v;
    }
  };

  exports.config = {
    models: [
      {
        apiRoot: 'Auth',
        modelText: userModel,
        customServerCode: exports
      }
    ]
  };

  exports.setup = function(app, sbvrUtils) {
    var addPermissions, apiKeyMiddleware, checkApiKey, checkPermissions, customApiKeyMiddleware, customAuthorizationMiddleware, getApiKeyPermissions, getPermissions, getUserPermissions;
    sbvrUtils.addHook('all', 'all', 'all', {
      PREPARSE: function(arg) {
        var req;
        req = arg.req;
        return apiKeyMiddleware(req);
      },
      POSTPARSE: function(arg) {
        var req, request;
        req = arg.req, request = arg.request;
        return addPermissions(req, request);
      }
    });
    sbvrUtils.addHook('POST', 'Auth', 'user', {
      POSTPARSE: function(arg) {
        var api, request;
        request = arg.request, api = arg.api;
        return api.post({
          resource: 'actor'
        }).then(function(result) {
          return request.values.actor = result.id;
        });
      }
    });
    sbvrUtils.addHook('DELETE', 'Auth', 'user', {
      POSTRUN: function(arg) {
        var api, request;
        request = arg.request, api = arg.api;
        return api["delete"]({
          resource: 'actor',
          id: request.values.actor
        });
      }
    });
    exports.checkPassword = function(username, password, callback) {
      var authApi;
      authApi = sbvrUtils.api.Auth;
      return authApi.get({
        resource: 'user',
        passthrough: {
          req: rootRead
        },
        options: {
          select: ['id', 'actor', 'password'],
          filter: {
            username: username
          }
        }
      }).then(function(result) {
        var actorId, hash, userId;
        if (result.length === 0) {
          throw new Error('User not found');
        }
        hash = result[0].password;
        userId = result[0].id;
        actorId = result[0].actor;
        return sbvrUtils.sbvrTypes.Hashed.compare(password, hash).then(function(res) {
          if (!res) {
            throw new Error('Passwords do not match');
          }
          return getUserPermissions(userId).then(function(permissions) {
            return {
              id: userId,
              actor: actorId,
              username: username,
              permissions: permissions
            };
          });
        });
      }).nodeify(callback);
    };
    getPermissions = function(permsFilter, callback) {
      var authApi;
      authApi = sbvrUtils.api.Auth;
      return authApi.get({
        resource: 'permission',
        passthrough: {
          req: rootRead
        },
        options: {
          select: 'name',
          filter: permsFilter
        }
      }).map(function(permission) {
        return permission.name;
      })["catch"](function(err) {
        authApi.logger.error('Error loading permissions', err, err.stack);
        throw err;
      }).nodeify(callback);
    };
    exports.getUserPermissions = getUserPermissions = function(userId, callback) {
      var permsFilter;
      if (_.isString(userId)) {
        userId = _.parseInt(userId);
      }
      if (!_.isFinite(userId)) {
        return Promise.rejected(new Error('User ID has to be numeric, got: ' + typeof userId));
      }
      permsFilter = {
        $or: {
          is_of__user: {
            $any: {
              $alias: 'uhp',
              $expr: {
                uhp: {
                  user: userId
                },
                $or: [
                  {
                    uhp: {
                      expiry_date: null
                    }
                  }, {
                    uhp: {
                      expiry_date: {
                        $gt: {
                          $now: null
                        }
                      }
                    }
                  }
                ]
              }
            }
          },
          is_of__role: {
            $any: {
              $alias: 'rhp',
              $expr: {
                rhp: {
                  role: {
                    $any: {
                      $alias: 'r',
                      $expr: {
                        r: {
                          is_of__user: {
                            $any: {
                              $alias: 'uhr',
                              $expr: {
                                uhr: {
                                  user: userId
                                },
                                $or: [
                                  {
                                    uhr: {
                                      expiry_date: null
                                    }
                                  }, {
                                    uhr: {
                                      expiry_date: {
                                        $gt: {
                                          $now: null
                                        }
                                      }
                                    }
                                  }
                                ]
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };
      return getPermissions(permsFilter, callback);
    };
    exports.getApiKeyPermissions = getApiKeyPermissions = (function() {
      var cache;
      cache = new BluebirdLRU({
        max: env.apiKeys.permissionsCache.max,
        maxAge: env.apiKeys.permissionsCache.maxAge,
        fetchFn: function(apiKey) {
          var permsFilter;
          permsFilter = {
            $or: {
              is_of__api_key: {
                $any: {
                  $alias: 'khp',
                  $expr: {
                    khp: {
                      api_key: {
                        $any: {
                          $alias: 'k',
                          $expr: {
                            k: {
                              key: apiKey
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              is_of__role: {
                $any: {
                  $alias: 'rhp',
                  $expr: {
                    'rhp': {
                      role: {
                        $any: {
                          $alias: 'r',
                          $expr: {
                            r: {
                              is_of__api_key: {
                                $any: {
                                  $alias: 'khr',
                                  $expr: {
                                    khr: {
                                      api_key: {
                                        $any: {
                                          $alias: 'k',
                                          $expr: {
                                            k: {
                                              key: apiKey
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          return getPermissions(permsFilter);
        }
      });
      return function(apiKey, callback) {
        var promise;
        promise = _.isString(apiKey) ? cache.get(apiKey) : Promise.rejected(new Error('API key has to be a string, got: ' + typeof apiKey));
        return promise.nodeify(callback);
      };
    })();
    checkApiKey = function(req, apiKey) {
      return Promise["try"](function() {
        if ((apiKey == null) || (req.apiKey != null)) {
          return;
        }
        return getApiKeyPermissions(apiKey)["catch"](function(err) {
          console.warn('Error with API key:', err);
          return [];
        }).then(function(permissions) {
          return req.apiKey = {
            key: apiKey,
            permissions: permissions
          };
        });
      });
    };
    exports.customAuthorizationMiddleware = customAuthorizationMiddleware = function(expectedScheme) {
      if (expectedScheme == null) {
        expectedScheme = 'Bearer';
      }
      expectedScheme = expectedScheme.toLowerCase();
      return function(req, res, next) {
        return Promise["try"](function() {
          var apiKey, auth, parts, scheme;
          auth = req.header('Authorization');
          if (!auth) {
            return;
          }
          parts = auth.split(' ');
          if (parts.length !== 2) {
            return;
          }
          scheme = parts[0], apiKey = parts[1];
          if (scheme.toLowerCase() !== expectedScheme) {
            return;
          }
          return checkApiKey(req, apiKey);
        }).then(function() {
          if (typeof next === "function") {
            next();
          }
        });
      };
    };
    exports.authorizationMiddleware = customAuthorizationMiddleware();
    exports.customApiKeyMiddleware = customApiKeyMiddleware = function(paramName) {
      if (paramName == null) {
        paramName = 'apikey';
      }
      return function(req, res, next) {
        var apiKey, ref, ref1;
        apiKey = (ref = (ref1 = req.params[paramName]) != null ? ref1 : req.body[paramName]) != null ? ref : req.query[paramName];
        return checkApiKey(req, apiKey).then(function() {
          if (typeof next === "function") {
            next();
          }
        });
      };
    };
    exports.apiKeyMiddleware = apiKeyMiddleware = customApiKeyMiddleware();
    exports.checkPermissions = checkPermissions = (function() {
      var _getGuestPermissions;
      _getGuestPermissions = (function() {
        var _guestPermissions;
        _guestPermissions = null;
        return function(callback) {
          if ((_guestPermissions == null) || _guestPermissions.isRejected()) {
            _guestPermissions = sbvrUtils.api.Auth.get({
              resource: 'user',
              passthrough: {
                req: rootRead
              },
              options: {
                select: 'id',
                filter: {
                  username: 'guest'
                }
              }
            }).then(function(result) {
              if (result.length === 0) {
                throw new Error('No guest permissions');
              }
              return getUserPermissions(result[0].id);
            });
          }
          return _guestPermissions.nodeify(callback);
        };
      })();
      return function() {
        var _checkPermissions, actionList, actorID, apiKeyActorID, args, authApi, callback, callbackArg, ref, ref1, req, resourceName, vocabulary;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        callbackArg = Math.max(3, Math.min(6, args.length - 1));
        if (_.isFunction(args[callbackArg])) {
          callback = args[callbackArg];
          args[callbackArg] = null;
        }
        req = args[0], actionList = args[1], resourceName = args[2], vocabulary = args[3];
        authApi = sbvrUtils.api.Auth;
        _checkPermissions = function(permissions, actorID) {
          var checkObject;
          if (actorID == null) {
            throw new Error('Actor ID cannot be null for _checkPermissions.');
          }
          checkObject = {
            or: ['all', actionList]
          };
          return nestedCheck(checkObject, function(permissionCheck) {
            var conditionalPermissions, resourcePermission, vocabularyPermission, vocabularyResourcePermission;
            resourcePermission = 'resource.' + permissionCheck;
            if (_.includes(permissions, resourcePermission)) {
              return true;
            }
            if (vocabulary != null) {
              vocabularyPermission = vocabulary + '.' + permissionCheck;
              if (_.includes(permissions, vocabularyPermission)) {
                return true;
              }
              if (resourceName != null) {
                vocabularyResourcePermission = vocabulary + '.' + resourceName + '.' + permissionCheck;
                if (_.includes(permissions, vocabularyResourcePermission)) {
                  return true;
                }
              }
            }
            conditionalPermissions = _.map(permissions, function(permissionName) {
              var condition, i, len, permission, ref;
              ref = [resourcePermission, vocabularyPermission, vocabularyResourcePermission];
              for (i = 0, len = ref.length; i < len; i++) {
                permission = ref[i];
                if (!(permission != null)) {
                  continue;
                }
                permission = permission + '?';
                if (permissionName.slice(0, permission.length) === permission) {
                  condition = permissionName.slice(permission.length);
                  if (_.isArray(actorID)) {
                    return _.map(actorID, function(id) {
                      return condition.replace(/\$ACTOR\.ID/g, id);
                    });
                  }
                  return condition.replace(/\$ACTOR\.ID/g, actorID);
                }
              }
              return false;
            });
            conditionalPermissions = _.filter(conditionalPermissions);
            if (conditionalPermissions.length === 1) {
              return conditionalPermissions[0];
            } else if (conditionalPermissions.length > 1) {
              return {
                or: conditionalPermissions
              };
            }
            return false;
          });
        };
        actorID = (ref = (ref1 = req.user) != null ? ref1.actor : void 0) != null ? ref : 0;
        apiKeyActorID = false;
        return Promise["try"](function() {
          if (req.user != null) {
            return _checkPermissions(req.user.permissions, actorID);
          }
          return false;
        })["catch"](function(err) {
          authApi.logger.error('Error checking user permissions', req.user, err, err.stack);
          return false;
        }).then(function(allowed) {
          var apiKeyPermissions, ref2;
          apiKeyPermissions = (ref2 = req.apiKey) != null ? ref2.permissions : void 0;
          if (allowed === true || (apiKeyPermissions == null) || apiKeyPermissions.length === 0) {
            return allowed;
          }
          return authApi.get({
            resource: 'api_key',
            passthrough: {
              req: rootRead
            },
            options: {
              select: 'is_of__actor',
              filter: {
                key: req.apiKey.key
              }
            }
          }).then(function(apiKeys) {
            if (apiKeys.length === 0) {
              throw new Error('API key is not linked to a actor?!');
            }
            apiKeyActorID = apiKeys[0].is_of__actor.__id;
            return _checkPermissions(apiKeyPermissions, apiKeyActorID);
          })["catch"](function(err) {
            return authApi.logger.error('Error checking api key permissions', req.apiKey.key, err, err.stack);
          }).then(function(apiKeyAllowed) {
            if (apiKeyAllowed === true) {
              return true;
            }
            return {
              or: [allowed, apiKeyAllowed]
            };
          });
        }).then(function(allowed) {
          if (allowed === true) {
            return allowed;
          }
          return _getGuestPermissions().then(function(permissions) {
            var actorIDs;
            actorIDs = apiKeyActorID !== false ? [actorID, apiKeyActorID] : actorID;
            return _checkPermissions(permissions, actorIDs);
          })["catch"](function(err) {
            authApi.logger.error('Error checking guest permissions', err, err.stack);
            return false;
          }).then(function(guestAllowed) {
            return {
              or: [allowed, guestAllowed]
            };
          });
        }).then(function(permissions) {
          return nestedCheck(permissions, _.identity);
        }).nodeify(callback);
      };
    })();
    exports.checkPermissionsMiddleware = function(action) {
      return function(req, res, next) {
        return checkPermissions(req, action).then(function(allowed) {
          switch (allowed) {
            case false:
              return res.sendStatus(401);
            case true:
              return next();
            default:
              throw new Error('checkPermissionsMiddleware returned a conditional permission');
          }
        })["catch"](function(err) {
          sbvrUtils.api.Auth.logger.error('Error checking permissions', err, err.stack);
          return res.sendStatus(503);
        });
      };
    };
    return addPermissions = (function() {
      var _addPermissions;
      _addPermissions = function(req, permissionType, vocabulary, resourceName, odataQuery, odataBinds) {
        return checkPermissions(req, permissionType, resourceName, vocabulary).then(function(conditionalPerms) {
          var permissionFilters, ref, ref1;
          if (conditionalPerms === false) {
            throw new PermissionError();
          }
          if (conditionalPerms !== true) {
            permissionFilters = nestedCheck(conditionalPerms, function(permissionCheck) {
              var e;
              try {
                permissionCheck = parsePermissions(permissionCheck, odataBinds);
                return {
                  filter: permissionCheck
                };
              } catch (error) {
                e = error;
                console.warn('Failed to parse conditional permissions: ', permissionCheck);
                throw new PermissionParsingError(e);
              }
            });
            if (permissionFilters === false) {
              throw new PermissionError();
            }
            if (permissionFilters !== true) {
              permissionFilters = collapsePermissionFilters(permissionFilters);
              if (odataQuery.options == null) {
                odataQuery.options = {};
              }
              if (odataQuery.options.$filter != null) {
                odataQuery.options.$filter = ['and', odataQuery.options.$filter, permissionFilters];
              } else {
                odataQuery.options.$filter = permissionFilters;
              }
            }
          }
          if (((ref = odataQuery.options) != null ? (ref1 = ref.$expand) != null ? ref1.properties : void 0 : void 0) != null) {
            return Promise.each(odataQuery.options.$expand.properties, function(expand) {
              return _addPermissions(req, methodPermissions.GET, vocabulary, expand.name, expand, odataBinds);
            });
          }
        });
      };
      return function(req, arg) {
        var custom, isMetadataEndpoint, method, odataBinds, odataQuery, permissionType, resourceName, values, vocabulary;
        method = arg.method, vocabulary = arg.vocabulary, resourceName = arg.resourceName, odataQuery = arg.odataQuery, odataBinds = arg.odataBinds, values = arg.values, custom = arg.custom;
        method = method.toUpperCase();
        isMetadataEndpoint = indexOf.call(metadataEndpoints, resourceName) >= 0 || method === 'OPTIONS';
        permissionType = isMetadataEndpoint ? 'model' : methodPermissions[method] != null ? methodPermissions[method] : (console.warn('Unknown method for permissions type check: ', method), 'all');
        return _addPermissions(req, permissionType, vocabulary, odataQuery.resource, odataQuery, odataBinds);
      };
    })();
  };

}).call(this);

//# sourceMappingURL=permissions.js.map
