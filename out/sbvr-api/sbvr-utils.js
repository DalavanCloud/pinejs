// Generated by CoffeeScript 1.12.6
(function() {
  var AbstractSQLCompiler, InternalRequestError, LF2AbstractSQL, LF2AbstractSQLTranslator, ODataMetadataGenerator, PinejsClient, PinejsClientCore, Promise, SBVRParser, SbvrValidationError, SqlCompilationError, TypedError, UnsupportedMethodError, _, abstractSqlModels, api, apiHooks, checkForExpansion, cleanupModel, constructError, controlFlow, db, devModel, executeModel, executeModels, executeStandardModels, fetchProcessing, getAndCheckBindValues, getHooks, handleODataRequest, isRuleAffected, memoize, memoizedCompileRule, migrator, odataMetadata, odataNameToSqlName, odataResourceURI, permissions, prepareResponse, prettifyConstraintError, processOData, ref1, resolveOdataBind, resolveSynonym, respondDelete, respondGet, respondOptions, respondPost, respondPut, runChangeSet, runDelete, runGet, runHook, runPost, runPut, runQuery, runRequest, runTransaction, runURI, sbvrTypes, seModels, sqlModels, sqlNameToODataName, updateBinds, uriParser, validateModel,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  Promise = require('bluebird');

  TypedError = require('typed-error');

  LF2AbstractSQL = require('@resin/lf-to-abstract-sql');

  AbstractSQLCompiler = require('@resin/abstract-sql-compiler');

  PinejsClientCore = require('pinejs-client/core');

  sbvrTypes = require('@resin/sbvr-types');

  ref1 = require('@resin/odata-to-abstract-sql'), sqlNameToODataName = ref1.sqlNameToODataName, odataNameToSqlName = ref1.odataNameToSqlName;

  SBVRParser = require('../extended-sbvr-parser/extended-sbvr-parser');

  migrator = require('../migrator/migrator');

  ODataMetadataGenerator = require('../sbvr-compiler/ODataMetadataGenerator');

  devModel = require('./dev.sbvr');

  permissions = require('./permissions');

  uriParser = require('./uri-parser');

  controlFlow = require('./control-flow');

  memoize = require('memoizee');

  memoizedCompileRule = memoize(function(abstractSqlQuery) {
    return AbstractSQLCompiler.compileRule(abstractSqlQuery);
  }, {
    primitive: true
  });

  db = null;

  exports.sbvrTypes = sbvrTypes;

  fetchProcessing = _.mapValues(sbvrTypes, function(arg) {
    var fetchProcessing;
    fetchProcessing = arg.fetchProcessing;
    if (fetchProcessing != null) {
      return Promise.promisify(fetchProcessing);
    }
  });

  LF2AbstractSQLTranslator = LF2AbstractSQL.createTranslator(sbvrTypes);

  seModels = {};

  abstractSqlModels = {};

  sqlModels = {};

  odataMetadata = {};

  apiHooks = {
    all: {},
    GET: {},
    PUT: {},
    POST: {},
    PATCH: {},
    DELETE: {},
    OPTIONS: {}
  };

  apiHooks.MERGE = apiHooks.PATCH;

  UnsupportedMethodError = (function(superClass) {
    extend(UnsupportedMethodError, superClass);

    function UnsupportedMethodError() {
      return UnsupportedMethodError.__super__.constructor.apply(this, arguments);
    }

    return UnsupportedMethodError;

  })(TypedError);

  SqlCompilationError = (function(superClass) {
    extend(SqlCompilationError, superClass);

    function SqlCompilationError() {
      return SqlCompilationError.__super__.constructor.apply(this, arguments);
    }

    return SqlCompilationError;

  })(TypedError);

  SbvrValidationError = (function(superClass) {
    extend(SbvrValidationError, superClass);

    function SbvrValidationError() {
      return SbvrValidationError.__super__.constructor.apply(this, arguments);
    }

    return SbvrValidationError;

  })(TypedError);

  InternalRequestError = (function(superClass) {
    extend(InternalRequestError, superClass);

    function InternalRequestError() {
      return InternalRequestError.__super__.constructor.apply(this, arguments);
    }

    return InternalRequestError;

  })(TypedError);

  resolveSynonym = function(arg) {
    var ref2, resourceName, vocabulary;
    vocabulary = arg.vocabulary, resourceName = arg.resourceName;
    resourceName = odataNameToSqlName(resourceName);
    return resourceName = (ref2 = abstractSqlModels[vocabulary].synonyms[resourceName]) != null ? ref2 : resourceName;
  };

  prettifyConstraintError = function(err, tableName) {
    var matches;
    if (err instanceof db.ConstraintError) {
      if (err instanceof db.UniqueConstraintError) {
        switch (db.engine) {
          case 'mysql':
            matches = /ER_DUP_ENTRY: Duplicate entry '.*?[^\\]' for key '(.*?[^\\])'/.exec(err);
            break;
          case 'postgres':
            matches = new RegExp('"' + tableName + '_(.*?)_key"').exec(err);
            if (matches == null) {
              throw new db.UniqueConstraintError('Unique key constraint violated');
            }
        }
        throw new db.UniqueConstraintError('"' + sqlNameToODataName(matches[1]) + '" must be unique.');
      }
      if (err instanceof db.ForeignKeyConstraintError) {
        switch (db.engine) {
          case 'mysql':
            matches = /ER_ROW_IS_REFERENCED_: Cannot delete or update a parent row: a foreign key constraint fails \(".*?"\.(".*?").*/.exec(err);
            break;
          case 'postgres':
            matches = new RegExp('"' + tableName + '" violates foreign key constraint ".*?" on table "(.*?)"').exec(err);
            if (matches == null) {
              matches = new RegExp('"' + tableName + '" violates foreign key constraint "' + tableName + '_(.*?)_fkey"').exec(err);
            }
            if (matches == null) {
              throw new db.ForeignKeyConstraintError('Foreign key constraint violated');
            }
        }
        throw new db.ForeignKeyConstraintError('Data is referenced by ' + sqlNameToODataName(matches[1]) + '.');
      }
      throw err;
    }
  };

  exports.resolveOdataBind = resolveOdataBind = function(odataBinds, value) {
    var dataType, ref2;
    if (_.isObject(value) && (value.bind != null)) {
      ref2 = odataBinds[value.bind], dataType = ref2[0], value = ref2[1];
    }
    return value;
  };

  getAndCheckBindValues = function(vocab, odataBinds, bindings, values) {
    var sqlModelTables;
    sqlModelTables = sqlModels[vocab].tables;
    return Promise.map(bindings, function(binding) {
      var dataType, field, fieldName, ref2, ref3, referencedName, sqlFieldName, sqlTableName, tableName, value;
      if (binding[0] === 'Bind') {
        if (_.isArray(binding[1])) {
          ref2 = binding[1], tableName = ref2[0], fieldName = ref2[1];
          referencedName = tableName + '.' + fieldName;
          value = values[referencedName];
          if (value === void 0) {
            value = values[fieldName];
          }
          value = resolveOdataBind(odataBinds, value);
          sqlTableName = odataNameToSqlName(tableName);
          sqlFieldName = odataNameToSqlName(fieldName);
          field = _.find(sqlModelTables[sqlTableName].fields, {
            fieldName: sqlFieldName
          });
        } else if (_.isInteger(binding[1])) {
          if (binding[1] >= odataBinds.length) {
            console.error("Invalid binding number '" + binding[1] + "' for binds: ", odataBinds);
            throw new Error('Invalid binding');
          }
          ref3 = odataBinds[binding[1]], dataType = ref3[0], value = ref3[1];
          field = {
            dataType: dataType
          };
        } else {
          throw new Error("Unknown binding: " + binding);
        }
      } else {
        dataType = binding[0], value = binding[1];
        field = {
          dataType: dataType
        };
      }
      if (value === void 0) {
        return db.DEFAULT_VALUE;
      }
      return AbstractSQLCompiler.dataTypeValidate(value, field)["catch"](function(e) {
        e.message = '"' + fieldName + '" ' + e.message;
        throw e;
      });
    });
  };

  isRuleAffected = (function() {
    var checkModifiedFields;
    checkModifiedFields = function(referencedFields, modifiedFields) {
      var refs;
      refs = referencedFields[modifiedFields.table];
      return (refs == null) || _.intersection(refs, modifiedFields.fields).length === 0;
    };
    return function(rule, request) {
      var modifiedFields;
      if ((rule.referencedFields == null) || ((request != null ? request.abstractSqlQuery : void 0) == null)) {
        return false;
      }
      modifiedFields = AbstractSQLCompiler.getModifiedFields(request.abstractSqlQuery);
      if (modifiedFields == null) {
        return false;
      }
      if (_.isArray(modifiedFields)) {
        return _.any(modifiedFields, _.partial(checkModifiedFields, rule.referencedFields));
      }
      return checkModifiedFields(rule.referencedFields, modifiedFields);
    };
  })();

  exports.validateModel = validateModel = function(tx, modelName, request) {
    return Promise.map(sqlModels[modelName].rules, function(rule) {
      if (!isRuleAffected(rule, request)) {
        return;
      }
      return tx.executeSql(rule.sql, rule.bindings).then(function(result) {
        var ref2;
        if ((ref2 = result.rows.item(0).result) === false || ref2 === 0 || ref2 === '0') {
          throw new SbvrValidationError(rule.structuredEnglish);
        }
      });
    });
  };

  exports.executeModel = executeModel = function(tx, model, callback) {
    return executeModels(tx, [model], callback);
  };

  exports.executeModels = executeModels = function(tx, models, callback) {
    return Promise.map(models, function(model) {
      var seModel, vocab;
      seModel = model.modelText;
      vocab = model.apiRoot;
      return migrator.run(tx, model).then(function() {
        var abstractSqlModel, e, lfModel, metadata, sqlModel;
        try {
          lfModel = SBVRParser.matchAll(seModel, 'Process');
        } catch (error) {
          e = error;
          console.error('Error parsing model', vocab, e, e.stack);
          throw new Error(['Error parsing model', e]);
        }
        try {
          abstractSqlModel = LF2AbstractSQLTranslator(lfModel, 'Process');
          sqlModel = AbstractSQLCompiler.compileSchema(abstractSqlModel);
          metadata = ODataMetadataGenerator(vocab, sqlModel);
        } catch (error) {
          e = error;
          console.error('Error compiling model', vocab, e, e.stack);
          throw new Error(['Error compiling model', e]);
        }
        return Promise.each(sqlModel.createSchema, function(createStatement) {
          var promise;
          promise = tx.executeSql(createStatement);
          if (db.engine === 'websql') {
            promise["catch"](function(err) {
              return console.warn("Ignoring errors in the create table statements for websql as it doesn't support CREATE IF NOT EXISTS", err);
            });
          }
          return promise;
        }).then(function() {
          seModels[vocab] = seModel;
          abstractSqlModels[vocab] = abstractSqlModel;
          sqlModels[vocab] = sqlModel;
          odataMetadata[vocab] = metadata;
          uriParser.addClientModel(vocab, abstractSqlModel);
          return validateModel(tx, vocab);
        }).then(function() {
          var key, ref2, ref3, ref4, ref5, value;
          api[vocab] = new PinejsClient('/' + vocab + '/');
          api[vocab].logger = {};
          for (key in console) {
            value = console[key];
            if (_.isFunction(value)) {
              if ((ref2 = (ref3 = (ref4 = model.logging) != null ? ref4[key] : void 0) != null ? ref3 : (ref5 = model.logging) != null ? ref5["default"] : void 0) != null ? ref2 : true) {
                api[vocab].logger[key] = _.bind(value, console, vocab + ':');
              } else {
                api[vocab].logger[key] = function() {};
              }
            } else {
              api[vocab].logger[key] = value;
            }
          }
          return {
            vocab: vocab,
            se: seModel,
            lf: lfModel,
            abstractsql: abstractSqlModel,
            sql: sqlModel
          };
        });
      });
    }).map(function(model) {
      var updateModel;
      updateModel = function(modelType, modelText) {
        return api.dev.get({
          resource: 'model',
          passthrough: {
            tx: tx,
            req: permissions.rootRead
          },
          options: {
            select: 'id',
            filter: {
              is_of__vocabulary: model.vocab,
              model_type: modelType
            }
          }
        }).then(function(result) {
          var body, id, method, ref2, uri;
          method = 'POST';
          uri = '/dev/model';
          body = {
            is_of__vocabulary: model.vocab,
            model_value: modelText,
            model_type: modelType
          };
          id = (ref2 = result[0]) != null ? ref2.id : void 0;
          if (id != null) {
            uri += '(' + id + ')';
            method = 'PATCH';
            body.id = id;
          }
          return runURI(method, uri, body, tx, permissions.root);
        });
      };
      return Promise.all([updateModel('se', model.se), updateModel('lf', model.lf), updateModel('abstractsql', model.abstractsql), updateModel('sql', model.sql)]);
    })["catch"](function(err) {
      Promise.map(models, function(model) {
        return cleanupModel(model.apiRoot);
      });
      throw err;
    }).nodeify(callback);
  };

  cleanupModel = function(vocab) {
    delete seModels[vocab];
    delete abstractSqlModels[vocab];
    delete sqlModels[vocab];
    delete odataMetadata[vocab];
    uriParser.deleteClientModel(vocab);
    return delete api[vocab];
  };

  getHooks = (function() {
    var getMethodHooks, getResourceHooks, getVocabHooks, mergeHooks;
    mergeHooks = function(a, b) {
      return _.mergeWith({}, a, b, function(a, b) {
        if (_.isArray(a)) {
          return a.concat(b);
        }
      });
    };
    getResourceHooks = function(vocabHooks, resourceName) {
      if (vocabHooks == null) {
        return {};
      }
      if (resourceName == null) {
        return vocabHooks['all'];
      }
      return mergeHooks(vocabHooks[resourceName], vocabHooks['all']);
    };
    getVocabHooks = function(methodHooks, request) {
      var resourceName;
      if (methodHooks == null) {
        return {};
      }
      if (request.resourceName != null) {
        resourceName = resolveSynonym(request);
      }
      return mergeHooks(getResourceHooks(methodHooks[request.vocabulary], resourceName), getResourceHooks(methodHooks['all'], resourceName));
    };
    return getMethodHooks = function(request) {
      return mergeHooks(getVocabHooks(apiHooks[request.method], request), getVocabHooks(apiHooks['all'], request));
    };
  })();

  runHook = function(hookName, args) {
    var hooks;
    Object.defineProperty(args, 'api', {
      get: _.once(function() {
        return api[args.request.vocabulary].clone({
          passthrough: _.pick(args, 'req', 'tx')
        });
      })
    });
    hooks = args.req.hooks[hookName] || [];
    return Promise.map(hooks, function(hook) {
      return hook(args);
    });
  };

  exports.deleteModel = function(vocabulary, callback) {
    return db.transaction().then(function(tx) {
      var dropStatements, ref2;
      dropStatements = _.map((ref2 = sqlModels[vocabulary]) != null ? ref2.dropSchema : void 0, function(dropStatement) {
        return tx.executeSql(dropStatement);
      });
      return Promise.all(dropStatements.concat([
        api.dev["delete"]({
          resource: 'model',
          passthrough: {
            tx: tx,
            req: permissions.root
          },
          options: {
            filter: {
              is_of__vocabulary: vocabulary
            }
          }
        })
      ])).then(function() {
        tx.end();
        return cleanupModel(vocabulary);
      })["catch"](function(err) {
        tx.rollback();
        throw err;
      });
    }).nodeify(callback);
  };

  exports.getID = function(vocab, request) {
    var comparison, idField, j, k, len, len1, ref2, ref3, whereClause;
    idField = sqlModels[vocab].tables[request.resourceName].idField;
    ref2 = request.abstractSqlQuery;
    for (j = 0, len = ref2.length; j < len; j++) {
      whereClause = ref2[j];
      if (whereClause[0] === 'Where') {
        ref3 = whereClause.slice(1);
        for (k = 0, len1 = ref3.length; k < len1; k++) {
          comparison = ref3[k];
          if (!(comparison[0] === 'Equals')) {
            continue;
          }
          if (comparison[1][2] === idField) {
            return comparison[2][1];
          }
          if (comparison[2][2] === idField) {
            return comparison[1][1];
          }
        }
      }
    }
    return 0;
  };

  checkForExpansion = (function() {
    var rowsObjectHack;
    rowsObjectHack = function(i) {
      return this[i];
    };
    return Promise.method(function(vocab, abstractSqlModel, parentResourceName, fieldName, instance) {
      var field, mapping, mappingResourceName, navigation;
      try {
        field = JSON.parse(instance[fieldName]);
      } catch (error) {
        field = instance[fieldName];
      }
      if (_.isArray(field)) {
        field.item = rowsObjectHack;
        navigation = odataNameToSqlName(fieldName).split('-').join('.');
        mapping = _.get(abstractSqlModel.relationships[parentResourceName], navigation);
        mappingResourceName = mapping[1][0];
        console.log('expand mapping', mapping);
        console.log('expand mappingResourceName', mappingResourceName);
        return processOData(vocab, abstractSqlModel, mappingResourceName, field).then(function(expandedField) {
          console.log('expand expandedField', parentResourceName, fieldName, expandedField);
          instance[fieldName] = expandedField;
        });
      } else if (field != null) {
        navigation = odataNameToSqlName(fieldName).split('-').join('.');
        mapping = _.get(abstractSqlModel.relationships[parentResourceName], navigation);
        mappingResourceName = mapping[1][0];
        console.log('deferred mapping', mapping);
        instance[fieldName] = {
          __deferred: {
            uri: '/' + vocab + '/' + mappingResourceName + '(' + field + ')'
          },
          __id: field
        };
      }
    });
  })();

  odataResourceURI = function(vocab, resourceName, id) {
    id = _.isString(id) ? "'" + encodeURIComponent(id) + "'" : id;
    return '/' + vocab + '/' + resourceName + '(' + id + ')';
  };

  processOData = (function() {
    var getFetchProcessingFields, getLocalFields;
    getLocalFields = function(table) {
      var dataType, fieldName, j, len, odataName, ref2, ref3;
      if (table.localFields == null) {
        table.localFields = {};
        ref2 = table.fields;
        for (j = 0, len = ref2.length; j < len; j++) {
          ref3 = ref2[j], fieldName = ref3.fieldName, dataType = ref3.dataType;
          if (!(dataType !== 'ForeignKey')) {
            continue;
          }
          odataName = sqlNameToODataName(fieldName);
          table.localFields[odataName] = true;
        }
      }
      return table.localFields;
    };
    getFetchProcessingFields = function(table) {
      return table.fetchProcessingFields != null ? table.fetchProcessingFields : table.fetchProcessingFields = _(table.fields).filter(function(arg) {
        var dataType;
        dataType = arg.dataType;
        return fetchProcessing[dataType] != null;
      }).map(function(arg) {
        var dataType, fieldName, odataName;
        fieldName = arg.fieldName, dataType = arg.dataType;
        odataName = sqlNameToODataName(fieldName);
        return [odataName, fetchProcessing[dataType]];
      }).fromPairs().value();
    };
    return function(vocab, abstractSqlModel, resourceName, rows) {
      var count, expandableFields, fetchProcessingFields, instances, instancesPromise, localFields, odataIdField, processedFields, sqlResourceName, table;
      if (rows.length === 0) {
        return Promise.fulfilled([]);
      }
      if (rows.length === 1) {
        if (rows.item(0).$count != null) {
          count = parseInt(rows.item(0).$count, 10);
          return Promise.fulfilled(count);
        }
      }
      sqlResourceName = resolveSynonym({
        vocabulary: vocab,
        resourceName: resourceName
      });
      table = abstractSqlModel.tables[sqlResourceName];
      odataIdField = sqlNameToODataName(table.idField);
      instances = rows.map(function(instance) {
        instance.__metadata = {
          uri: odataResourceURI(vocab, resourceName, +instance[odataIdField]),
          type: ''
        };
        return instance;
      });
      instancesPromise = Promise.fulfilled();
      localFields = getLocalFields(table);
      expandableFields = _.filter(_.keys(instances[0]), function(fieldName) {
        return fieldName.slice(0, 2) !== '__' && !localFields.hasOwnProperty(fieldName);
      });
      if (expandableFields.length > 0) {
        instancesPromise = Promise.map(instances, function(instance) {
          return Promise.map(expandableFields, function(fieldName) {
            return checkForExpansion(vocab, abstractSqlModel, sqlResourceName, fieldName, instance);
          });
        });
      }
      fetchProcessingFields = getFetchProcessingFields(table);
      processedFields = _.filter(_.keys(instances[0]), function(fieldName) {
        return fieldName.slice(0, 2) !== '__' && fetchProcessingFields.hasOwnProperty(fieldName);
      });
      if (processedFields.length > 0) {
        instancesPromise = instancesPromise.then(function() {
          return Promise.map(instances, function(instance) {
            return Promise.map(processedFields, function(resourceName) {
              return fetchProcessingFields[resourceName](instance[resourceName]).then(function(result) {
                instance[resourceName] = result;
              });
            });
          });
        });
      }
      return instancesPromise.then(function() {
        return instances;
      });
    };
  })();

  exports.runRule = (function() {
    var LF2AbstractSQLPrepHack, translator;
    LF2AbstractSQLPrepHack = LF2AbstractSQL.LF2AbstractSQLPrep._extend({
      CardinalityOptimisation: function() {
        return this._pred(false);
      }
    });
    translator = LF2AbstractSQL.LF2AbstractSQL.createInstance();
    translator.addTypes(sbvrTypes);
    return function(vocab, rule, callback) {
      return Promise["try"](function() {
        var abstractSqlModel, e, fetchingViolators, formulationType, lfModel, logger, resourceName, ruleAbs, ruleBody, ruleLF, ruleSQL, seModel, slfModel, wantNonViolators;
        seModel = seModels[vocab];
        logger = api[vocab].logger;
        try {
          lfModel = SBVRParser.matchAll(seModel + '\nRule: ' + rule, 'Process');
        } catch (error) {
          e = error;
          logger.error('Error parsing rule', rule, e, e.stack);
          throw new Error(['Error parsing rule', rule, e]);
        }
        ruleLF = lfModel[lfModel.length - 1];
        lfModel = lfModel.slice(0, -1);
        try {
          slfModel = LF2AbstractSQL.LF2AbstractSQLPrep.match(lfModel, 'Process');
          slfModel.push(ruleLF);
          slfModel = LF2AbstractSQLPrepHack.match(slfModel, 'Process');
          translator.reset();
          abstractSqlModel = translator.match(slfModel, 'Process');
        } catch (error) {
          e = error;
          logger.error('Error compiling rule', rule, e, e.stack);
          throw new Error(['Error compiling rule', rule, e]);
        }
        formulationType = ruleLF[1][0];
        resourceName = ruleLF[1][1][0] === 'LogicalNegation' ? ruleLF[1][1][1][1][2][1] : ruleLF[1][1][1][2][1];
        fetchingViolators = false;
        ruleAbs = abstractSqlModel.rules.slice(-1)[0];
        ruleBody = _.find(ruleAbs, {
          0: 'Body'
        });
        if (ruleBody[1][0] === 'Not' && ruleBody[1][1][0] === 'Exists' && ruleBody[1][1][1][0] === 'SelectQuery') {
          ruleBody[1] = ruleBody[1][1][1];
          fetchingViolators = true;
        } else if (ruleBody[1][0] === 'Exists' && ruleBody[1][1][0] === 'SelectQuery') {
          ruleBody[1] = ruleBody[1][1];
        } else {
          throw new Error('Unsupported rule formulation');
        }
        wantNonViolators = formulationType === 'PossibilityFormulation' || formulationType === 'PermissibilityFormulation';
        if (wantNonViolators === fetchingViolators) {
          ruleBody[1] = _.map(ruleBody[1], function(queryPart) {
            if (queryPart[0] !== 'Where') {
              return queryPart;
            }
            if (queryPart.length > 2) {
              throw new Error('Unsupported rule formulation');
            }
            return ['Where', ['Not', queryPart[1]]];
          });
        }
        ruleBody[1] = _.map(ruleBody[1], function(queryPart) {
          if (queryPart[0] !== 'Select') {
            return queryPart;
          }
          return ['Select', '*'];
        });
        ruleSQL = AbstractSQLCompiler.compileRule(ruleBody);
        return db.executeSql(ruleSQL.query, ruleSQL.bindings).then(function(result) {
          var filter, ids, odataIdField, table;
          table = abstractSqlModels[vocab].tables[resourceName];
          odataIdField = sqlNameToODataName(table.idField);
          ids = result.rows.map(function(row) {
            return row[table.idField];
          });
          ids = _.uniq(ids);
          ids = _.map(ids, function(id) {
            return odataIdField + ' eq ' + id;
          });
          filter = ids.length > 0 ? ids.join(' or ') : '0 eq 1';
          return runURI('GET', '/' + vocab + '/' + sqlNameToODataName(table.resourceName) + '?$filter=' + filter, null, null, permissions.rootRead).then(function(result) {
            result.__formulationType = formulationType;
            result.__resourceName = resourceName;
            return result;
          });
        });
      }).nodeify(callback);
    };
  })();

  exports.PinejsClient = PinejsClient = (function(superClass) {
    extend(PinejsClient, superClass);

    function PinejsClient() {
      return PinejsClient.__super__.constructor.apply(this, arguments);
    }

    PinejsClient.prototype._request = function(arg) {
      var body, custom, method, req, tx, url;
      method = arg.method, url = arg.url, body = arg.body, tx = arg.tx, req = arg.req, custom = arg.custom;
      return runURI(method, url, body, tx, req, custom);
    };

    return PinejsClient;

  })(PinejsClientCore(_, Promise));

  exports.api = api = {};

  exports.runURI = runURI = function(method, uri, body, tx, req, custom, callback) {
    var apiKey, message, user, x;
    if (body == null) {
      body = {};
    }
    if ((callback != null) && !_.isFunction(callback)) {
      message = 'Called runURI with a non-function callback?!';
      console.trace(message);
      return Promise.rejected(message);
    }
    if (_.isObject(req)) {
      user = req.user;
      apiKey = req.apiKey;
    } else {
      if (req != null) {
        console.warn('Non-object req passed to runURI?', req, new Error().stack);
      }
      user = {
        permissions: []
      };
    }
    req = {
      custom: custom,
      user: user,
      apiKey: apiKey,
      method: method,
      url: uri,
      body: body,
      params: {},
      query: {},
      tx: tx
    };
    x = new Error('Uri from..');
    return new Promise(function(resolve, reject) {
      var next, res;
      res = {
        statusCode: 200,
        status: function(statusCode1) {
          this.statusCode = statusCode1;
          return this;
        },
        sendStatus: function(statusCode) {
          if (statusCode >= 400) {
            return reject(statusCode);
          } else {
            return resolve();
          }
        },
        send: function(statusCode) {
          if (statusCode == null) {
            statusCode = this.statusCode;
          }
          return this.sendStatus(statusCode);
        },
        json: function(data, statusCode) {
          if (statusCode == null) {
            statusCode = this.statusCode;
          }
          if (statusCode >= 400) {
            return reject(data);
          } else {
            return resolve(data);
          }
        },
        set: function() {},
        type: function() {}
      };
      next = function(route) {
        console.warn('Next called on a runURI?!', method, uri, route);
        return res.sendStatus(500);
      };
      return handleODataRequest(req, res, next);
    }).tapCatch(function(err) {
      return console.log('Error from....', x);
    }).nodeify(callback);
  };

  exports.handleODataRequest = handleODataRequest = function(req, res, next) {
    var apiRoot, mapPar, mapSeries, ref2, url;
    url = req.url.split('/');
    apiRoot = url[1];
    if ((apiRoot == null) || (abstractSqlModels[apiRoot] == null)) {
      return next('route');
    }
    if (process.env.DEBUG) {
      api[apiRoot].logger.log('Parsing', req.method, req.url);
    }
    ref2 = controlFlow.getMappingFn(req.headers), mapPar = ref2.mapPar, mapSeries = ref2.mapSeries;
    req.hooks = getHooks({
      method: req.method,
      vocabulary: apiRoot
    });
    return runHook('PREPARSE', {
      req: req,
      tx: req.tx
    }).then(function() {
      var body, method, ref3;
      method = req.method, url = req.url, body = req.body;
      body = ((ref3 = req.batch) != null ? ref3.length : void 0) > 0 ? req.batch : [
        {
          method: method,
          url: url,
          data: body
        }
      ];
      return mapSeries(body, function(bodypart) {
        return uriParser.parseOData(bodypart).then(controlFlow.liftP(function(request) {
          req.hooks = getHooks(request);
          return runHook('POSTPARSE', {
            req: req,
            request: request,
            tx: req.tx
          })["return"](request).then(uriParser.translateUri).then(function(request) {
            var err;
            if ((request.abstractSqlQuery != null) && !request._defer) {
              try {
                request.sqlQuery = memoizedCompileRule(request.abstractSqlQuery);
              } catch (error) {
                err = error;
                api[apiRoot].logger.error('Failed to compile abstract sql: ', request.abstractSqlQuery, err, err.stack);
                throw new SqlCompilationError(err);
              }
            }
            return request;
          });
        })).then(function(request) {
          return runTransaction(req, request, function(tx) {
            var env;
            if (_.isArray(request)) {
              env = new Map();
              return Promise.reduce(request, runChangeSet(req, res, tx), env).then(function(env) {
                return Array.from(env.values());
              });
            } else {
              return runRequest(req, res, tx, request);
            }
          });
        });
      });
    }).then(function(results) {
      return mapSeries(results, function(result) {
        if (_.isError(result)) {
          return constructError(result);
        } else {
          return result;
        }
      });
    }).then(function(responses) {
      var ref3, response;
      res.set('Cache-Control', 'no-cache');
      if (!((ref3 = req.batch) != null ? ref3.length : void 0) > 0) {
        response = responses[0];
        if (response.status) {
          res.status(response.status);
        }
        _.forEach(response.headers, function(headerValue, headerName) {
          return res.set(headerName, headerValue);
        });
        if (!response.body) {
          return res.sendStatus(response.status);
        } else {
          return res.json(response.body);
        }
      } else {
        return res.status(200).sendMulti(responses);
      }
    })["catch"](function(e) {
      console.error('An error occured while constructing the response', e, e.stack);
      return res.sendStatus(500);
    });
  };

  constructError = function(e) {
    return Promise.reject(e)["catch"](SbvrValidationError, function(err) {
      return {
        status: 400,
        body: err.message
      };
    })["catch"](uriParser.BadRequestError, function() {
      return {
        status: 400
      };
    })["catch"](permissions.PermissionError, function(err) {
      return {
        status: 401
      };
    })["catch"](SqlCompilationError, uriParser.TranslationError, uriParser.ParsingError, permissions.PermissionParsingError, InternalRequestError, function(err) {
      return {
        status: 500
      };
    })["catch"](UnsupportedMethodError, function(err) {
      return {
        status: 405
      };
    })["catch"](e, function(err) {
      console.error(err);
      if (_.isError(err)) {
        err = err.message;
      }
      return {
        status: 404,
        body: err
      };
    });
  };

  runRequest = function(req, res, tx, request) {
    var logger;
    logger = api[request.vocabulary].logger;
    if (process.env.DEBUG) {
      logger.log('Running', req.method, req.url);
    }
    return runHook('PRERUN', {
      req: req,
      request: request,
      tx: tx
    }).then(function() {
      switch (request.method) {
        case 'GET':
          return runGet(req, res, request, tx);
        case 'POST':
          return runPost(req, res, request, tx);
        case 'PUT':
        case 'PATCH':
        case 'MERGE':
          return runPut(req, res, request, tx);
        case 'DELETE':
          return runDelete(req, res, request, tx);
      }
    })["catch"](db.DatabaseError, function(err) {
      prettifyConstraintError(err, request.resourceName);
      logger.error(err, err.stack);
      throw err;
    })["catch"](EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, function(err) {
      logger.error(err, err.stack);
      throw new InternalRequestError();
    }).tap(function(result) {
      return runHook('POSTRUN', {
        req: req,
        request: request,
        result: result,
        tx: tx
      });
    }).then(function(result) {
      return prepareResponse(req, res, request, result, tx);
    });
  };

  runChangeSet = function(req, res, tx) {
    return function(env, request) {
      request = updateBinds(env, request);
      return runRequest(req, res, tx, request).then(function(result) {
        result.headers['Content-Id'] = request.id;
        env.set(request.id, result);
        return env;
      });
    };
  };

  updateBinds = function(env, request) {
    if (request._defer) {
      request.odataBinds = _.map(request.odataBinds, function(arg) {
        var id, ref, ref2, tag;
        tag = arg[0], id = arg[1];
        if (tag === 'ContentReference') {
          ref = env.get(id);
          if (_.isUndefined(ref != null ? (ref2 = ref.body) != null ? ref2.id : void 0 : void 0)) {
            throw uriParser.BadRequestError('Reference to a non existing resource in Changeset');
          } else {
            return uriParser.parseId(ref.body.id);
          }
        } else {
          return [tag, id];
        }
      });
      request.sqlQuery = memoizedCompileRule(request.abstractSqlQuery);
    }
    return request;
  };

  prepareResponse = function(req, res, request, result, tx) {
    return Promise["try"](function() {
      switch (request.method) {
        case 'GET':
          return respondGet(req, res, request, result, tx);
        case 'POST':
          return respondPost(req, res, request, result, tx);
        case 'PUT':
        case 'PATCH':
        case 'MERGE':
          return respondPut(req, res, request, result, tx);
        case 'DELETE':
          return respondDelete(req, res, request, result, tx);
        case 'OPTIONS':
          return respondOptions(req, res, request, result, tx);
        default:
          throw new UnsupportedMethodError();
      }
    });
  };

  runTransaction = function(req, request, callback) {
    var runCallback;
    runCallback = function(tx) {
      return callback(tx);
    };
    if (req.tx != null) {
      return runCallback(req.tx);
    } else {
      return db.transaction().then(function(tx) {
        return runCallback(tx).tap(function() {
          return tx.end();
        })["catch"](function(err) {
          tx.rollback();
          throw err;
        });
      });
    }
  };

  runQuery = function(tx, request, queryIndex, addReturning) {
    var odataBinds, sqlQuery, values, vocabulary;
    values = request.values, odataBinds = request.odataBinds, sqlQuery = request.sqlQuery, vocabulary = request.vocabulary;
    if (queryIndex != null) {
      sqlQuery = sqlQuery[queryIndex];
    }
    return getAndCheckBindValues(vocabulary, odataBinds, sqlQuery.bindings, values).then(function(values) {
      if (process.env.DEBUG) {
        api[vocabulary].logger.log(sqlQuery.query, values);
      }
      sqlQuery.values = values;
      return tx.executeSql(sqlQuery.query, values, null, addReturning);
    });
  };

  runGet = function(req, res, request, tx) {
    if (request.sqlQuery != null) {
      return runQuery(tx, request);
    }
  };

  respondGet = function(req, res, request, result, tx) {
    var vocab;
    vocab = request.vocabulary;
    if (request.sqlQuery != null) {
      return processOData(vocab, abstractSqlModels[vocab], request.resourceName, result.rows).then(function(d) {
        return runHook('PRERESPOND', {
          req: req,
          res: res,
          request: request,
          result: result,
          data: d,
          tx: tx
        }).then(function() {
          return {
            body: {
              d: d
            },
            headers: {
              contentType: 'application/json'
            }
          };
        });
      });
    } else {
      if (request.resourceName === '$metadata') {
        return {
          body: odataMetadata[vocab],
          headers: {
            contentType: 'xml'
          }
        };
      } else {
        return {
          status: 404
        };
      }
    }
  };

  runPost = function(req, res, request, tx) {
    var idField, vocab;
    vocab = request.vocabulary;
    idField = abstractSqlModels[vocab].tables[resolveSynonym(request)].idField;
    return runQuery(tx, request, null, idField).then(function(sqlResult) {
      return validateModel(tx, vocab, request).then(function() {
        if (request.abstractSqlQuery[0] === 'UpdateQuery') {
          return request.sqlQuery.values[0];
        } else {
          return sqlResult.insertId;
        }
      });
    });
  };

  respondPost = function(req, res, request, result, tx) {
    var id, location, vocab;
    vocab = request.vocabulary;
    id = result;
    location = odataResourceURI(vocab, request.resourceName, id);
    api[vocab].logger.log('Insert ID: ', request.resourceName, id);
    return runURI('GET', location, null, tx, req)["catch"](function() {
      return {
        d: [
          {
            id: id
          }
        ]
      };
    }).then(function(result) {
      return runHook('PRERESPOND', {
        req: req,
        res: res,
        request: request,
        result: result,
        tx: tx
      }).then(function() {
        return {
          status: 201,
          body: result.d[0],
          headers: {
            contentType: 'application/json',
            Location: location
          }
        };
      });
    });
  };

  runPut = function(req, res, request, tx) {
    var vocab;
    vocab = request.vocabulary;
    return Promise["try"](function() {
      if (_.isArray(request.sqlQuery)) {
        return runQuery(tx, request, 1).then(function(result) {
          if (result.rowsAffected === 0) {
            return runQuery(tx, request, 0);
          }
        });
      } else {
        return runQuery(tx, request);
      }
    }).then(function() {
      return validateModel(tx, vocab, request);
    });
  };

  respondPut = respondDelete = respondOptions = function(req, res, request, tx) {
    return runHook('PRERESPOND', {
      req: req,
      res: res,
      request: request,
      tx: tx
    }).then(function() {
      return {
        status: 200,
        headers: {}
      };
    });
  };

  runDelete = function(req, res, request, tx) {
    var vocab;
    vocab = request.vocabulary;
    return runQuery(tx, request).then(function() {
      return validateModel(tx, vocab, request);
    });
  };

  exports.executeStandardModels = executeStandardModels = function(tx, callback) {
    return executeModel(tx, {
      apiRoot: 'dev',
      modelText: devModel,
      logging: {
        log: false
      }
    }).then(function() {
      return executeModels(tx, permissions.config.models);
    }).then(function() {
      return console.info('Sucessfully executed standard models.');
    })["catch"](function(err) {
      console.error('Failed to execute standard models.', err, err.stack);
      throw err;
    }).nodeify(callback);
  };

  exports.addHook = function(method, apiRoot, resourceName, callbacks) {
    var apiRootHooks, callback, callbackType, methodHooks, origResourceName, resourceHooks, results1;
    methodHooks = apiHooks[method];
    if (methodHooks == null) {
      throw new Error('Unsupported method: ' + method);
    }
    if (apiRoot !== 'all' && (abstractSqlModels[apiRoot] == null)) {
      throw new Error('Unknown api root: ' + apiRoot);
    }
    if (resourceName !== 'all') {
      origResourceName = resourceName;
      resourceName = resolveSynonym({
        vocabulary: apiRoot,
        resourceName: resourceName
      });
      if (abstractSqlModels[apiRoot].tables[resourceName] == null) {
        throw new Error('Unknown resource for api root: ' + origResourceName + ', ' + apiRoot);
      }
    }
    for (callbackType in callbacks) {
      callback = callbacks[callbackType];
      if (callbackType !== 'PREPARSE' && callbackType !== 'POSTPARSE' && callbackType !== 'PRERUN' && callbackType !== 'POSTRUN' && callbackType !== 'PRERESPOND') {
        throw new Error('Unknown callback type: ' + callbackType);
      }
    }
    apiRootHooks = methodHooks[apiRoot] != null ? methodHooks[apiRoot] : methodHooks[apiRoot] = {};
    resourceHooks = apiRootHooks[resourceName] != null ? apiRootHooks[resourceName] : apiRootHooks[resourceName] = {};
    results1 = [];
    for (callbackType in callbacks) {
      callback = callbacks[callbackType];
      if (resourceHooks[callbackType] == null) {
        resourceHooks[callbackType] = [];
      }
      results1.push(resourceHooks[callbackType].push(callback));
    }
    return results1;
  };

  exports.setup = function(app, _db, callback) {
    exports.db = db = _db;
    AbstractSQLCompiler = AbstractSQLCompiler[db.engine];
    return db.transaction().then(function(tx) {
      return executeStandardModels(tx).then(function() {
        permissions.setup(app, exports);
        _.extend(exports, permissions);
        return tx.end();
      })["catch"](function(err) {
        tx.rollback();
        console.error('Could not execute standard models', err, err.stack);
        return process.exit(1);
      });
    }).then(function() {
      return db.executeSql('CREATE UNIQUE INDEX "uniq_model_model_type_vocab" ON "model" ("is_of__vocabulary", "model type");')["catch"](function() {});
    }).nodeify(callback);
  };

}).call(this);

//# sourceMappingURL=sbvr-utils.js.map
