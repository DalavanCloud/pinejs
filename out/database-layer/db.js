// Generated by CoffeeScript 1.12.6
(function() {
  var ConnectionParameters, ConstraintError, DEFAULT_VALUE, DatabaseError, ForeignKeyConstraintError, NotADatabaseError, Promise, Tx, TypedError, UniqueConstraintError, _, alwaysExport, atomicExecuteSql, bindDefaultValues, createTransaction, mysql, pg, sqlBinds,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Promise = require('bluebird');

  sqlBinds = require('./sql-binds');

  TypedError = require('typed-error');

  DatabaseError = (function(superClass) {
    extend(DatabaseError, superClass);

    function DatabaseError(message) {
      if ((message != null ? message.code : void 0) != null) {
        this.code = message.code;
      }
      if ((message != null ? message.constructor.name : void 0) === 'SQLError') {
        message = message.message;
      }
      DatabaseError.__super__.constructor.call(this, message);
    }

    return DatabaseError;

  })(TypedError);

  ConstraintError = (function(superClass) {
    extend(ConstraintError, superClass);

    function ConstraintError() {
      return ConstraintError.__super__.constructor.apply(this, arguments);
    }

    return ConstraintError;

  })(DatabaseError);

  UniqueConstraintError = (function(superClass) {
    extend(UniqueConstraintError, superClass);

    function UniqueConstraintError() {
      return UniqueConstraintError.__super__.constructor.apply(this, arguments);
    }

    return UniqueConstraintError;

  })(ConstraintError);

  ForeignKeyConstraintError = (function(superClass) {
    extend(ForeignKeyConstraintError, superClass);

    function ForeignKeyConstraintError() {
      return ForeignKeyConstraintError.__super__.constructor.apply(this, arguments);
    }

    return ForeignKeyConstraintError;

  })(ConstraintError);

  NotADatabaseError = function(err) {
    return !(err instanceof DatabaseError);
  };

  DEFAULT_VALUE = {};

  bindDefaultValues = function(sql, bindings) {
    var bindNo;
    if (!_.some(bindings, function(binding) {
      return binding === DEFAULT_VALUE;
    })) {
      return sql;
    }
    bindNo = 0;
    return sqlBinds(sql, function() {
      if (bindings[bindNo] === DEFAULT_VALUE) {
        bindings.splice(bindNo, 1);
        return 'DEFAULT';
      } else {
        bindNo++;
        return '?';
      }
    });
  };

  alwaysExport = {
    DEFAULT_VALUE: DEFAULT_VALUE,
    DatabaseError: DatabaseError,
    ConstraintError: ConstraintError,
    UniqueConstraintError: UniqueConstraintError,
    ForeignKeyConstraintError: ForeignKeyConstraintError
  };

  atomicExecuteSql = function(sql, bindings, callback) {
    return this.transaction().then(function(tx) {
      var result;
      result = tx.executeSql(sql, bindings);
      return result["finally"](function() {
        if (result.isRejected()) {
          return tx.rollback();
        } else {
          return tx.end();
        }
      });
    }).nodeify(callback);
  };

  Tx = (function() {
    var timeoutMS;

    if (process.env.TRANSACTION_TIMEOUT_MS) {
      timeoutMS = parseInt(process.env.TRANSACTION_TIMEOUT_MS);
      if (_.isNaN(timeoutMS) || timeoutMS <= 0) {
        throw new Error("Invalid valid for TRANSACTION_TIMEOUT_MS: " + process.env.TRANSACTION_TIMEOUT_MS);
      }
    } else {
      timeoutMS = 10000;
    }

    function Tx(stackTraceErr, executeSql, rollback, end) {
      var automaticClose, closeTransaction, pendingExecutes;
      automaticClose = (function(_this) {
        return function() {
          console.error('Transaction still open after ' + timeoutMS + 'ms without an execute call.', stackTraceErr.stack);
          return _this.rollback();
        };
      })(this);
      pendingExecutes = (function() {
        var automaticCloseTimeout, pending;
        automaticCloseTimeout = setTimeout(automaticClose, timeoutMS);
        pending = 0;
        return {
          increment: function() {
            if (pending === false) {
              return;
            }
            pending++;
            return clearTimeout(automaticCloseTimeout);
          },
          decrement: function() {
            if (pending === false) {
              return;
            }
            pending--;
            if (pending === 0) {
              return automaticCloseTimeout = setTimeout(automaticClose, timeoutMS);
            } else if (pending < 0) {
              console.error('Pending transactions is less than 0, wtf?');
              return pending = 0;
            }
          },
          cancel: function() {
            pending = false;
            return clearTimeout(automaticCloseTimeout);
          }
        };
      })();
      this.executeSql = function() {
        var args, bindings, callback, sql;
        sql = arguments[0], bindings = arguments[1], callback = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
        if (bindings == null) {
          bindings = [];
        }
        pendingExecutes.increment();
        sql = bindDefaultValues(sql, bindings);
        return executeSql.apply(null, [sql, bindings].concat(slice.call(args)))["finally"](pendingExecutes.decrement)["catch"](NotADatabaseError, function(err) {
          throw new DatabaseError(err);
        }).nodeify(callback);
      };
      this.rollback = function(callback) {
        var promise;
        promise = rollback();
        closeTransaction('Transaction has been rolled back.');
        return promise.nodeify(callback);
      };
      this.end = function(callback) {
        var promise;
        promise = end();
        closeTransaction('Transaction has been ended.');
        return promise.nodeify(callback);
      };
      closeTransaction = (function(_this) {
        return function(message) {
          var rejectionValue;
          pendingExecutes.cancel();
          rejectionValue = new Error(message);
          _this.executeSql = function(sql, bindings, callback) {
            return Promise.rejected(rejectionValue).nodeify(callback);
          };
          return _this.rollback = _this.end = function(callback) {
            return Promise.rejected(rejectionValue).nodeify(callback);
          };
        };
      })(this);
    }

    return Tx;

  })();

  createTransaction = function(createFunc) {
    return function(callback) {
      var promise, stackTraceErr;
      stackTraceErr = new Error();
      promise = new Promise(function(resolve, reject) {
        return createFunc(resolve, reject, stackTraceErr);
      });
      if (callback != null) {
        promise.tap(callback)["catch"](function(err) {
          return console.error(err, callback);
        });
      }
      return promise;
    };
  };

  try {
    pg = require('pg');
    ConnectionParameters = require('pg/lib/connection-parameters');
  } catch (error) {}

  if (pg != null) {
    exports.postgres = function(connectString) {
      var PG_FOREIGN_KEY_VIOLATION, PG_UNIQUE_VIOLATION, PostgresTx, config, createResult, pool;
      PG_UNIQUE_VIOLATION = '23505';
      PG_FOREIGN_KEY_VIOLATION = '23503';
      config = new ConnectionParameters(connectString);
      config.Promise = Promise;
      config.max = pg.defaults.poolSize;
      config.idleTimeoutMillis = pg.defaults.poolIdleTimeout;
      config.log = pg.defaults.poolLog;
      pool = new pg.Pool(config);
      createResult = function(arg) {
        var ref, rowCount, rows;
        rowCount = arg.rowCount, rows = arg.rows;
        return {
          rows: {
            length: (rows != null ? rows.length : void 0) || 0,
            item: function(i) {
              return rows[i];
            },
            forEach: function(iterator, thisArg) {
              return rows.forEach(iterator, thisArg);
            },
            map: function(iterator, thisArg) {
              return rows.map(iterator, thisArg);
            }
          },
          rowsAffected: rowCount,
          insertId: ((ref = rows[0]) != null ? ref.id : void 0) || null
        };
      };
      PostgresTx = (function(superClass) {
        extend(PostgresTx, superClass);

        function PostgresTx(_db, _close, _stackTraceErr) {
          var end, executeSql, rollback;
          executeSql = function(sql, bindings, addReturning) {
            var bindNo;
            if (addReturning == null) {
              addReturning = false;
            }
            bindings = bindings.slice(0);
            if (addReturning && /^\s*INSERT\s+INTO/i.test(sql)) {
              sql = sql.replace(/;?$/, ' RETURNING "' + addReturning + '";');
            }
            if (_.includes(sql, '?')) {
              bindNo = 0;
              sql = sqlBinds(sql, function() {
                var bindString, binding, initialBindNo;
                if (Array.isArray(bindings[bindNo])) {
                  initialBindNo = bindNo;
                  bindString = ((function() {
                    var j, len, ref, results;
                    ref = bindings[initialBindNo];
                    results = [];
                    for (j = 0, len = ref.length; j < len; j++) {
                      binding = ref[j];
                      results.push('$' + ++bindNo);
                    }
                    return results;
                  })()).join(',');
                  Array.prototype.splice.apply(bindings, [initialBindNo, 1].concat(bindings[initialBindNo]));
                  return bindString;
                } else if (bindings[bindNo] === DEFAULT_VALUE) {
                  bindings.splice(bindNo, 1);
                  return 'DEFAULT';
                } else {
                  return '$' + ++bindNo;
                }
              });
            }
            return Promise.fromCallback(function(callback) {
              return _db.query({
                text: sql,
                values: bindings
              }, callback);
            })["catch"]({
              code: PG_UNIQUE_VIOLATION
            }, function(err) {
              throw new UniqueConstraintError(err);
            })["catch"]({
              code: PG_FOREIGN_KEY_VIOLATION
            }, function(err) {
              throw new ForeignKeyConstraintError(err);
            }).then(createResult);
          };
          rollback = (function(_this) {
            return function() {
              var promise;
              promise = _this.executeSql('ROLLBACK;');
              _close();
              return promise;
            };
          })(this);
          end = (function(_this) {
            return function() {
              var promise;
              promise = _this.executeSql('COMMIT;');
              _close();
              return promise;
            };
          })(this);
          PostgresTx.__super__.constructor.call(this, _stackTraceErr, executeSql, rollback, end);
        }

        PostgresTx.prototype.tableList = function(extraWhereClause, callback) {
          if (extraWhereClause == null) {
            extraWhereClause = '';
          }
          if ((callback == null) && _.isFunction(extraWhereClause)) {
            callback = extraWhereClause;
            extraWhereClause = '';
          }
          if (extraWhereClause !== '') {
            extraWhereClause = 'WHERE ' + extraWhereClause;
          }
          return this.executeSql("SELECT * FROM (SELECT tablename as name FROM pg_tables WHERE schemaname = 'public') t " + extraWhereClause + ";", [], callback);
        };

        PostgresTx.prototype.dropTable = function(tableName, ifExists, callback) {
          if (ifExists == null) {
            ifExists = true;
          }
          return this.executeSql('DROP TABLE ' + (ifExists === true ? 'IF EXISTS ' : '') + '"' + tableName + '" CASCADE;', [], callback);
        };

        return PostgresTx;

      })(Tx);
      return _.extend({
        engine: 'postgres',
        executeSql: atomicExecuteSql,
        transaction: createTransaction(function(resolve, reject, stackTraceErr) {
          return pool.connect(function(err, client, done) {
            var tx;
            if (err) {
              console.error('Error connecting', err, err.stack);
              process.exit(1);
            }
            tx = new PostgresTx(client, done, stackTraceErr);
            if (process.env.PG_SCHEMA != null) {
              tx.executeSql('SET search_path TO "' + process.env.PG_SCHEMA + '"');
            }
            tx.executeSql('START TRANSACTION;');
            return resolve(tx);
          });
        })
      }, alwaysExport);
    };
  }

  try {
    mysql = require('mysql');
  } catch (error) {}

  if (mysql != null) {
    exports.mysql = function(options) {
      var MYSQL_FOREIGN_KEY_VIOLATION, MYSQL_UNIQUE_VIOLATION, MySqlTx, _pool, createResult;
      MYSQL_UNIQUE_VIOLATION = 'ER_DUP_ENTRY';
      MYSQL_FOREIGN_KEY_VIOLATION = 'ER_ROW_IS_REFERENCED';
      _pool = mysql.createPool(options);
      _pool.on('connection', function(_db) {
        return _db.query("SET sql_mode='ANSI_QUOTES';");
      });
      createResult = function(rows) {
        return {
          rows: {
            length: (rows != null ? rows.length : void 0) || 0,
            item: function(i) {
              return rows[i];
            },
            forEach: function(iterator, thisArg) {
              return rows.forEach(iterator, thisArg);
            },
            map: function(iterator, thisArg) {
              return rows.map(iterator, thisArg);
            }
          },
          rowsAffected: rows.affectedRows,
          insertId: rows.insertId || null
        };
      };
      MySqlTx = (function(superClass) {
        extend(MySqlTx, superClass);

        function MySqlTx(_db, _close, _stackTraceErr) {
          var end, executeSql, rollback;
          executeSql = function(sql, bindings) {
            return Promise.fromCallback(function(callback) {
              return _db.query(sql, bindings, callback);
            })["catch"]({
              code: MYSQL_UNIQUE_VIOLATION
            }, function(err) {
              throw new UniqueConstraintError(err);
            })["catch"]({
              code: MYSQL_FOREIGN_KEY_VIOLATION
            }, function(err) {
              throw new ForeignKeyConstraintError(err);
            }).then(createResult);
          };
          rollback = (function(_this) {
            return function() {
              var promise;
              promise = _this.executeSql('ROLLBACK;');
              _close();
              return promise;
            };
          })(this);
          end = (function(_this) {
            return function() {
              var promise;
              promise = _this.executeSql('COMMIT;');
              _close();
              return promise;
            };
          })(this);
          MySqlTx.__super__.constructor.call(this, _stackTraceErr, executeSql, rollback, end);
        }

        MySqlTx.prototype.tableList = function(extraWhereClause, callback) {
          if (extraWhereClause == null) {
            extraWhereClause = '';
          }
          if ((callback == null) && _.isFunction(extraWhereClause)) {
            callback = extraWhereClause;
            extraWhereClause = '';
          }
          if (extraWhereClause !== '') {
            extraWhereClause = ' WHERE ' + extraWhereClause;
          }
          return this.executeSql('SELECT name FROM (SELECT table_name as name FROM information_schema.tables WHERE table_schema = ?) t' + extraWhereClause + ';', [options.database], callback);
        };

        MySqlTx.prototype.dropTable = function(tableName, ifExists, callback) {
          if (ifExists == null) {
            ifExists = true;
          }
          return this.executeSql('DROP TABLE ' + (ifExists === true ? 'IF EXISTS ' : '') + '"' + tableName + '";', [], callback);
        };

        return MySqlTx;

      })(Tx);
      return _.extend({
        engine: 'mysql',
        executeSql: atomicExecuteSql,
        transaction: createTransaction(function(resolve, reject, stackTraceErr) {
          return _pool.getConnection(function(err, _db) {
            var _close, tx;
            if (err) {
              console.error('Error connecting', err, err.stack);
              process.exit(1);
            }
            _close = function() {
              return _db.release();
            };
            tx = new MySqlTx(_db, _close, stackTraceErr);
            tx.executeSql('START TRANSACTION;');
            return resolve(tx);
          });
        })
      }, alwaysExport);
    };
  }

  if (typeof openDatabase !== "undefined" && openDatabase !== null) {
    exports.websql = function(databaseName) {
      var WEBSQL_CONSTRAINT_ERR, WebSqlTx, _db, createResult, getInsertId;
      WEBSQL_CONSTRAINT_ERR = 6;
      _db = openDatabase(databaseName, '1.0', 'rulemotion', 2 * 1024 * 1024);
      getInsertId = function(result) {
        try {
          return result.insertId;
        } catch (error) {}
      };
      createResult = function(result) {
        return {
          rows: {
            length: result.rows.length,
            item: function(i) {
              return _.clone(result.rows.item(i));
            },
            forEach: function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              this.map.apply(this, args);
            },
            map: function(iterator, thisArg) {
              var i, j, ref, results;
              results = [];
              for (i = j = 0, ref = result.rows.length; j < ref; i = j += 1) {
                results.push(iterator.call(thisArg, this.item(i), i, result.rows));
              }
              return results;
            }
          },
          rowsAffected: result.rowsAffected,
          insertId: getInsertId(result)
        };
      };
      WebSqlTx = (function(superClass) {
        extend(WebSqlTx, superClass);

        function WebSqlTx(_tx, _stackTraceErr) {
          var asyncRecurse, end, executeSql, queue, rollback, running;
          running = true;
          queue = [];
          asyncRecurse = function() {
            var args;
            while (args = queue.pop()) {
              console.debug('Running', args[0]);
              _tx.executeSql.apply(_tx, args);
            }
            if (running === true) {
              console.debug('Looping');
              return _tx.executeSql('SELECT 0', [], asyncRecurse);
            }
          };
          asyncRecurse();
          executeSql = function(sql, bindings) {
            return new Promise(function(resolve, reject) {
              var errorCallback, successCallback;
              sql = bindDefaultValues(sql, bindings);
              successCallback = function(_tx, _results) {
                return resolve(_results);
              };
              errorCallback = function(_tx, err) {
                return reject(err);
              };
              return queue.push([sql, bindings, successCallback, errorCallback]);
            })["catch"]({
              code: WEBSQL_CONSTRAINT_ERR
            }, function() {
              throw new ConstraintError('Constraint failed.');
            }).then(createResult);
          };
          rollback = function() {
            return new Promise(function(resolve) {
              var errorCallback, successCallback;
              successCallback = function() {
                resolve();
                throw new Error('Rollback');
              };
              errorCallback = function() {
                resolve();
                return true;
              };
              queue = [['RUN A FAILING STATEMENT TO ROLLBACK', [], successCallback, errorCallback]];
              return running = false;
            });
          };
          end = function() {
            running = false;
            return Promise.fulfilled();
          };
          WebSqlTx.__super__.constructor.call(this, _stackTraceErr, executeSql, rollback, end);
        }

        WebSqlTx.prototype.tableList = function(extraWhereClause, callback) {
          if (extraWhereClause == null) {
            extraWhereClause = '';
          }
          if ((callback == null) && _.isFunction(extraWhereClause)) {
            callback = extraWhereClause;
            extraWhereClause = '';
          }
          if (extraWhereClause !== '') {
            extraWhereClause = ' AND ' + extraWhereClause;
          }
          return this.executeSql("SELECT name, sql FROM sqlite_master WHERE type='table' AND name NOT IN ('__WebKitDatabaseInfoTable__', 'sqlite_sequence')" + extraWhereClause + ';', [], callback);
        };

        WebSqlTx.prototype.dropTable = function(tableName, ifExists, callback) {
          if (ifExists == null) {
            ifExists = true;
          }
          return this.executeSql('DROP TABLE ' + (ifExists === true ? 'IF EXISTS ' : '') + '"' + tableName + '";', [], callback);
        };

        return WebSqlTx;

      })(Tx);
      return _.extend({
        engine: 'websql',
        executeSql: atomicExecuteSql,
        transaction: createTransaction(function(resolve, reject, stackTraceErr) {
          return _db.transaction(function(_tx) {
            return resolve(new WebSqlTx(_tx, stackTraceErr));
          });
        })
      }, alwaysExport);
    };
  }

  exports.connect = function(databaseOptions) {
    if ((exports[databaseOptions.engine] == null) || databaseOptions.engine === 'connect') {
      throw new Error('Unsupported database engine: ' + databaseOptions.engine);
    }
    return exports[databaseOptions.engine](databaseOptions.params);
  };

}).call(this);

//# sourceMappingURL=db.js.map
