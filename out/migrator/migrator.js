// Generated by CoffeeScript 1.12.6
(function() {
  var MigrationError, Promise, TypedError, _, modelText, permissions,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Promise = require('bluebird');

  TypedError = require('typed-error');

  modelText = require('./migrations.sbvr');

  permissions = require('../sbvr-api/permissions');

  exports.MigrationError = MigrationError = (function(superClass) {
    extend(MigrationError, superClass);

    function MigrationError() {
      return MigrationError.__super__.constructor.apply(this, arguments);
    }

    return MigrationError;

  })(TypedError);

  exports.run = function(tx, model) {
    var modelName;
    if (!_.some(model.migrations)) {
      return Promise.fulfilled();
    }
    modelName = model.apiRoot;
    return this.checkModelAlreadyExists(tx, modelName).then((function(_this) {
      return function(exists) {
        if (!exists) {
          _this.logger.info('First time model has executed, skipping migrations');
          return _this.setExecutedMigrations(tx, modelName, _.keys(model.migrations));
        }
        return _this.getExecutedMigrations(tx, modelName).then(function(executedMigrations) {
          var pendingMigrations;
          pendingMigrations = _this.filterAndSortPendingMigrations(model.migrations, executedMigrations);
          if (!_.some(pendingMigrations)) {
            return;
          }
          return _this.executeMigrations(tx, pendingMigrations).then(function(newlyExecutedMigrations) {
            return _this.setExecutedMigrations(tx, modelName, slice.call(executedMigrations).concat(slice.call(newlyExecutedMigrations)));
          });
        });
      };
    })(this));
  };

  exports.checkModelAlreadyExists = function(tx, modelName) {
    return this.sbvrUtils.api.dev.get({
      resource: 'model',
      passthrough: {
        tx: tx,
        req: permissions.rootRead
      },
      options: {
        select: ['is_of__vocabulary'],
        top: 1,
        filter: {
          is_of__vocabulary: modelName
        }
      }
    }).then(_.some);
  };

  exports.getExecutedMigrations = function(tx, modelName) {
    return this.migrationsApi.get({
      resource: 'migration',
      id: modelName,
      passthrough: {
        tx: tx,
        req: permissions.rootRead
      },
      options: {
        select: ['executed_migrations']
      }
    }).then(function(data) {
      return (data != null ? data.executed_migrations : void 0) || [];
    });
  };

  exports.setExecutedMigrations = function(tx, modelName, executedMigrations) {
    return this.migrationsApi.put({
      resource: 'migration',
      id: modelName,
      passthrough: {
        tx: tx,
        req: permissions.root
      },
      body: {
        model_name: modelName,
        executed_migrations: executedMigrations
      }
    });
  };

  exports.filterAndSortPendingMigrations = function(migrations, executedMigrations) {
    return _(migrations).omit(executedMigrations).toPairs().sortBy(_.head).value();
  };

  exports.executeMigrations = function(tx, migrations) {
    if (migrations == null) {
      migrations = [];
    }
    return Promise.map(migrations, this.executeMigration.bind(this, tx), {
      concurrency: 1
    })["catch"]((function(_this) {
      return function(err) {
        _this.logger.error('Error while executing migrations, rolled back');
        throw new MigrationError(err);
      };
    })(this))["return"](_.map(migrations, _.head));
  };

  exports.executeMigration = function(tx, arg) {
    var key, migration;
    key = arg[0], migration = arg[1];
    this.logger.info("Running migration " + (JSON.stringify(key)));
    switch (typeof migration) {
      case 'function':
        return migration(tx, this.sbvrUtils);
      case 'string':
        return tx.executeSql(migration);
    }
  };

  exports.config = {
    models: [
      {
        modelName: 'migrations',
        apiRoot: 'migrations',
        modelText: modelText,
        customServerCode: exports
      }
    ]
  };

  exports.setup = function(app, sbvrUtils, db, callback) {
    this.sbvrUtils = sbvrUtils;
    this.migrationsApi = this.sbvrUtils.api.migrations;
    this.logger = this.migrationsApi.logger;
    return callback();
  };

}).call(this);

//# sourceMappingURL=migrator.js.map
